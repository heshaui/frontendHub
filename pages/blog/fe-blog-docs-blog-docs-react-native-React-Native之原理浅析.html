<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Native之原理浅析 - FrontendHub</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/content.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body class="content-page">
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="../../index.html" style="color: inherit; text-decoration: none; display: flex; align-items: center; gap: 0.5rem;">
                    <i class="fas fa-code"></i>
                    <span>FrontendHub</span>
                </a>
            </div>
            <button class="nav-toggle" id="navToggle">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-menu" id="navMenu">
                <li><a href="../../index.html">首页</a></li>
                <li><a href="../index.html#features">特色</a></li>
                <li><a href="../index.html#courses">课程</a></li>
                <li><a href="../index.html#resources">资源</a></li>
            </ul>
        </div>
    </nav>

    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <div class="container">
            <a href="../../index.html"><i class="fas fa-home"></i> 首页</a>
            <i class="fas fa-chevron-right"></i>
            <span>React Native之原理浅析</span>
        </div>
    </div>

    <!-- 主要内容区 -->
    <main class="content-main">
        <div class="container">
            <div class="content-layout">
                <!-- 侧边栏目录 -->
                <aside class="sidebar">
                    <div class="sidebar-sticky">
                        <h3><i class="fas fa-list"></i> 目录</h3>
                        <nav class="toc" id="toc">
                            <!-- 目录将通过JavaScript自动生成 -->
                        </nav>
                    </div>
                </aside>

                <!-- 文章内容 -->
                <article class="article">
                    <header class="article-header">
                        <h1>React Native之原理浅析</h1>
                        <div class="article-meta">
                            <span><i class="far fa-calendar"></i> 更新时间：2025-12-23</span>
                            <span><i class="far fa-clock"></i> 阅读时长：约 15 分钟</span>
                        </div>
                    </header>

                    <div class="article-content">
<div class="content__default"><h2 id="一、javascriptcore"><a href="#一、javascriptcore" class="header-anchor">#</a> 一、JavaScriptCore</h2> <blockquote><p>讲React Native之前，了解JavaScriptCore会有帮助，也是必要的。React Native的核心驱动力就来自于JS Engine. 你写的所有JS和JSX代码都会被JS Engine来执行, 没有JS Engine的参与，你是无法享受ReactJS给原生应用开发带来的便利的。在iOS上，默认的就是JavaScriptCore， iOS 7之后的设备都支持. iOS 不允许用自己的JS Engine. JavaScriptCore来自于WebKit, 所以，安卓上默认也是用JavaScriptCore</p></blockquote> <blockquote><p>你深入了解<code>React Native</code>的第一站应该是 <code>JavaScriptCore</code></p></blockquote> <ul><li><code>JavaScriptCore</code>在<code>iOS</code>平台上给<code>React Native</code>提供的接口也仅限于那几个接口，你弄明白了<code>JavaScriptCore</code>那几个接口, React Native 剩下的魔法秘密都可以顺藤摸瓜来分析了。</li> <li>接下来要讲解的就是Facebook围绕这几个接口以及用一个React来颠覆整个native开发所做的精妙设计和封装</li></ul> <h2 id="二、浏览器工作原理"><a href="#二、浏览器工作原理" class="header-anchor">#</a> 二、浏览器工作原理</h2> <ul><li>浏览器通过<code>Dom Render</code>来渲染所有的元素.</li> <li>浏览器有一整套的UI控件，样式和功能都是按照html标准实现的</li> <li>浏览器能读懂html和css。</li> <li>html告诉浏览器绘制什么控件(html tag)，css告诉浏览器每个类型的控件(html tag)具体长什么样。</li> <li>浏览器的主要作用就是通过解析html来形成dom树，然后通过css来点缀和装饰树上的每一个节点</li></ul> <p><strong>UI的描述和呈现分离开了</strong></p> <ol><li>html文本描述了页面应该有哪些功能，css告诉浏览器该长什么样。</li> <li>浏览器引擎通过解析html和css，翻译成一些列的预定义UI控件，</li> <li>然后UI控件去调用操作系统绘图指令去绘制图像展现给用户。</li> <li>Javascript可有可无，主要用于html里面一些用户事件响应，DOM操作、异步网络请求和一些简单的计算</li></ol> <blockquote><p>在react native 里面，1和2是不变的，也是用html语言描述页面有哪些功能，然后stylesheet告诉浏览器引擎每个控件应该长什么样。并且和浏览器用的是同一个引擎</p></blockquote> <blockquote><p>在步骤3里面UI控件不再是浏览器内置的控件，而是<code>react native</code>自己实现的一套UI控件（两套，android一套，ios一套），这个切换是在<code>MessageQueque</code>中进行的，并且还可以发现，他们tag也是不一样的</p></blockquote> <p><strong>Javascript在react native里面非常重要</strong></p> <ul><li>它负责管理UI component的生命周期，管理Virtual DOM</li> <li>所有业务逻辑都是用javascript来实现或者衔接</li> <li>调用原生的代码来操纵原生组件。</li> <li>Javascript本身是无绘图能力的，都是通过给原生组件发指令来完成</li></ul> <h2 id="三、react-native-架构"><a href="#三、react-native-架构" class="header-anchor">#</a> 三、React Native 架构</h2> <p><img src="https://s.poetries.top/gitee/2019/10/680.jpeg" alt=""></p> <ul><li>绿色的是我们应用开发的部分。我们写的代码基本上都是在这一层</li> <li>蓝色代表公用的跨平台的代码和工具引擎，一般我们不会动蓝色部分的代码</li> <li>黄色代码平台相关的代码，做定制化的时候会添加修改代码。不跨平台，要针对平台写不同的代码。iOS写OC, android写java，web写js. 每个bridge都有对应的js文件，js部分是可以共享的，写一份就可以了。如果你想做三端融合，你就得理解这一个东西。如果你要自己定制原生控件，你就得写bridge部分</li> <li>红色部分是系统平台的东西。红色上面有一个虚线，表示所有平台相关的东西都通过bridge隔离开来了</li> <li>大部分情况下我们只用写绿色的部分，少部分情况下会写黄色的部分。你如果对基础架构和开源感兴趣，你可以写蓝色部分，然后尝试给那些大的开源项目提交代码。红色部分是独立于React Native的</li></ul> <h2 id="四、react-native、react和javascriptcore的关系"><a href="#四、react-native、react和javascriptcore的关系" class="header-anchor">#</a> 四、React Native、React和JavascriptCore的关系</h2> <blockquote><p>React Native最重要的三个概念应该就是<code>React Native</code>、<code>React</code>和<code>JavascriptCore</code></p></blockquote> <ul><li>React是一个纯JS库，所有的React代码和所有其它的js代码都需要JS Engine来解释执行。因为种种原因，浏览器里面的JS代码是不允许调用自定义的原生代码的，而React又是为浏览器JS开发的一套库，所以，比较容易理解的事实是React是一个纯JS库，它封装了一套Virtual Dom的概念，实现了数据驱动编程的模式，为复杂的Web UI实现了一种无状态管理的机制, 标准的HTML/CSS之外的事情，它无能为力。调用原生控件，驱动声卡显卡，读写磁盘文件，自定义网络库等等，这是JS/React无能为力的</li> <li>你可以简单理解为React是一个纯JS 函数， 它接受特定格式的字符串数据，输出计算好的字符串数据</li> <li>JS Engine负责调用并解析运行这个函数</li> <li><code>React Native</code>呢？ 它比较复杂。复杂在哪里？前面我们说了React 是纯JS库，意味着React只能运行JS代码，通过JS Engine提供的接口(Html Tag)绘制html支持的那些元素，驱动有限的声卡显卡。简单点说, React只能做浏览器允许它做的事情, 不能调用原生接口， 很多的事情也只能干瞪眼</li></ul> <p><strong>React Native它可不一样</strong></p> <ul><li>第一点，驱动关系不一样。前面我们说的是, JS Engine来解析执行React脚本, 所以，React由浏览器(最终还是JS Engine)来驱动. 到了React Native这里，RN的原生代码(Timer和用户事件)驱动JS Engine, 然后JS Engine解析执行React或者相关的JS代码，然后把计算好的结果返回给Native code. 然后, Native code 根据JS计算出来的结果驱动设备上所有能驱动的硬件。重点，所有的硬件。也就是说，在RN这里，JS代码已经摆脱JS Engine(浏览器)的限制，可以调用所有原生接口啦</li> <li>第二点, 它利用React的Virtual Dom和数据驱动编程概念，简化了我们原生应用的开发, 同时，它不由浏览器去绘制，只计算出绘制指令，最终的绘制还是由原生控件去负责，保证了原生的用户体验</li></ul> <p><strong>React Native组件结构</strong></p> <blockquote><p>驱动硬件的能力决定能一个软件能做多大的事情，有多大的主控性。研究过操作系统底层东西或者汇编的同学明白，我们大部分时候写的代码是受限的代码，很多特权指令我们是没法使用的，很多设备我们是不允许直接驱动的。我们现在的编程里面几乎已经没有人提中断了，没有中断，硬件的操作几乎会成为一场灾难.</p></blockquote> <p>在一定程度上，React Native和NodeJS有异曲同工之妙。它们都是通过扩展JavaScript Engine, 使它具备强大的本地资源和原生接口调用能力，然后结合JavaScript丰富的库和社区和及其稳定的跨平台能力，把javascript的魔力在浏览器之外的地方充分发挥出来</p> <p><strong>JavaScriptCore + ReactJS + Bridges 就成了React Native</strong></p> <ul><li><code>JavaScriptCore</code>负责JS代码解释执行</li> <li><code>ReactJS</code>负责描述和管理<code>VirtualDom</code>,指挥原生组件进行绘制和更新，同时很多计算逻辑也在js里面进行。ReactJS自身是不直接绘制UI的，UI绘制是非常耗时的操作，原生组件最擅长这事情。</li> <li><code>Bridges</code>用来翻译ReactJS的绘制指令给原生组件进行绘制，同时把原生组件接收到的用户事件反馈给<code>ReactJS</code>。
要在不同的平台实现不同的效果就可以通过定制<code>Bridges</code>来实现</li></ul> <blockquote><p>深入 <code>Bridge</code> 前面有提到, RN厉害在于它能打通JS和Native Code, 让JS能够调用丰富的原生接口,充分发挥硬件的能力, 实现非常复杂的效果,同时能保证效率和跨平台性。</p></blockquote> <blockquote><p>打通RN任督二脉的关键组件就是<code>Bridge</code>. 在RN中如果没有Bridge, JS还是那个JS，只能调用JS Engine提供的有限接口，绘制标准html提供的那些效果,那些摄像头，指纹，3D加速,声卡, 视频播放定制等等，JS都只能流流口水，原生的、平台相关的、设备相关的效果做不了， 除非对浏览器进行定制</p></blockquote> <ul><li>Bridge的作用就是给RN内嵌的JS Engine提供原生接口的扩展供JS调用。所有的本地存储、图片资源访问、图形图像绘制、3D加速、网络访问、震动效果、NFC、原生控件绘制、地图、定位、通知等都是通过Bridge封装成JS接口以后注入JS Engine供JS调用。理论上，任何原生代码能实现的效果都可以通过Bridge封装成JS可以调用的组件和方法, 以JS模块的形式提供给RN使用。</li> <li>每一个支持RN的原生功能必须同时有一个原生模块和一个JS模块，JS模块是原生模块的封装，方便Javascript调用其接口。Bridge会负责管理原生模块和对应JS模块之间的沟通, 通过Bridge, JS代码能够驱动所有原生接口，实现各种原生酷炫的效果。</li> <li>RN中JS和Native分隔非常清晰，JS不会直接引用Native层的对象实例，Native也不会直接引用JS层的对象实例(所有Native和JS互掉都是通过Bridge层会几个最基础的方法衔接的)。</li> <li><code>Bridge</code> 原生代码负责管理原生模块并生成对应的JS模块信息供JS代码调用。每个功能JS层的封装主要是针对ReactJS做适配，让原生模块的功能能够更加容易被用ReactJS调用。<code>MessageQueue.js</code>是<code>Bridge</code>在JS层的代理，所有JS2N和N2JS的调用都会经过<code>MessageQueue.js</code>来转发。JS和Native之间不存在任何指针传递，所有参数都是字符串传递。所有的instance都会被在JS和Native两边分别编号，然后做一个映射,然后那个数字/字符串编号会做为一个查找依据来定位跨界对象。</li></ul> <h2 id="五、bridge各模块简介"><a href="#五、bridge各模块简介" class="header-anchor">#</a> 五、Bridge各模块简介</h2> <h3 id="_5-1-rctrootview"><a href="#_5-1-rctrootview" class="header-anchor">#</a> 5.1 RCTRootView</h3> <ul><li><code>RCTRootView</code>是<code>React Native</code>加载的地方,是万物之源。从这里开始，我们有了JS Engine, JS代码被加载进来，对应的原生模块也被加载进来，然后js loop开始运行。 js loop的驱动来源是Timer和Event Loop(用户事件). js loop跑起来以后应用就可以持续不停地跑下去了。</li> <li>如果你要通过调试来理解RN底层原理，你也应该是从RCTRootView着手，顺藤摸瓜。</li> <li>每个项目的<code>AppDelegate.m</code>的- (BOOL)application:didFinishLaunchingWithOptions:里面都可以看到RCTRootView的初始化代码，RCTRootView初始化完成以后，整个React Native运行环境就已经初始化好了，JS代码也加载完毕，所有React的绘制都会有这个RCTRootView来管理。</li></ul> <p><strong>RCTRootView做的事情如下</strong></p> <ul><li>创建并且持有<code>RCTBridge</code></li> <li>加载<code>JS Bundle</code>并且初始化JS运行环境.</li> <li>初始化JS运行环境的时候在App里面显示<code>loadingView</code>, 注意不是屏幕顶部的那个下拉悬浮进度提示条. RN第一次加载之后每次启动非常快，很少能意识到这个加载过程了。loadingView默认情况下为空, 也就是默认是没有效果的。loadingView可以被自定义，直接覆盖RCTRootView.loadingView就可以了.开发模式下RN app第一次启动因为需要完整打包整个js所以可以很明显看到加载的过程，加载第一次以后就看不到很明显的加载过程了，可以执行下面的命令来触发重新打包整个js来观察<code>loadingView</code>的效果 <code>watchman watch-del-all &amp;&amp; rm -rf node_modules/ &amp;&amp; yarn install &amp;&amp; yarn start – –reset-cache</code>, 然后杀掉<code>app</code>重启你就会看到一个很明显的进度提示.</li> <li><code>JS</code>运行环境准备好以后把加载视图用<code>RCTRootContentView</code>替换加载视图</li> <li>有准备工作就绪以后调用<code>AppRegistry.runApplication</code>正式启动RN JS代码，从<code>Root Component()</code>开始UI绘制</li></ul> <blockquote><p>一个App可以有多个<code>RCTRootView</code>, 初始化的时候需要手动传输<code>Bridge</code>做为参数，全局可以有多个<code>RCTRootView</code>, 但是只能有一个<code>Bridge</code></p></blockquote> <blockquote><p>如果你做过<code>React Native</code>和原生代码混编，你会发现混编就是把<code>AppDelegate</code>里面那段初始化<code>RCTRootView</code>的代码移动到需要混编的地方，然后把<code>RCTRootView</code>做为一个普通的<code>subview</code>来加载到原生的<code>view</code>里面去，非常简单。不过这地方也要注意处理好单Bridge实例的问题，同时，混编里面要注意<code>RCTRootView</code>如果销毁过早可能会引发JS回调奔溃的问题</p></blockquote> <h3 id="_5-2-rctrootcontentview"><a href="#_5-2-rctrootcontentview" class="header-anchor">#</a> 5.2 RCTRootContentView</h3> <ul><li><code>RCTRootContentView reactTag</code>在默认情况下为1. 在<code>Xcode view Hierarchy debugger</code> 下可以看到，最顶层为<code>RCTRootView</code>, 里面嵌套的是<code>RCTRootContentView</code>, 从<code>RCTRootContentView</code>开始，每个View都有一个<code>reactTag</code></li> <li><code>RCTRootView</code>继承自UIView, RCTRootView主要负责初始化<code>JS Environment</code>和React代码，然后管理整个运行环境的生命周期。 <code>RCTRootContentView</code>继承自<code>RCTView</code>, <code>RCTView</code>继承自UIView, RCTView封装了React Component Node更新和渲染的逻辑， <code>RCTRootContentView</code>会管理所有react ui components. <code>RCTRootContentView</code>同时负责处理所有touch事件</li></ul> <h3 id="_5-3-rctbridge"><a href="#_5-3-rctbridge" class="header-anchor">#</a> 5.3 RCTBridge</h3> <blockquote><p>这是一个加载和初始化专用类，用于前期JS的初始化和原生代码的加载</p></blockquote> <ul><li>负责加载各个Bridge模块供JS调用</li> <li>找到并注册所有实现了<code>RCTBridgeModule protocol</code>的类, 供JS后期使用.</li> <li>创建和持有 <code>RCTBatchedBridge</code></li></ul> <h3 id="_5-4-rctbatchedbridge"><a href="#_5-4-rctbatchedbridge" class="header-anchor">#</a> 5.4 RCTBatchedBridge</h3> <blockquote><p>如果RCTBridge是总裁, 那么RCTBatchedBridge就是副总裁。前者负责发号施令，后者负责实施落地</p></blockquote> <ul><li>负责Native和JS之间的相互调用(消息通信)</li> <li>持有<code>JSExecutor</code></li> <li>实例化所有在RCTBridge里面注册了的<code>native node_modules</code></li> <li>创建JS运行环境, 注入<code>native hooks</code> 和<code>modules</code>, 执行 JS bundle script</li> <li>管理JS run loop, 批量把所有JS到native的调用翻译成<code>native invocations</code></li> <li>批量管理原生代码到JS的调用，把这些调用翻译成JS消息发送给<code>JS executor</code></li></ul> <h3 id="_5-5-rctjavascriptloader"><a href="#_5-5-rctjavascriptloader" class="header-anchor">#</a> 5.5 RCTJavaScriptLoader</h3> <blockquote><p>这是实现远程代码加载的核心。热更新，开发环境代码加载，静态<code>jsbundle</code>加载都离不开这个工具。</p></blockquote> <ul><li>从指定的地方(<code>bundle</code>, <code>http server</code>)加载 <code>script bundle</code></li> <li>把加载完成的脚本用<code>string</code>的形式返回</li> <li>处理所有获取代码、打包代码时遇到的错误</li></ul> <h3 id="_5-6-rctcontextexecutor"><a href="#_5-6-rctcontextexecutor" class="header-anchor">#</a> 5.6 RCTContextExecutor</h3> <ul><li>封装了基础的JS和原生代码互掉和管理逻辑，是JS引擎切换的基础。通过不同的RCTCOntextExecutor来适配不同的JS Engine，让我们的React JS可以在iOS、Android、chrome甚至是自定义的js engine里面执行。这也是为何我们能在chrome里面直接调试js代码的原因</li> <li>管理和执行所有N2J调用</li></ul> <h3 id="_5-7-rctmoduledata"><a href="#_5-7-rctmoduledata" class="header-anchor">#</a> 5.7 RCTModuleData</h3> <ul><li>加载和管理所有和JS有交互的原生代码。把需要和JS交互的代码按照一定的规则自动封装成JS模块</li> <li>收集所有桥接模块的信息，供注入到JS运行环境</li></ul> <h3 id="_5-8-rctmodulemethod"><a href="#_5-8-rctmodulemethod" class="header-anchor">#</a> 5.8 RCTModuleMethod</h3> <blockquote><p>记录所有原生代码的导出函数地址(JS里面是不能直接持有原生对象的)，同时生成对应的字符串映射到该函数地址。JS调用原生函数的时候会通过message的形式调用过来</p></blockquote> <ul><li>记录所有的原生代码的函数地址，并且生成对应的字符串映射到该地址</li> <li>记录所有的block的地址并且映射到唯一的一个id</li> <li>翻译所有<code>J2N call</code>，然后执行对应的native方法</li></ul> <blockquote><ul><li>如果是原生方法的调用则直接通过方法名调用，MessageQueue会帮忙把Method翻译成MethodID, 然后转发消息给原生代码，传递函数签名和参数给原生MessageQueue, 最终给RCTModuleMethod解析调用最终的方法</li> <li>如果JS调用的是一个回调block，MessageQueue会把回调对象转化成一个一次性的block id, 然后传递给RCTModuleMethod, 最终由RCTModuleMethod解析调用。基本上和方法调用一样，只不过生命周期会不一样，block是动态生成的，要及时销毁，要不然会导致内存泄漏</li></ul></blockquote> <blockquote><p>实际上是不存在原生MessageQueue对象模块的，JS的MessageQueue对应到原生层就是RCTModuleData &amp; RCTModuleMethod的组合, MessageQueue的到原生层的调用先经过RCTModuleData和RCTModuleMethod翻译成原生代码调用，然后执行</p></blockquote> <h3 id="_5-9-messagequeue"><a href="#_5-9-messagequeue" class="header-anchor">#</a> 5.9 MessageQueue</h3> <ul><li>这是核心中的核心。整个react native对浏览器内核是未做任何定制的，完全依赖浏览器内核的标准接口在运作。它怎么实现UI的完全定制的呢？它实际上未使用浏览器内核的任何UI绘制功能，注意是未使用UI绘制功能。它利用javascript引擎强大的DOM操作管理能力来管理所有UI节点，每次刷新前把所有节点信息更新完毕以后再给yoga做排版，然后再调用原生组件来绘制。javascript是整个系统的核心语言。</li> <li>我们可以把浏览器看成一个盒子，javascript引擎是盒子里面的总管，DOM是javascript引擎内置的，javascript和javascript引擎也是无缝链接的。react native是怎么跳出这个盒子去调用外部原生组件来绘制UI的呢？秘密就在MessageQueue。</li> <li>javascript引擎对原生代码的调用都是通过一套固定的接口来实现，这套接口的主要作用就是记录原生接口的地址和对应的javascript的函数名称，然后在javascript调用该函数的时候把调用转发给原生接口</li></ul> <h2 id="六、react-native-初始化"><a href="#六、react-native-初始化" class="header-anchor">#</a> 六、React Native 初始化</h2> <blockquote><p><code>React Native</code>的初始化从<code>RootView</code>开始，默认在<code>AppDelegate.m:- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code> 里面会有<code>RootViewd</code>的初始化逻辑，调试的时候可以从这里入手</p></blockquote> <p><strong>React Native的初始化分为几个步骤</strong></p> <ul><li>原生代码加载</li> <li><code>JS Engine</code>初始化(生成一个空的JS引擎)</li> <li>JS基础设施初始化. 主要是require等基本模块的加载并替换JS默认的实现。自定义<code>require</code>, <code>Warning window</code>, <code>Alert window</code>, <code>fetch</code>等都是在这里进行的。基础设施初始化好以后就可以开始加载js代码了</li> <li>遍历加载所有要导出给JS用的原生模块和方法, 生成对应的JS模块信息，打包成json的格式给JS Engine, 准确地说是给MessageQueue.</li></ul> <p><strong>这里需要提一下的是</strong></p> <blockquote><p>这里的导出是没有对象的，只有方法和模块。JS不是一个标准的面向对象语言，刚从Java转JavaScript的同学都会在面向对象这个概念上栽跟头，这里特别提醒一下</p></blockquote> <h3 id="_6-1-原生代码初始化"><a href="#_6-1-原生代码初始化" class="header-anchor">#</a> 6.1 原生代码初始化</h3> <blockquote><p>这里讨论的主要是RN相关的原生代码和用户自定义的RN模块的原生代码的加载和初始化。原生代码初始化主要分两步</p></blockquote> <ul><li>静态加载。iOS没有动态加载原生代码的接口，所有的代码都在编译的初期就已经编译为静态代码并且链接好，程序启动的时候所有的原生代码都会加载好。这是原生代码的静态加载，iOS里面没有动态加载原生代码的概念，这也是为何没有静态代码热更新的原因</li> <li>RN模块解析和注入JS。这是加载的第二步。在RootView初始化的时候会遍历所有被标记为RCTModule的原生模块，生成一个json格式的模块信息，里面包含模块名称和方法名称，然后注入到JS Engine, 由MessageQueue记录下来。原生代码在生成json模块信息的时候同时会在原生代码这边维护一个名称字典，用来把模块和方法的名称映射到原生代码的地址上去，用于JS调用原生代码的翻译</li></ul> <h3 id="_6-2-javascript环境初始化"><a href="#_6-2-javascript环境初始化" class="header-anchor">#</a> 6.2 Javascript环境初始化</h3> <ul><li>RN的初始化是从RCRootView开始的，所有的绘制都会在这个RootView里面进行(Alert除外)</li> <li>RootView做的第一件事情就是初始化一个空的JS Engine。 这个空的JS Engine里面包含一些最基础的模块和方法(fetch, require, alert等), 没有UI绘制模块。 RN的工作就是替换这些基础的模块和方法，然后把RN的UI绘制模块加载并注入到JS Engine.</li></ul> <p><strong>JS Engine不直接管理UI的绘制</strong></p> <ul><li>所有的绘制由原生控制的UI事件和Timer触发</li> <li>影响界面刷新的事件发生以后一部分直接由原生控件消化掉，直接更新原生控件。剩下的部分会通过<code>Bridge</code>派发给MessageQueue，然后在JS层进行业务逻辑的计算，再由<code>React</code>来进行Virtual Dom的管理和更新。<code>Virtual Dom</code>再通过MessageQueue发送重绘指令给对应的原生组件进行UI更新</li></ul> <h3 id="_6-3-nativemodules加载"><a href="#_6-3-nativemodules加载" class="header-anchor">#</a> 6.3 NativeModules加载</h3> <ul><li>在OC里面，所有NativeModules要加载进JS Engine都必须遵循一定的协议(protocol)。</li> <li>模块(OC里面的类)需要声明为<code>&lt;RCTBridgeModule&gt;</code>, 然后在类里面还必须调用宏RCT_EXPORT_MODULE() 用来定义一个接口告诉JS当前模块叫什么名字。这个宏可以接受一个可选的参数，指定模块名，不指定的情况下就取类名。</li> <li>对应的JS模块在初始化的时候会调用原生类的[xxx new]方法- 模块声明为<code>&lt;RCTBridgeModule&gt;</code>后只是告诉Native Modules这有一个原生模块，是一个空的模块。要导出任何方法给JS使用都必须手动用宏RCT_EXPORT_METHOD来导出方法给JS用.</li> <li>所有的原生模块都会注册到<code>NativeModules</code>这一个JS模块下面去，你如果想要让自己的模块成为一个顶级模块就必须再写一个JS文件封装一遍NativeModules里面的方法。</li> <li>你如果想自己的方法导出就默认成为顶级方法，那么你需要一个手动去调用JSC的接口，这个在前面章节有讲解。 不建议这样做，因为这样你会失去跨JS引擎的便利性。</li> <li>你可以导出常量到JS里面去, 模块初始化的时候会坚持用户是否有实现<code>constantsToExport</code> 方法, 接受一个常量词典</li></ul> <div class="language- extra-class"><pre class="language-text"><code>- (NSDictionary *)constantsToExport
{
  return @{ @"firstDayOfTheWeek": @"Monday" };// JS里面可以直接调用 ModuleName.firstDayOfTheWeek获取这个常量
}
</code></pre></div><ul><li>常量只会在初始化的时候调用一次，动态修改该方法的返回值无效</li> <li>所有标记为RCT_EXPORT_MODULE的模块都会在程序启动的时候自动注册好这些模块，主要是记录模块名和方法名。只是注册，不一定会初始化。</li> <li><code>Native Modules</code>导出宏具体使用方法见官方文档<code>Native Modules</code></li></ul> <h3 id="_6-4-三个线程"><a href="#_6-4-三个线程" class="header-anchor">#</a> 6.4 三个线程</h3> <blockquote><p>React Native有三个重要的线程:</p></blockquote> <ul><li>Shadow queue. 布局引擎(yoga)计算布局用的</li> <li>Main thread. 主线程。就是操作系统的UI线程。无论是iOS还是android，一个进程都只有一个UI线程，我们常说的主线程. React Native所有UI绘制也是由同一个UI线程来维护</li> <li><code>Javascript thread. javascript</code>线程。 大家都知道javascript是单线程模型，event驱动的异步模型。React Native用了JS引擎，所以也必需有一个独立的js 线程. 所有JS和原生代码的交互都发生在这个线程里。死锁，异常也最容易发生在这个线程</li></ul> <blockquote><p>可以看到Shadow queue是queue而不是thread, 在iOS里面queue是thread之上的一层抽象,GCD里面的一个概念，创建queue的时候可以指定是并行的还是串行的。也就是说，一个queue可能对应多个thread</p></blockquote> <h2 id="七、内部机制"><a href="#七、内部机制" class="header-anchor">#</a> 七、内部机制</h2> <p><strong>内部机制</strong></p> <p><img src="https://s.poetries.top/gitee/2019/10/681.jpg" alt=""></p> <p><strong>JS用时序</strong></p> <p><img src="https://s.poetries.top/gitee/2019/10/682.png" alt=""></p> <h2 id="八、总结"><a href="#八、总结" class="header-anchor">#</a> 八、总结</h2> <h3 id="_8-1-react-native-框架分析"><a href="#_8-1-react-native-框架分析" class="header-anchor">#</a> 8.1 React Native 框架分析</h3> <p><img src="https://s.poetries.top/gitee/2019/10/683.png" alt=""></p> <h3 id="_8-2-层次架构"><a href="#_8-2-层次架构" class="header-anchor">#</a> 8.2 层次架构</h3> <ul><li><strong>Java层</strong>：该层主要提供了Android的UI渲染器<code>UIManager</code>（将JavaScript映射成<code>Android Widget</code>）以及一些其他的功能组件（例如：Fresco、Okhttp）等，在java层均封装为Module，java层核心jar包是react-native.jar，封装了众多上层的interface，如Module，Registry，bridge等</li> <li><strong>C++层</strong>：主要处理Java与JavaScript的通信以及执行JavaScript代码工作，该层封装了JavaScriptCore，执行对js的解析。基于<code>JavaScriptCore</code>，<code>Web</code>开发者可以尽情使用ES6的新特性，如class、箭头操作符等，而且 React Native运行在<code>JavaScriptCore</code>中的，完全不存在浏览器兼容的情况。Bridge桥接了java ， js 通信的核心接口。JSLoader主要是将来自assets目录的或本地file加载javascriptCore，再通过<code>JSCExectutor</code>解析js文件</li> <li><strong>Js层</strong>：该层提供了各种供开发者使用的组件以及一些工具库。
<code>Component</code>：Js层通js/jsx编写的<code>Virtual Dom</code>来构建<code>Component</code>或Module，Virtual DOM是DOM在内存中的一种轻量级表达方式，可以通过不同的渲染引擎生成不同平台下的UI。component的使用在 React 里极为重要, 因为component的存在让计算 DOM diff 更高效。
ReactReconciler : 用于管理顶层组件或子组件的挂载、卸载、重绘</li></ul> <blockquote><p>注：JSCore，即JavaScriptCore，JS解析的核心部分，IOS使用的是内置的<code>JavaScriptCore</code>，Androis上使用的是 https://webkit.org 家的jsc.so。</p></blockquote> <p><strong>Java层核心类及原理，如下所示</strong></p> <p><strong>ReactContext</strong></p> <ul><li>ReactContext继承于ContextWrapper，是ReactNative应用的上下文，通过getContext()去获得，通过它可以访问ReactNative核心类的实现。</li></ul> <p><strong>ReactInstanceManager</strong></p> <ul><li><code>ReactInstanceManager</code>是ReactNative应用总的管理类，创建<code>ReactContext</code>、<code>CatalystInstance</code>等类，解析<code>ReactPackage</code>生成映射表，并且配合<code>ReactRootView</code>管理View的创建与生命周期等功能。</li></ul> <p><strong>ReactRootView</strong></p> <ul><li>为启动入口核心类，负责监听及分发事件并重新渲染元素，App启动后，其将作为App的<code>root view</code>。</li></ul> <p><strong>CatalystInstance</strong></p> <ul><li><code>CatalystInstance</code>是<code>ReactNative</code>应用Java层、C++层、JS层通信总管理类，总管Java层、JS层核心<code>Module</code>映射表与回调，三端通信的入口与桥梁。</li></ul> <p><strong>JavaScriptModule</strong></p> <ul><li><code>JavaScriptModule</code>是<code>JS Module</code>，负责JS到Java的映射调用格式声明，由<code>CatalystInstance</code>统一管理。</li></ul> <p><strong>NativeModule</strong></p> <ul><li><code>NativeModule</code>是<code>java Module</code>，负责Java到Js的映射调用格式声明，由<code>CatalystInstance</code>统一管理。</li></ul> <p><strong>JavascriptModuleRegistry</strong></p> <ul><li>JS Module映射表,负责将所有JavaScriptModule注册到CatalystInstance，通过Java动态代理调用到Js。</li></ul> <p><strong>NativeModuleRegistry</strong></p> <ul><li>是Java Module映射表,即暴露给Js的API集合。</li></ul> <p><strong>CoreModulePackage</strong></p> <ul><li>定义核心框架模块，创建<code>NativeModules&amp;JsModules</code></li></ul> <h3 id="_8-3-启动过程的解析"><a href="#_8-3-启动过程的解析" class="header-anchor">#</a> 8.3 启动过程的解析</h3> <ol><li>ReactInstanceManager创建时会配置应用所需的java模块与js模块，通过ReactRootView的startReactApplication启动APP。</li> <li>在创建ReactInstanceManager同时会创建用于加载JsBundle的JSBundlerLoader，并传递给CatalystInstance。</li> <li>CatalystInstance会创建Java模块注册表及Javascript模块注册表，并遍历实例化模块。</li> <li>CatalystInstance通过JSBundlerLoader向Node Server请求Js Bundle，并传递给JSCJavaScriptExectutor，最后传递给javascriptCore，再通过ReactBridge通知ReactRootView完成渲染</li></ol> <h3 id="_8-4-js与java通信机制"><a href="#_8-4-js与java通信机制" class="header-anchor">#</a> 8.4 Js与Java通信机制</h3> <blockquote><p>Java与Js之间的调用，是以两边存在两边存在同一份模块配置表，最终均是将调用转化为{moduleID,methodID，callbackID，args}，处理端在模块配置表里查找注册的模块与方法并调用。</p></blockquote> <p><strong>Java 调用Js</strong></p> <blockquote><p>Java通过注册表调用到CatalystInstance实例，透过ReactBridge的jni，调用到Onload.cpp中的callFunction，最后通过javascriptCore，调用BatchedBridge.js，根据参数｛moduleID,methodID｝require相应Js模块执行。流程如下图：</p></blockquote> <p><img src="https://s.poetries.top/gitee/2019/10/684.png" alt=""></p> <p><strong>Js 调用Java</strong></p> <blockquote><p>如果消息队列中有等待Java 处理的逻辑，而且 Java 超过 5ms 都没有来取走，那么 JavaScript 就会主动调用 Java 的方法,在需要调用调Java模块方法时，会把参数｛moduleID,methodID｝等数据存在MessageQueue中，等待Java的事件触发，把MessageQueue中的｛moduleID,methodID｝返回给Java，再根据模块注册表找到相应模块处理。流程如下图：</p></blockquote> <p><img src="https://s.poetries.top/gitee/2019/10/685.webp" alt=""></p> <h2 id="九、更多参考"><a href="#九、更多参考" class="header-anchor">#</a> 九、更多参考</h2> <ul><li><a href="https://juejin.im/post/5a6460f8f265da3e4f0a446d" target="_blank" rel="noopener noreferrer">React Native for Android 原理分析与实践：实现原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.jianshu.com/p/e220e1f34a0b" target="_blank" rel="noopener noreferrer">深入剖析 JavaScriptCore<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <!----> <div class="readMore-wrapper"><span class="readMore">阅读全文</span></div>
                    </div>
                            <p>这是一个信息提示框。</p>
                        </div>

                        <div class="note warning">
                            <div class="note-title"><i class="fas fa-exclamation-triangle"></i> 注意</div>
                            <p>这是一个警告提示框。</p>
                        </div>

                        <div class="note success">
                            <div class="note-title"><i class="fas fa-check-circle"></i> 成功</div>
                            <p>这是一个成功提示框。</p>
                        </div>

                        <h2>代码示例</h2>
                        <pre><code class="language-javascript">// 示例代码
function example() {
    console.log('Hello, FrontendHub!');
}
</code></pre>
                    </div>

                    <!-- 文章底部导航 -->
                    <nav class="article-nav">
                        <a href="#" class="prev-article">
                            <i class="fas fa-chevron-left"></i>
                            <span>上一篇</span>
                        </a>
                        <a href="#" class="next-article">
                            <span>下一篇</span>
                            <i class="fas fa-chevron-right"></i>
                        </a>
                    </nav>
                </article>
            </div>
        </div>
    </main>

    <!-- 页脚 -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4><i class="fas fa-code"></i> FrontendHub</h4>
                    <p>专注于前端技术学习与面试准备</p>
                </div>
                <div class="footer-section">
                    <h4>快速链接</h4>
                    <ul>
                        <li><a href="../../index.html">首页</a></li>
                        <li><a href="../index.html#courses">课程体系</a></li>
                        <li><a href="../index.html#resources">学习资源</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 FrontendHub. 用于个人学习使用.</p>
            </div>
        </div>
    </footer>

    <!-- 返回顶部按钮 -->
    <button class="back-to-top" id="backToTop">
        <i class="fas fa-arrow-up"></i>
    </button>

    <script src="../../js/main.js"></script>
    <script src="../../js/content.js"></script>
</body>
</html>

