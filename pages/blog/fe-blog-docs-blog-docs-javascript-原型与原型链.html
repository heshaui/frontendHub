<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="referrer" content="no-referrer">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>原型与原型链 - FrontendHub</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/content.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body class="content-page">
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="../../index.html" style="color: inherit; text-decoration: none; display: flex; align-items: center; gap: 0.5rem;">
                    <i class="fas fa-code"></i>
                    <span>FrontendHub</span>
                </a>
            </div>
            <button class="nav-toggle" id="navToggle">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-menu" id="navMenu">
                <li><a href="../../index.html">首页</a></li>
                <li><a href="../index.html#features">特色</a></li>
                <li><a href="../index.html#courses">课程</a></li>
                <li><a href="../index.html#resources">资源</a></li>
            </ul>
        </div>
    </nav>

    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <div class="container">
            <a href="../../index.html"><i class="fas fa-home"></i> 首页</a>
            <i class="fas fa-chevron-right"></i>
            <span>原型与原型链</span>
        </div>
    </div>

    <!-- 主要内容区 -->
    <main class="content-main">
        <div class="container">
            <div class="content-layout">
                <!-- 侧边栏目录 -->
                <aside class="sidebar">
                    <div class="sidebar-sticky">
                        <h3><i class="fas fa-list"></i> 目录</h3>
                        <nav class="toc" id="toc">
                            <!-- 目录将通过JavaScript自动生成 -->
                        </nav>
                    </div>
                </aside>

                <!-- 文章内容 -->
                <article class="article">
                    <header class="article-header">
                        <h1>原型与原型链</h1>
                        <div class="article-meta">
                            <span><i class="far fa-calendar"></i> 更新时间：2025-12-23</span>
                            <span><i class="far fa-clock"></i> 阅读时长：约 15 分钟</span>
                        </div>
                    </header>

                    <div class="article-content">
<div class="content__default"><h2 id="写在前面"><a href="#写在前面" class="header-anchor">#</a> 写在前面</h2> <p><strong>首先我们需要明确两点：</strong></p> <p>1️⃣<code>__proto__</code>和<code>constructor</code>是<strong>对象</strong>独有的</p> <p>2️⃣<code>prototype</code>属性是<strong>函数</strong>独有的</p> <h2 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h2> <h3 id="prototype"><a href="#prototype" class="header-anchor">#</a> prototype</h3> <ul><li>在最新ES规范里，prototype 被定义为：给其它对象提供共享属性的对象。</li> <li>也就是说，prototype 自己也是对象，只是被用以承担某个职能罢了。</li></ul> <p>因此，prototype 描述的是两个对象之间的某种关系（其中一个，为另一个提供属性访问权限）。</p> <h3 id="constructor与prototype联系"><a href="#constructor与prototype联系" class="header-anchor">#</a> constructor与prototype联系</h3> <ul><li><p>每个函数都有一个prototype属性,它默认指向一个Object空对象(即称为:原型对象)</p></li> <li><p>原型对象中有一个属性constructor,它指向函数对象</p></li> <li><p>给原型对象添加属性(一般是方法)</p> <ul><li>作用:函数的所有实例对象自动拥有原型中的属性(方法)</li></ul></li></ul> <p>下面通过一个例子来说明:</p> <div class="language- extra-class"><pre class="language-text"><code>		function Demo() {}
        console.log(Demo.prototype.constructor === Demo)  // true
        console.dir(Demo.prototype)
</code></pre></div><p>![](C:\Users\DayDay\Pictures\Camera Roll\demo.png)</p> <p>可以看到就是Demo函数对象的prototype原型是右边这个对象,那么Demo.prototype原型上有个constructor属性,这个属性正好指向Demo函数本身。</p> <p>所有你可以理解成:</p> <div class="language- extra-class"><pre class="language-text"><code>A的显示原型是B,则有:
A.prototype === B 
B.constructor === A
</code></pre></div><p><strong>我觉得这样子唯一的好处在于你可以找到我,我也可以找到你。好滑稽</strong></p> <h3 id="proto-和prototype关系"><a href="#proto-和prototype关系" class="header-anchor">#</a> <code>__proto__</code>和prototype关系</h3> <p><strong>再次强调 ：</strong></p> <p>1️⃣<code>__proto__</code>和<code>constructor</code>是<strong>对象</strong>独有的。2️⃣<code>prototype</code>属性是<strong>函数</strong>独有的</p> <p>关于更多<code>__proto__</code>更深入的介绍，可以参看工业聚大佬的《深入理解 JavaScript 原型》一文。</p> <h4 id="显示原型和隐式原型"><a href="#显示原型和隐式原型" class="header-anchor">#</a> 显示原型和隐式原型</h4> <ul><li>每个函数fun都独有一个prototype, 及<strong>显式原型(属性)</strong></li> <li>每个实例对象都有一个<code>__proto__</code>, 及隐式原型(属性)**</li> <li>对象的隐式原型的值 === 其构造函数的显示原型的值</li></ul> <p>怎么理解呢？我们通过内存结构图来看看吧</p> <div class="language-js extra-class"><pre class="language-js"><code>		<span class="token keyword">function</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token class-name">Demo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>       <span class="token comment">//给原型添加say方法</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Demo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say<span class="token punctuation">)</span>
        <span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        fn<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 怎么找到say方法的呢?</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Demo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>  <span class="token comment">// true</span>
</code></pre></div><p><img src="C:%5CUsers%5CDayDay%5CDesktop%5C%E5%89%8D%E7%AB%AF-%E7%AC%94%E8%AE%B0%5Cimages%5C%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B.png" alt=""></p> <p>我们从图中可以看到,Demo函数的原型跟它构造函数(Demo)创建的实例fn.<code>__proto__</code>指向同一个对象。</p> <p><strong>那么fn是怎么找到say方法的呢？</strong></p> <p>更加具体的说就是通过隐式原型<code>__proro__</code>找到的,分析如下:</p> <ul><li>js引擎执行到fn.say()整行代码时,解析器去栈中查找fn变量</li> <li>发现fn变量是引用类型,就去堆内存中查找地址为0x234的实体，查到后,发现并没有say属性,接着就去找<code>__proro__</code>属性对应的原型</li> <li>接着找到内存地址为0x345对应的实体,发现该实体中有say属性,同样的操作去找地址为0x789的实体，最后执行该函数。</li></ul> <p>那么是不是可以更加准确的说明:实例是通过<code>隐式原型__proto__</code>查找需要调用的属性的，那么我们通过接下来的代码去验证一下。</p> <p>代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token class-name">Demo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>       <span class="token comment">//给原型添加say方法</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Demo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'old name'</span>
        <span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        fn<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 怎么找到say方法的呢?</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"为修改前"</span><span class="token punctuation">,</span>fn<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Demo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>  <span class="token comment">// true</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"-------接下来修改fn的__proto__"</span><span class="token punctuation">)</span>
        fn<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token function-variable function">say</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello 隐式原型"</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token literal-property property">name</span> <span class="token operator">:</span> <span class="token string">'new name'</span>
        <span class="token punctuation">}</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"修改实例中的隐式原型"</span><span class="token punctuation">,</span>fn<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Demo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>  <span class="token comment">// true</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
        fn<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"重新创建一个Demo构造函数实例"</span><span class="token punctuation">)</span>
        <span class="token keyword">let</span> demo1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Demo</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> demo1<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span>
        demo1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><img src="C:\Users\DayDay\Desktop\前端-笔记\images\证明隐式原型.PNG" style="zoom:60%;"> <p>首先的说明的是：</p> <p><strong>通过查阅相关的文档,ES6之前不能直接操作隐式原型,也不推荐你这么做。</strong></p> <p>通过修改fn的隐式原型,让它指向一个新的对象。那么fn.<strong>proto</strong> 不等于Demo.prototype.  这个例子也能证明一点,<strong>实例对象调用属性时</strong>,实例对象不具有该属性时,是通过隐式原型去找的该属性的,找不到的话,在它的<strong>隐式原型对象</strong>的<strong>隐式原型对象上</strong>找。</p> <p>这也就是我们常说的,在原型上添加属性或者方法,实例可以共享,原因就在于我们并不推荐去修改实例的<code>__proto__</code>属性,这样子也就是会有一下结果:</p> <div class="language- extra-class"><pre class="language-text"><code>function Demo() {
		// 内部语句 this.prototype = {}
}
let fn = new Demo(); // 内部语句: fn.`__proto__` = Demo.prototype

// 实例化一个对象隐式原型会默认赋值: fn.__proto__ = Demo.prototype
// 定义函数时: 显式原型也会默认添加: Demo.prototype = new Object()
</code></pre></div><p>这里我们需要知道的是，<code>__proto__</code>是对象所独有的，并且<code>__proto__</code>是<strong>一个对象指向另一个对象</strong>，也就是他的原型对象。我们也可以理解为父类对象。它的作用就是当你在访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就回去它的<code>__proto__</code>属性所指向的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那么就回去其父类的<code>__proto__</code>属性所指向的父类的父类上去查找。以此类推，知道找到 <code>null</code>。而这个查找的过程，也就构成了我们常说的<strong>原型链</strong>。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <ul><li><p>那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性。</p></li> <li><p>函数的prototype属性：在定义函数时自动添加prototype,默认是一个空Object对象</p></li> <li><p>对象的<code>__proto__</code>属性：创建一个对象实例时,默认值是构造函数的prototype属性值,也就是上面所说的</p></li> <li><p>实例的构造函数属性（constructor）指向构造函数</p></li> <li><p>一般而言,可以直接操作显式原型,不能直接操作隐式原型(ES6)</p></li> <li><p>更多规范,移步<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="noopener noreferrer">MDN<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul> <h3 id="补充"><a href="#补充" class="header-anchor">#</a> 补充</h3> <h4 id="object和function的鸡和蛋的问题"><a href="#object和function的鸡和蛋的问题" class="header-anchor">#</a> <code>Object</code>和<code>Function</code>的鸡和蛋的问题</h4> <p>**最后总结： ** <strong>先有Object.prototype（原型链顶端），Function.prototype继承Object.prototype而产生，最后，Function和Object和其它构造函数继承Function.prototype而产生。</strong></p> <h4 id="mdn的推荐"><a href="#mdn的推荐" class="header-anchor">#</a> MDN的推荐</h4> <p>使用<code>__proto__</code>是有争议的，也不鼓励使用它。因为它从来没有被包括在ECMAScript语言规范中，但是现代浏览器都实现了它。<code>__proto__</code>属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。它已被不推荐使用, 现在更推荐使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noopener noreferrer"><code>Object.getPrototypeOf</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getPrototypeOf" target="_blank" rel="noopener noreferrer"><code>Reflect.getPrototypeOf</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener noreferrer"><code>Object.setPrototypeOf</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>/<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/setPrototypeOf" target="_blank" rel="noopener noreferrer"><code>Reflect.setPrototypeOf</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（尽管如此，设置对象的[[Prototype]]是一个缓慢的操作，如果性能是一个问题，应该避免）。</p> <p><strong>proto</strong> 属性也可以在对象文字定义中使用对象[[Prototype]]来创建，作为<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener noreferrer"><code>Object.create()</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的一个替代。</p> <h2 id="prototype-chain-原型链"><a href="#prototype-chain-原型链" class="header-anchor">#</a> <strong>prototype chain 原型链</strong></h2> <blockquote><p>a prototype may have a non-null implicit reference to its prototype, and so on; this is called the <em>prototype chain</em>.</p></blockquote> <p>如上，在 ECMAScript 2019 规范里，只通过短短的一句话，就介绍完了 prototype chain</p> <p>原型链的概念，仅仅是在原型这个概念基础上所作的直接推论。</p> <p>既然 prototype 只是恰好作为另一个对象的隐式引用的普通对象。那么，它也是对象，也符合一个对象的基本特征。</p> <div class="language- extra-class"><pre class="language-text"><code>每个对象都可以有一个原型_proto_，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找...... 这个操作被委托在整个原型链上，这个就是我们说的原型链了。
</code></pre></div><h3 id="结论"><a href="#结论" class="header-anchor">#</a> 结论:</h3> <ul><li><p><code>__proto__</code> 是原型链查询中实际用到的，它总是指向 prototype</p></li> <li><p>prototype 是函数所独有的**，**在定义构造函数时自动创建，它总是被 <strong>proto</strong> 所指。</p></li> <li><p>所有对象都有__proto__属性，函数这个特殊对象除了具有__proto__属性，还有特有的原型属性prototype。prototype对象默认有两个属性，constructor属性和__proto__属性。prototype属性可以给函数和对象添加可共享（继承）的方法、属性，而__proto__是查找某函数或对象的原型链方式。constructor，这个属性包含了一个指针，指回原构造函数。</p></li></ul></div> <!----> <div class="readMore-wrapper"><span class="readMore">阅读全文</span></div>
                    </div>
                            <p>这是一个信息提示框。</p>
                        </div>

                        <div class="note warning">
                            <div class="note-title"><i class="fas fa-exclamation-triangle"></i> 注意</div>
                            <p>这是一个警告提示框。</p>
                        </div>

                        <div class="note success">
                            <div class="note-title"><i class="fas fa-check-circle"></i> 成功</div>
                            <p>这是一个成功提示框。</p>
                        </div>

                        <h2>代码示例</h2>
                        <pre><code class="language-javascript">// 示例代码
function example() {
    console.log('Hello, FrontendHub!');
}
</code></pre>
                    </div>

                    <!-- 文章底部导航 -->
                    <nav class="article-nav">
                        <a href="#" class="prev-article">
                            <i class="fas fa-chevron-left"></i>
                            <span>上一篇</span>
                        </a>
                        <a href="#" class="next-article">
                            <span>下一篇</span>
                            <i class="fas fa-chevron-right"></i>
                        </a>
                    </nav>
                </article>
            </div>
        </div>
    </main>

    <!-- 页脚 -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4><i class="fas fa-code"></i> FrontendHub</h4>
                    <p>专注于前端技术学习与面试准备</p>
                </div>
                <div class="footer-section">
                    <h4>快速链接</h4>
                    <ul>
                        <li><a href="../../index.html">首页</a></li>
                        <li><a href="../index.html#courses">课程体系</a></li>
                        <li><a href="../index.html#resources">学习资源</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 FrontendHub. 用于个人学习使用.</p>
            </div>
        </div>
    </footer>

    <!-- 返回顶部按钮 -->
    <button class="back-to-top" id="backToTop">
        <i class="fas fa-arrow-up"></i>
    </button>

    <script src="../../js/main.js"></script>
    <script src="../../js/content.js"></script>
</body>
</html>

