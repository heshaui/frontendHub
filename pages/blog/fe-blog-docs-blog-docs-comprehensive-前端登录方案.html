<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="referrer" content="no-referrer">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>前端登录方案 - FrontendHub</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/content.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body class="content-page">
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="../../index.html" style="color: inherit; text-decoration: none; display: flex; align-items: center; gap: 0.5rem;">
                    <i class="fas fa-code"></i>
                    <span>FrontendHub</span>
                </a>
            </div>
            <button class="nav-toggle" id="navToggle">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-menu" id="navMenu">
                <li><a href="../../index.html">首页</a></li>
                <li><a href="../index.html#features">特色</a></li>
                <li><a href="../index.html#courses">课程</a></li>
                <li><a href="../index.html#resources">资源</a></li>
            </ul>
        </div>
    </nav>

    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <div class="container">
            <a href="../../index.html"><i class="fas fa-home"></i> 首页</a>
            <i class="fas fa-chevron-right"></i>
            <span>前端登录方案</span>
        </div>
    </div>

    <!-- 主要内容区 -->
    <main class="content-main">
        <div class="container">
            <div class="content-layout">
                <!-- 侧边栏目录 -->
                <aside class="sidebar">
                    <div class="sidebar-sticky">
                        <h3><i class="fas fa-list"></i> 目录</h3>
                        <nav class="toc" id="toc">
                            <!-- 目录将通过JavaScript自动生成 -->
                        </nav>
                    </div>
                </aside>

                <!-- 文章内容 -->
                <article class="article">
                    <header class="article-header">
                        <h1>前端登录方案</h1>
                        <div class="article-meta">
                            <span><i class="far fa-calendar"></i> 更新时间：2025-12-23</span>
                            <span><i class="far fa-clock"></i> 阅读时长：约 15 分钟</span>
                        </div>
                    </header>

                    <div class="article-content">
<div class="content__default"><h2 id="cookie-session-登录"><a href="#cookie-session-登录" class="header-anchor">#</a> Cookie + Session 登录</h2> <blockquote><p>HTTP 是一种无状态的协议，客户端每次发送请求时，首先要和服务器端建立一个连接，在请求完成后又会断开这个连接。这种方式可以节省传输时占用的连接资源，但同时也存在一个问题：每次请求都是独立的，服务器端无法判断本次请求和上一次请求是否来自同一个用户，进而也就无法判断用户的登录状态。</p></blockquote> <p>为了解决 HTTP 无状态的问题，Lou Montulli 在 1994 年的时候，推出了 Cookie。</p> <blockquote><p>Cookie 是服务器端发送给客户端的一段特殊信息，这些信息以文本的方式存放在客户端，客户端每次向服务器端发送请求时都会带上这些特殊信息。</p></blockquote> <p>有了 <code>Cookie</code> 之后，服务器端就能够获取到客户端传递过来的信息了，如果需要对信息进行验证，还需要通过 <code>Session</code></p> <blockquote><p>客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个便是 <code>Session</code> 对象。</p></blockquote> <p>有了 <code>Cookie</code> 和 <code>Session</code>之后，我们就可以进行登录认证了</p> <h3 id="cookie-session-实现流程"><a href="#cookie-session-实现流程" class="header-anchor">#</a> Cookie + Session  实现流程</h3> <p>Cookie + Session 的登录方式是最经典的一种登录方式，现在仍然有大量的企业在使用。</p> <p>用户首次登录时：</p> <p><img src="https://s.poetries.top/gitee/2020/08/48.png" alt=""></p> <ul><li>用户访问 <code>a.com/pageA</code>，并输入密码登录。</li> <li>服务器验证密码无误后，会创建 <code>SessionId</code>，并将它保存起来。</li> <li>服务器端响应这个 HTTP 请求，并通过 <code>Set-Cookie</code> 头信息，将 <code>SessionId</code> 写入 <code>Cookie</code> 中</li></ul> <blockquote><p>服务器端的 <code>SessionId</code> 可能存放在很多地方，例如：内存、文件、数据库等。</p></blockquote> <p>第一次登录完成之后，后续的访问就可以直接使用 Cookie 进行身份验证了：</p> <p><img src="https://s.poetries.top/gitee/2020/08/49.png" alt=""></p> <ul><li>用户访问 <code>a.com/pageB</code> 页面时，会自动带上第一次登录时写入的 <code>Cookie</code>。</li> <li>服务器端比对 <code>Cookie</code> 中的 <code>SessionId</code> 和保存在服务器端的 <code>SessionId</code> 是否一致。</li> <li>如果一致，则身份验证成功</li></ul> <p><strong>Cookie + Session  存在的问题</strong></p> <blockquote><p>虽然我们使用 <code>Cookie + Session</code>的方式完成了登录验证，但仍然存在一些问题：</p></blockquote> <ul><li>由于服务器端需要对接大量的客户端，也就需要存放大量的 <code>SessionId</code>，这样会导致服务器压力过大。</li> <li>如果服务器端是一个集群，为了同步登录态，需要将 <code>SessionId</code> 同步到每一台机器上，无形中增加了服务器端维护成本。</li> <li>由于 <code>SessionId</code> 存放在 <code>Cookie</code> 中，所以无法避免 <code>CSRF</code> 攻击</li></ul> <h2 id="token-登录"><a href="#token-登录" class="header-anchor">#</a> Token 登录</h2> <p>为了解决 Session + Cookie 机制暴露出的诸多问题，我们可以使用 Token 的登录方式。</p> <blockquote><p>Token 是服务端生成的一串字符串，以作为客户端请求的一个令牌。当第一次登录后，服务器会生成一个 Token 并返回给客户端，客户端后续访问时，只需带上这个 Token 即可完成身份认证。</p></blockquote> <h3 id="token-机制实现流程"><a href="#token-机制实现流程" class="header-anchor">#</a> Token 机制实现流程</h3> <p>用户首次登录时：</p> <p><img src="https://s.poetries.top/gitee/2020/08/50.png" alt=""></p> <ul><li>用户输入账号密码，并点击登录。</li> <li>服务器端验证账号密码无误，创建 Token。</li> <li>服务器端将 Token 返回给客户端，由***客户端自由保存***</li></ul> <p>后续页面访问时：</p> <p><img src="https://s.poetries.top/gitee/2020/08/51.png" alt=""></p> <ul><li>用户访问 <code>a.com/pageB</code> 时，带上第一次登录时获取的 <code>Token</code>。</li> <li>服务器端验证 <code>Token</code> ，有效则身份验证成功</li></ul> <h3 id="token-机制的特点"><a href="#token-机制的特点" class="header-anchor">#</a> Token 机制的特点</h3> <ul><li>服务器端不需要存放 Token，所以不会对服务器端造成压力，即使是服务器集群，也不需要增加维护成本。</li> <li>Token 可以存放在前端任何地方，可以不用保存在 Cookie 中，提升了页面的安全性。</li> <li>Token 下发之后，只要在生效时间之内，就一直有效，如果服务器端想收回此 Token 的权限，并不容易。</li></ul> <h3 id="token-的生成方式"><a href="#token-的生成方式" class="header-anchor">#</a> Token 的生成方式</h3> <blockquote><p>最常见的 Token 生成方式是使用 JWT（Json Web Token），它是一种简洁的，自包含的方法用于通信双方之间以 JSON 对象的形式安全的传递信息。</p></blockquote> <p>上文中我们说到，使用 Token 后，服务器端并不会存储 Token，那怎么判断客户端发过来的 Token 是合法有效的呢？</p> <p>答案其实就在 Token 字符串中，其实 Token 并不是一串杂乱无章的字符串，而是通过多种算法拼接组合而成的字符串，我们来具体分析一下。</p> <p>JWT 算法主要分为 3 个部分：header（头信息），playload（消息体），signature（签名）。</p> <p>header 部分指定了该 JWT 使用的签名算法:</p> <div class="language- extra-class"><pre class="language-text"><code>header = '{"alg":"HS256","typ":"JWT"}'   //
`HS256` 表示使用了 HMAC-SHA256 来生成签名。
</code></pre></div><p>playload 部分表明了 JWT 的意图：</p> <div class="language- extra-class"><pre class="language-text"><code>payload = '{"loggedInAs":"admin","iat":1422779638}'     //iat 表示令牌生成的时间
</code></pre></div><blockquote><p><code>signature</code> 部分为 <code>JWT</code> 的签名，主要为了让 <code>JWT</code>不能被随意篡改，签名的方法分为两个步骤：</p></blockquote> <ul><li>输入 <code>base64url</code> 编码的 <code>header</code> 部分、 . <code>、base64url</code> 编码的 <code>playload</code> 部分，输出 <code>unsignedToken</code></li> <li>输入 <code>base64url</code> 编码的 header 部分、 . 、base64url 编码的 playload 部分，输出 <code>unsignedToken</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const base64Header = encodeBase64(header)
const base64Payload = encodeBase64(payload)
const unsignedToken = `${base64Header}.${base64Payload}`
const key = '服务器私钥'

signature = HMAC(key, unsignedToken)
</code></pre></div><p>最后的 Token 计算如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> base64Header <span class="token operator">=</span> <span class="token function">encodeBase64</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span>
<span class="token keyword">const</span> base64Payload <span class="token operator">=</span> <span class="token function">encodeBase64</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
<span class="token keyword">const</span> base64Signature <span class="token operator">=</span> <span class="token function">encodeBase64</span><span class="token punctuation">(</span>signature<span class="token punctuation">)</span>

token <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>base64Header<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>base64Payload<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>base64Signature<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
</code></pre></div><p>服务器在判断 <code>Token</code> 时：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>base64Header<span class="token punctuation">,</span> base64Payload<span class="token punctuation">,</span> base64Signature<span class="token punctuation">]</span> <span class="token operator">=</span> token<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> signature1 <span class="token operator">=</span> <span class="token function">decodeBase64</span><span class="token punctuation">(</span>base64Signature<span class="token punctuation">)</span>
<span class="token keyword">const</span> unsignedToken <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>base64Header<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>base64Payload<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
<span class="token keyword">const</span> signature2 <span class="token operator">=</span> <span class="token constant">HMAC</span><span class="token punctuation">(</span><span class="token string">'服务器私钥'</span><span class="token punctuation">,</span> unsignedToken<span class="token punctuation">)</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>signature1 <span class="token operator">===</span> signature2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">'签名验证成功，token 没有被篡改'</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> payload <span class="token operator">=</span>  <span class="token function">decodeBase64</span><span class="token punctuation">(</span>base64Payload<span class="token punctuation">)</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> payload<span class="token punctuation">.</span>iat <span class="token operator">&lt;</span> <span class="token string">'token 有效期'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">'token 有效'</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>有了 <code>Token</code> 之后，登录方式已经变得非常高效，接下来我们介绍另外两种登录方式。</p></blockquote> <h2 id="sso-单点登录"><a href="#sso-单点登录" class="header-anchor">#</a> SSO 单点登录</h2> <p>单点登录指的是在公司内部搭建一个公共的认证中心，公司下的所有产品的登录都可以在认证中心里完成，一个产品在认证中心登录后，再去访问另一个产品，可以不用再次登录，即可获取登录状态。</p> <h3 id="sso-机制实现流程"><a href="#sso-机制实现流程" class="header-anchor">#</a> SSO 机制实现流程</h3> <p>用户首次访问时，需要在认证中心登录：</p> <p><img src="https://s.poetries.top/gitee/2020/08/52.png" alt=""></p> <ul><li>用户访问网站  <code>a.com</code> 下的 <code>pageA</code>页面。</li> <li>由于没有登录，则会重定向到认证中心，并带上回调地址 <code>www.sso.com?return_uri=a.com/pageA</code>，以便登录后直接进入对应页面。</li> <li>用户在认证中心输入账号密码，提交登录。</li> <li>认证中心验证账号密码有效，然后重定向  <code>a.com?ticket=123</code> 带上授权码 <code>ticket</code>，并将认证中心 <code>sso.com</code> 的登录态写入 <code>Cookie</code>。</li> <li>在 a.com 服务器中，拿着 ticket 向认证中心确认，授权码 ticket 真实有效。</li> <li>验证成功后，服务器将登录信息写入 Cookie（此时客户端有 2 个 Cookie 分别存有 a.com 和 sso.com 的登录态）</li></ul> <blockquote><p>认证中心登录完成之后，继续访问 a.com 下的其他页面：</p></blockquote> <p><img src="https://s.poetries.top/gitee/2020/08/53.png" alt=""></p> <ul><li>这个时候，由于 a.com 存在已登录的 Cookie 信息，所以服务器端直接认证成功。</li> <li>如果认证中心登录完成之后，访问 b.com 下的页面：</li></ul> <p><img src="https://s.poetries.top/gitee/2020/08/54.png" alt=""></p> <p>这个时候，由于认证中心存在之前登录过的 <code>Cookie</code>，所以也不用再次输入账号密码，直接返回第 4 步，下发 <code>ticket</code> 给 <code>b.com</code> 即可</p> <h3 id="sso-单点登录退出"><a href="#sso-单点登录退出" class="header-anchor">#</a> SSO 单点登录退出</h3> <blockquote><p>目前我们已经完成了单点登录，在同一套认证中心的管理下，多个产品可以共享登录态。现在我们需要考虑退出了，即：在一个产品中退出了登录，怎么让其他的产品也都退出登录？</p></blockquote> <p>原理其实不难，可以回过头来看第 5 步，每一个产品在向认证中心验证 ticket 时，其实可以顺带将自己的退出登录 api 发送到认证中心。</p> <p><strong>当某个产品 c.com 退出登录时：</strong></p> <ul><li>清空 c.com 中的登录态 Cookie。</li> <li>请求认证中心 sso.com 中的退出 api。</li> <li>认证中心遍历下发过 ticket 的所有产品，并调用对应的退出 api，完成退出</li></ul> <h2 id="oauth-第三方登录"><a href="#oauth-第三方登录" class="header-anchor">#</a> OAuth 第三方登录</h2> <p>在上文中，我们使用单点登录完成了多产品的登录态共享，但都是建立在一套统一的认证中心下，对于一些小型企业，未免太麻烦，有没有一种登录能够做到开箱即用？</p> <p>其实是有的，很多大厂都会提供自己的第三方登录服务，我们一起来分析一下。</p> <p><img src="https://s.poetries.top/gitee/2020/08/55.png" alt=""></p> <h3 id="oauth-机制实现流程"><a href="#oauth-机制实现流程" class="header-anchor">#</a> OAuth 机制实现流程</h3> <p>这里以微信开放平台的接入流程为例：</p> <p><img src="https://s.poetries.top/gitee/2020/08/56.png" alt=""></p> <ul><li>首先，a.com 的运营者需要在微信开放平台注册账号，并向微信申请使用微信登录功能。</li> <li>申请成功后，得到申请的 appid、appsecret。</li> <li>用户在 a.com 上选择使用微信登录。</li> <li>这时会跳转微信的 OAuth 授权登录，并带上 a.com 的回调地址。</li> <li>用户输入微信账号和密码，登录成功后，需要选择具体的授权范围，如：授权用户的头像、昵称等。</li> <li>授权之后，微信会根据拉起 a.com?code=123 ，这时带上了一个临时票据 code。</li> <li>获取 code 之后， a.com 会拿着 code 、appid、appsecret，向微信服务器申请 token，验证成功后，微信会下发一个 token。</li> <li>有了 token 之后， a.com 就可以凭借 token 拿到对应的微信用户头像，用户昵称等信息了。</li> <li>a.com 提示用户登录成功，并将登录状态写入 Cooke，以作为后续访问的凭证。</li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>本文介绍了 4 种常见的登录方式，原理应该大家都清楚了，总结一下这 4 种方案的使用场景：</p> <ul><li><code>Cookie + Session</code> 历史悠久，适合于简单的后端架构，需开发人员自己处理好安全问题。</li> <li><code>Token</code> 方案对后端压力小，适合大型分布式的后端架构，但已分发出去的 token ，如果想收回权限，就不是很方便了。</li> <li><code>SSO</code> 单点登录，适用于中大型企业，想要统一内部所有产品的登录方式。</li> <li><code>OAuth</code> 第三方登录，简单易用，对用户和开发者都友好，但第三方平台很多，需要选择合适自己的第三方登录平台。</li></ul></div> <!----> <div class="readMore-wrapper"><span class="readMore">阅读全文</span></div>
                    </div>
                            <p>这是一个信息提示框。</p>
                        </div>

                        <div class="note warning">
                            <div class="note-title"><i class="fas fa-exclamation-triangle"></i> 注意</div>
                            <p>这是一个警告提示框。</p>
                        </div>

                        <div class="note success">
                            <div class="note-title"><i class="fas fa-check-circle"></i> 成功</div>
                            <p>这是一个成功提示框。</p>
                        </div>

                        <h2>代码示例</h2>
                        <pre><code class="language-javascript">// 示例代码
function example() {
    console.log('Hello, FrontendHub!');
}
</code></pre>
                    </div>

                    <!-- 文章底部导航 -->
                    <nav class="article-nav">
                        <a href="#" class="prev-article">
                            <i class="fas fa-chevron-left"></i>
                            <span>上一篇</span>
                        </a>
                        <a href="#" class="next-article">
                            <span>下一篇</span>
                            <i class="fas fa-chevron-right"></i>
                        </a>
                    </nav>
                </article>
            </div>
        </div>
    </main>

    <!-- 页脚 -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4><i class="fas fa-code"></i> FrontendHub</h4>
                    <p>专注于前端技术学习与面试准备</p>
                </div>
                <div class="footer-section">
                    <h4>快速链接</h4>
                    <ul>
                        <li><a href="../../index.html">首页</a></li>
                        <li><a href="../index.html#courses">课程体系</a></li>
                        <li><a href="../index.html#resources">学习资源</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 FrontendHub. 用于个人学习使用.</p>
            </div>
        </div>
    </footer>

    <!-- 返回顶部按钮 -->
    <button class="back-to-top" id="backToTop">
        <i class="fas fa-arrow-up"></i>
    </button>

    <script src="../../js/main.js"></script>
    <script src="../../js/content.js"></script>
</body>
</html>

