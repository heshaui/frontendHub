<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP报文篇 - FrontendHub</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/content.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body class="content-page">
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="../../index.html" style="color: inherit; text-decoration: none; display: flex; align-items: center; gap: 0.5rem;">
                    <i class="fas fa-code"></i>
                    <span>FrontendHub</span>
                </a>
            </div>
            <button class="nav-toggle" id="navToggle">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-menu" id="navMenu">
                <li><a href="../../index.html">首页</a></li>
                <li><a href="../index.html#features">特色</a></li>
                <li><a href="../index.html#courses">课程</a></li>
                <li><a href="../index.html#resources">资源</a></li>
            </ul>
        </div>
    </nav>

    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <div class="container">
            <a href="../../index.html"><i class="fas fa-home"></i> 首页</a>
            <i class="fas fa-chevron-right"></i>
            <span>HTTP报文篇</span>
        </div>
    </div>

    <!-- 主要内容区 -->
    <main class="content-main">
        <div class="container">
            <div class="content-layout">
                <!-- 侧边栏目录 -->
                <aside class="sidebar">
                    <div class="sidebar-sticky">
                        <h3><i class="fas fa-list"></i> 目录</h3>
                        <nav class="toc" id="toc">
                            <!-- 目录将通过JavaScript自动生成 -->
                        </nav>
                    </div>
                </aside>

                <!-- 文章内容 -->
                <article class="article">
                    <header class="article-header">
                        <h1>HTTP报文篇</h1>
                        <div class="article-meta">
                            <span><i class="far fa-calendar"></i> 更新时间：2025-12-23</span>
                            <span><i class="far fa-clock"></i> 阅读时长：约 15 分钟</span>
                        </div>
                    </header>

                    <div class="article-content">
<div class="content__default"><h2 id="_1-http报文概念"><a href="#_1-http报文概念" class="header-anchor">#</a> 1. HTTP报文概念</h2> <p>概念：是HTTP通信中的基本单位，由8位组字节流组成。</p> <h2 id="_2-http报文整体结构"><a href="#_2-http报文整体结构" class="header-anchor">#</a> 2. HTTP报文整体结构</h2> <p>整体结构：报文首部 + 空行 + 报文实体</p> <p>有些地方会写为(这样也可以)：起始行 + 首部字段 + 空行 + 报文实体</p> <p>（首部也就是头部）</p> <p>另外对于<strong>请求报文</strong>和<strong>响应报文</strong>，它们主要是报文首部不同：</p> <p><strong>请求报文：</strong></p> <p><img src="https://s.poetries.top/gitee/2020/09/145.png" alt=""></p> <p>真实例子：</p> <p><img src="https://s.poetries.top/gitee/2020/09/146.png" alt=""></p> <p><strong>响应报文：</strong></p> <p><img src="https://s.poetries.top/gitee/2020/09/147.png" alt=""></p> <p>真实例子：</p> <p><img src="https://s.poetries.top/gitee/2020/09/148.png" alt=""></p> <h2 id="_3-http报文组成"><a href="#_3-http报文组成" class="header-anchor">#</a> 3. HTTP报文组成</h2> <p>上面👆介绍了一下HTTP报文的整体结构，这里主要是做一下细分。</p> <p>HTTP报文的整体是：报文首部 + 空行 + 报文实体</p> <p>不过因为：报文首部 = 起始行 + 首部字段，其实起始行也挺重要的，所以我就分为两部分说了。</p> <p>大家记住这张图就可以了：</p> <p><img src="https://s.poetries.top/gitee/2020/09/149.png" alt=""></p> <h3 id="_3-1-起始行"><a href="#_3-1-起始行" class="header-anchor">#</a> 3.1 起始行</h3> <p>请求报文中叫：<strong>请求行</strong></p> <p>由：<code>方法 + URI + 版本号</code> 组成</p> <p>例：<code>GET index.html HTTP/1.1</code></p> <p>真实例子可以看上面👆HTTP整体报文那张图。</p> <p>响应报文中叫：<strong>状态行</strong></p> <p>由：<code>版本号 + 状态码 + 原因短语</code></p> <p>例：<code>HTTP/1.1 200 OK</code></p> <p>(这个原因短语就是之前学习<strong>HTTP状态码</strong>每个状态码对应的英文单词，比如<code>404 Not Found</code>)</p> <h3 id="_3-2-首部字段"><a href="#_3-2-首部字段" class="header-anchor">#</a> 3.2 首部字段</h3> <p>在第四节中细讲。</p> <h3 id="_3-3-空行"><a href="#_3-3-空行" class="header-anchor">#</a> 3.3 空行</h3> <p>空行：也就是CR(回车符) 或 LF(换行符)，它的作用就是用来<strong>区分头部和实体</strong>。</p> <p>例如下面这个实例：</p> <p><img src="https://s.poetries.top/gitee/2020/09/150.png" alt=""></p> <p>在<code>Connection: keep-alive</code>下面就有一个换行符。</p> <p><strong>注意点：</strong></p> <p>如果在头部中故意加一个空行，空行后面的内容会被全部当成实体</p> <h3 id="_3-4-报文实体"><a href="#_3-4-报文实体" class="header-anchor">#</a> 3.4 报文实体</h3> <p>报文实体也就是具体请求和响应的数据了，就是我们俗说的<code>body</code>。</p> <p>请求报文中叫：<strong>请求体</strong></p> <p>响应报文中叫：<strong>响应体</strong></p> <h2 id="_4-http首部字段"><a href="#_4-http首部字段" class="header-anchor">#</a> 4. HTTP首部字段</h2> <p>（HTTP报文中最繁琐的就是首部字段了，也就是我们经常在<code>network</code>上看到的那么一大串的配置）</p> <p><img src="https://s.poetries.top/gitee/2020/09/151.png" alt=""></p> <p>HTTP首部字段我会从这几个方面来讲解：</p> <ul><li>HTTP首部字段结构</li> <li>四种HTTP首部字段类型</li> <li>非标准的首部字段</li> <li>Accept相关字段</li></ul> <h3 id="_4-1-http首部字段结构"><a href="#_4-1-http首部字段结构" class="header-anchor">#</a> 4.1 HTTP首部字段结构</h3> <ol><li>首先基本结构是：</li></ol> <p>由：<code>key: value</code></p> <p>例子：<code>Content-Type: text/html</code></p> <ol start="2"><li>多个字段值用<code>,</code>号连接：</li></ol> <p>由：<code>key: value1, value2</code></p> <p>例：<code>Keep-Alive: timeout=15, max=100</code></p> <ol start="3"><li>若是字段值有可选参数且是多个则用<code>;</code>号连接：</li></ol> <p>由：<code>key: value1, q=1;value2, q=0.8</code></p> <p>例：<code>Accept: text/html, q=1; application/xml, q=0.8</code></p> <ol start="4"><li>若是首部字段重复不同的浏览器有不同的处理结果，有些浏览器会优先处理第一次出现的首部字段，而有些则先处理最后出现的首部字段</li></ol> <h3 id="_4-2-四种http首部字段类型"><a href="#_4-2-四种http首部字段类型" class="header-anchor">#</a> 4.2 四种HTTP首部字段类型</h3> <p>首部字段从类型上来说，有四种：</p> <ul><li>通用首部字段(General Header Fields)：请求和响应报文都会用的字段</li> <li>请求首部字段(Request Header Fields)：请求报文时用的字段</li> <li>响应首部字段(Response Header Fields)：响应报文时用的字段</li> <li>实体首部字段(Entity Header Fields)：请求和响应报文的实体部分用的字段</li></ul> <p>而每一种类型下面又有很多字段，可能一下要记这么多也比较难，所以面试时能尽量把自己知道的说出来就可以了，让面试官知道对于一些重要的字段你还是有了解的。</p> <p>以下我列举了一些，不过标了星号的可是重点哦。</p> <h4 id="通用首部字段"><a href="#通用首部字段" class="header-anchor">#</a> 通用首部字段</h4> <p><img src="https://s.poetries.top/gitee/2020/09/152.png" alt=""></p> <p>这边有一个需要注意的点：</p> <p><code>Connection</code>首部字段有一个值是<code>keep-alive</code>，表示开启持久连接。</p> <p>而其实还有一个首部字段也叫<code>Keep-Alive</code>，允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。</p> <p>对于这个<code>Keep-Alive</code>首部字段，有两个参数：</p> <ul><li><code>timeout</code>：指定了一个空闲连接需要保持打开状态的最小时长（以秒为单位）。需要注意的是，如果没有在传输层设置 keep-alive TCP message 的话，大于 TCP 层面的超时设置会被忽略。</li> <li><code>max</code>：在连接关闭之前，在此连接可以发送的请求的最大值。在非管道连接中，除了 0 以外，这个值是被忽略的，因为需要在紧跟着的响应中发送新一次的请求。HTTP 管道连接则可以用它来限制管道的使用。</li></ul> <p>案例🌰：</p> <div class="language- extra-class"><pre class="language-text"><code>HTTP/1.1 200 OK
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Thu, 11 Aug 2016 15:23:13 GMT
Keep-Alive: timeout=5, max=1000
Last-Modified: Mon, 25 Jul 2016 04:32:39 GMT
Server: Apache

(body)
</code></pre></div><blockquote><p>需要将 The Connection 首部的值设置为  "keep-alive" 这个首部才有意义。同时需要注意的是，在HTTP/2 协议中， Connection 和 Keep-Alive  是被忽略的；在其中采用其他机制来进行连接管理。</p></blockquote> <h4 id="请求首部字段"><a href="#请求首部字段" class="header-anchor">#</a> 请求首部字段</h4> <p><img src="https://s.poetries.top/gitee/2020/09/153.png" alt=""></p> <h4 id="响应首部字段"><a href="#响应首部字段" class="header-anchor">#</a> 响应首部字段</h4> <p><img src="https://s.poetries.top/gitee/2020/09/154.png" alt=""></p> <h4 id="实体首部字段"><a href="#实体首部字段" class="header-anchor">#</a> 实体首部字段</h4> <p><img src="https://s.poetries.top/gitee/2020/09/155.png" alt=""></p> <h3 id="_4-3-非标准的首部字段"><a href="#_4-3-非标准的首部字段" class="header-anchor">#</a> 4.3 非标准的首部字段</h3> <p>因为HTTP首部字段是可以自行扩展的，所以在Web服务器和浏览器的应用上，出现了一些非标准的首部字段。</p> <p>有这么一些：</p> <p><img src="https://s.poetries.top/gitee/2020/09/156.png" alt=""></p> <p>另外关于<code>Cookie</code>这块内容也还是挺多的，所以我也会单独放在第三章来进行讲解。</p> <h3 id="_4-4-accept相关字段"><a href="#_4-4-accept相关字段" class="header-anchor">#</a> 4.4 Accept相关字段</h3> <p>还有一个比较重要的点就是几种<code>Accept</code>相关的首部字段。</p> <h4 id="权重"><a href="#权重" class="header-anchor">#</a> 权重</h4> <p>当有多个字段值的时候，可以指定字段 q 来作为权重，权重范围 0～1。</p> <p>例如：</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Accept</span><span class="token punctuation">:</span> <span class="token header-value">text/html, q=1; application/xml, q=0.8</span></span>
</code></pre></div><h4 id="五种类别"><a href="#五种类别" class="header-anchor">#</a> 五种类别</h4> <p>（图中的序号并无优先级的意思，只是单纯的作为标记）</p> <p><img src="https://s.poetries.top/gitee/2020/09/157.png" alt=""></p> <p>需要注意的是：</p> <p><code>If-Range</code> 和 <code>Range</code>以及 <code>Accept-Ranges</code> 和 <code>Content-Range</code></p> <p>这四个字段只有<code>Accept-Ranges</code>是有<code>s</code>的。</p> <h2 id="_5-编码提升传输速率"><a href="#_5-编码提升传输速率" class="header-anchor">#</a> 5. 编码提升传输速率</h2> <p>对于「编码提升传输速率」，我主要是将它分为了两部分讲解：</p> <ul><li>内容编码</li> <li>传输编码</li></ul> <p>首先说下两者的区别吧：</p> <ul><li><code>内容编码</code>通常用于对实体内容进行压缩编码，目的是优化传输，例如用 gzip 压缩文本文件，能大幅减小体积。且它通常是有选择性的，例如<code>jpg、png</code>这类文件一般不开启，因为图片格式已经是高度压缩过的，再压一遍没什么效果不说还浪费 CPU。</li> <li><code>传输编码</code>则是用来改变报文格式，通常在头部加入 <code>Transfer-Encoding: chunked</code>，实现分块编码。</li></ul> <p>相同点：</p> <ul><li>都是作用在实体主体上的可逆变换。这句话的意思是说：例如服务器使用了<code>gzip</code>压缩了原始的响应体然后发送给浏览器，浏览器在得到之后可以对这个被压缩的响应体进行解码得到原始内容。</li></ul> <h3 id="_5-1-内容编码"><a href="#_5-1-内容编码" class="header-anchor">#</a> 5.1 内容编码</h3> <h4 id="内容编码介绍"><a href="#内容编码介绍" class="header-anchor">#</a> 内容编码介绍</h4> <p><code>内容编码</code>表示HTTP应用程序有时在发送请求之前需要对内容进行编码，例如我们常听见的通过<strong>Content-Encoding</strong>来指定内容的压缩方式，通过<strong>Content-Length</strong>来指定文件大小。</p> <p>内容编码的具体过程主要是：</p> <ul><li>服务器生成原始响应报文，其中有原始的<code>Content-Type</code>和<code>Content-Length</code>首部字段</li> <li>接着将原始的响应报文经过<code>内容编码服务器</code>创建编码后的报文。这个编码后的报文同样有<code>Content-Type</code>和<code>Content-Length</code>两个字段，只不过<code>Content-Length</code>是有可能变的，例如主体经过了压缩，那么它的值肯定就变小了。</li> <li>除了上述两个字段，还会在编码后的报文中增加<code>Content-Encoding</code>首部，这样收到的应用程序就可以进行解码了。</li> <li>接收程序收到编码后的报文再进行解码，获得原始报文。</li></ul> <p>(具体过程可以看后面的HTTP压缩的具体过程，与此情况大同小异)</p> <h4 id="内容编码类型"><a href="#内容编码类型" class="header-anchor">#</a> 内容编码类型</h4> <p>HTTP定义了一些标准的内容编码类型，主要是由<code>Content-Encoding</code>和<code>Accept-Encoding</code>首部字段来进行控制。</p> <p>内容编码类型的不同，实际上是使用了不同的算法，例如<code>gzip</code>算法、<code>deflate</code>算法。而标示需要使用哪种算法来进行内容编码，则需要用到<code>内容编码代号</code>，也就是<code>Content-Encoding</code>的值，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>Content-Encoding: gzip
</code></pre></div><p>主要是有这么几种内容编码代号：</p> <ul><li>gzip：实体采用GUN zip 编码</li> <li>compress：实体采用Unix的文件压缩程序</li> <li>deflate：实体使用zlib的格式压缩</li> <li>identity：不对实体进行编码。当没有<code>Content-Encoding</code>首部的时候，就默认这种情况</li></ul> <p>补充：</p> <ul><li>br：实体采用Brotli算法编码</li></ul> <p>注意⚠️：</p> <ul><li><p><code>Content-Encoding</code>是在响应报文中定义的首部，用于告诉浏览器我采用了哪种编码方式，你得按这种编码方式来进行解析。</p></li> <li><p><code>Accept-Encoding</code>是在请求报文中定义的首部，用于告诉服务器我支持哪些编码方式，你可以按这些编码方式来进行编码然后传输给我。</p></li> <li><p>另外，如果HTTP请求中没有<code>Accept-Encoding</code>首部的话，服务器就会假设客户端能够接受任何编码方式，也就是等价于<code>Accept-Encoding: *</code> 这种情况。</p></li> <li><p><code>gzip</code>压缩方式使用最为广泛，而<code>brotli</code>是一种比<code>Gzip</code>压缩率更高的算法，编码代号为<code>br</code>。在兼容性上<code>br</code>已经支持了大部分的浏览器，不过<code>br</code>压缩只能在<code>HTTPS</code>中生效，因为在<code>HTTP</code>请求中<code>request header</code>里的<code>Accept-Encoding</code>是没有<code>br</code>这个选项的。</p></li></ul> <h4 id="内容编码与http压缩"><a href="#内容编码与http压缩" class="header-anchor">#</a> 内容编码与HTTP压缩</h4> <p>HTTP压缩，在HTTP协议中，其实是内容编码的一种。</p> <p>因为内容编码的类型会有很多种，而使用一些特定编码类型，例如<code>gzip</code>，就能实现对内容<code>(body)</code>进行压缩，</p> <p>这样可以有助于减少传输实体的时间。</p> <p>也可以使用其他的编码把内容搅乱或加密，以此来防止未授权的第三方看到文档的内容。</p> <p>所以我们说HTTP压缩，其实就是HTTP内容编码的一种。</p> <h4 id="http压缩的具体过程"><a href="#http压缩的具体过程" class="header-anchor">#</a> HTTP压缩的具体过程</h4> <p>HTTP压缩是指: Web服务器和浏览器之间压缩传输的<code>文本内容</code>的方法。</p> <p>HTTP采用通用的压缩算法，比如<code>gzip</code>来压缩<code>html,javascript, CSS</code>文件。 能大大减少网络传输的数据量，提高了用户显示网页的速度。</p> <p>既然HTTP压缩是内容编码的一种，那么它的压缩过程其实也就是遵循了内容编码的过程。</p> <p>在此，我们以<code>Accept-Encoding: gzip</code>为例，也就是<code>gzip</code>压缩：</p> <ul><li>浏览器发送HTTP请求给服务器，并且请求报文中带有<code>Accept-Encoding: gzip</code>首部字段(告诉服务器，浏览器支持<code>gzip</code>压缩)</li> <li>服务器在接受到请求之后，首先生成原始的响应，其中原始的响应中有：<code>Content-Type</code>和<code>Content-Length</code></li> <li>接着通过<code>gzip内容编码器</code>进行编码，编码后请求的<code>header</code>中有<code>Content-Type</code>和<code>Content-Length</code>，还新增了<code>Content-Encoding: gzip</code>，并且把此请求发送给浏览器</li> <li>浏览器在接受到请求后，根据<code>Content-Encoding: gzip</code>来对请求进行解码，这里应该也有一个<code>gzip内容解码器</code>，然后得到原始的响应。</li></ul> <p>让我们来看张图：</p> <p><img src="https://s.poetries.top/gitee/2020/09/158.png" alt=""></p> <p>可以看到，在这里原始响应虽然被压缩过了，但是后面还是能经过解码器转为原始内容，所以这就是前面提到的<code>可逆变换</code>。</p> <h4 id="gzip的相关知识点"><a href="#gzip的相关知识点" class="header-anchor">#</a> gzip的相关知识点</h4> <blockquote><p>gzip, compress, 以及deflate编码都是无损压缩算法，用于减少传输报文的大小，不会导致信息损失。 其中gzip通常效率最高， 使用最为广泛。</p></blockquote> <p><strong>压缩的好处</strong></p> <p><code>HTTP</code>压缩对纯文本可以压缩至原内容的40%, 从而节省了60%的数据传输。</p> <p><strong>gzip的缺点</strong></p> <ul><li>内容编码和内容的具体格式细节紧密相关，使用<code>gzip</code>压缩文本文件非常合适，但<code>png、gif、jpg、jpeg</code>这类图片文件并不推荐使用<code>gzip</code>压缩（svg是个例外），首先经过压缩后的图片文件gzip能压缩的空间很小。事实上，添加标头，压缩字典，并校验响应体可能会让它更大。</li> <li>压缩本身是需要耗费时间，我们可以理解为我们是以服务器压缩的时间开销和CPU开销为代价，省下了一些传输过程中的时间开销。</li></ul> <p>(来源：<a href="https://juejin.im/post/5d27dd2de51d454f6f16ec89#heading-1" target="_blank" rel="noopener noreferrer">前端性能优化gzip初探（补充gzip压缩使用算法brotli压缩的相关介绍)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</p> <p><strong>gzip是如何压缩的</strong></p> <p>简单来说， <code>gzip</code>压缩是在一个文本文件中找出类似的字符串， 并临时替换他们，使整个文件变小。这种形式的压缩对Web来说非常适合， 因为<code>HTML</code>和<code>CSS</code>文件通常包含大量的重复的字符串，例如空格，标签。</p> <p><strong>Request可以压缩吗？</strong></p> <p>浏览器是不会对<code>Request</code>压缩的。 但是一些HTTP程序在发送<code>Request</code>时，会对其进行编码。</p> <h3 id="_5-2-传输编码"><a href="#_5-2-传输编码" class="header-anchor">#</a> 5.2 传输编码</h3> <h4 id="产生原因"><a href="#产生原因" class="header-anchor">#</a> 产生原因</h4> <p>在非长连接的情况下浏览器可以通过连接是否关闭来界定请求或者响应的边界；而对于建立了长连接的情况，也就是设置了<code>Connection: keep-alive</code>这个头部，浏览器没法判断这次的数据是否传输完了，这时候就得计算<strong>实体的长度</strong>，并通过头部告诉浏览器，也就是使用<code>Content-Length</code>这个首部字段。</p> <p><code>Content-Length</code>如果比实际的长度短，就会造成内容被截断，甚至会影响下一次的请求；如果比实际的长度长，则会造成<code>pending</code>，这个请求一直在等待中直到超时。(但是在<code>HTTP/1.0</code>中由于长连接并未被标准化，所以这个字段可有可无)</p> <p>因此<code>Content-Length</code>的计算显的尤为重要，它必须真实的反应实体长度。但又由于很多时候实体长度并没有那么容易获得，例如实体来自于网络文件，或者由动态语言生成。而这时候如果需要等待<code>Content-Length</code>的计算的话，无疑会影响到<code>TTFB(Time To First Byte)</code>，也就是从客户端发出请求到收到响应的第一个字节所花费的时间。越短的<code>TTFB</code>则能让用户更早的看到页面内容，体验越好。</p> <p>所以这就是<code>Transfer-Encoding</code>产生的原因，它解决了：不依赖头部的长度信息，也能知道实体的边界。</p> <h4 id="transfer-encoding-chunked"><a href="#transfer-encoding-chunked" class="header-anchor">#</a> Transfer-Encoding: chunked</h4> <p>是不是感觉上面那句话不好理解呢？</p> <p><strong>没有<code>Transfer-Encoding</code>:</strong></p> <p>没有<code>Transfer-Encoding</code>的时候，服务器在传输给浏览器数据的时候可能是这样的：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'net'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">sock</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sock<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'HTTP/1.1 200 OK\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'Content-Length: 9\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'lindaidai'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">,</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>浏览器接收到数据之后就能通过<code>Content-Length</code>与实体长度做一个比对，判定数据是否传输完成。</p> <p>但这样在传输大量数据的时候，复杂的计算<code>Content-Length</code>就可能会影响前面提到的<code>TTFB</code>。</p> <p><strong>设置<code>Transfer-Encoding: chunked</code>:</strong></p> <p>设置了此首部之后，表明这是一次分块传输，可以将报文实体改为用一系列分块来传输：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'net'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">sock</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sock<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'HTTP/1.1 200 OK\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'Transfer-Encoding: chunked\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'a\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'0123456789\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'6\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'daidai\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'0\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sock<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'\r\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">,</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这次的传输有以下几个特点：</p> <ul><li>每个分块会有两部分内容：十六进制的长度和数据(例如<code>a\r\n</code>表示的就是长度为<code>10</code>，因为<code>a</code>是十六进制中的<code>10</code>；后面的<code>0123456789</code>就表示数据)</li> <li>长度值独占一行，长度不包括它结尾的<code>CRLF(\r\n)</code>，也不包括分块数据结尾的<code>CRLF</code>。</li> <li>最后一个分块的长度值必须是<code>0</code>，且对应分块数据没有内容，它表示的是实体结束。</li></ul> <p><img src="https://s.poetries.top/gitee/2020/09/159.png" alt=""></p> <p>可以看到，通过设置<code>Transfer-Encoding: chunked</code>，这种简单的分块策略就能解决前面提到的那个问题。</p> <p><strong>使用场景</strong>：</p> <p>所以在使用场景上，我认为主要有：</p> <ul><li>传输大量数据的时候</li> <li>配合<code>压缩编码</code>来进行传输(5.4里会提到)</li></ul> <h3 id="_5-3-transfer-encoding的取值"><a href="#_5-3-transfer-encoding的取值" class="header-anchor">#</a> 5.3 Transfer-Encoding的取值</h3> <p>历史上 <code>Transfer-Encoding</code> 可以有多种取值，为此还引入了一个名为 <code>TE</code> 的头部用来协商采用何种传输编码。但是最新的<code>HTTP</code>规范里，只定义了一种传输编码：分块编码(<code>chunked</code>)。</p> <h3 id="_5-4-transfer-encoding结合content-encoding"><a href="#_5-4-transfer-encoding结合content-encoding" class="header-anchor">#</a> 5.4 Transfer-Encoding结合Content-Encoding</h3> <p>通过前面的介绍，我们知道了：</p> <ul><li><code>Transfer-Encoding: chunked</code>表明分块传输</li> <li><code>Content-Encoding: gzip</code>表明使用<code>gzip</code>压缩传输</li></ul> <p>二者经常会结合来用，其实就是针对进行了内容编码（压缩）的内容再进行传输编码（分块）。</p> <p>例如如下：</p> <div class="language- extra-class"><pre class="language-text"><code>GET /index.html HTTP/1.1
Host: lindaidai.com
Accept-Encoding: gzip

HTTP/1.1 200 OK
Server: nginx/1.10.2
Date: Mon, 25 May 2020 07:36:22 GMT
Content-Type: text/html
Transfer-Encoding: chunked
Connection: keep-alive
Content-Encoding: gzip

dsf
�H���W(�/�I�J

0
</code></pre></div><h2 id="_6-多部分对象集合-multipart"><a href="#_6-多部分对象集合-multipart" class="header-anchor">#</a> 6. 多部分对象集合(Multipart)</h2> <p>HTTP协议中采纳了多部分对象集合(Multipart)，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。</p> <p>多部分对象集合包含的对象如下：</p> <p><code>multipart/form-data</code>：在Web表单文件上传时使用。</p> <p><code>multipart/byteranges</code>：状态码206(Partial Content, 部分内容)响应报文包含了多个范围的内容时使用。</p> <p>例如：</p> <div class="language- extra-class"><pre class="language-text"><code>Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name="field1"

--AaB03x
Content-Disposition: form-data; name="pics";
filename="file1.txt"
Content-Type: text/plain

...(file1.txt的数据)...
--AaB03x--
</code></pre></div><p>注意⚠️：</p> <ul><li>在HTTP报文中使用多部分对象集合时，需要在首部字段里加上<code>Content-Type</code>。</li> <li>使用<code>boundary</code>字符串来划分多部分对象集合指明的各类实体。</li> <li>在boundary字符串指定的各个实体的起始行之前插入<code>"--"</code>标记，而在多部分对象集合对应的字符串的最后插入<code>"–"</code>标记作为结束。</li></ul> <h2 id="_7-获取部分内容的范围请求"><a href="#_7-获取部分内容的范围请求" class="header-anchor">#</a> 7. 获取部分内容的范围请求</h2> <p><strong>概念：</strong></p> <p>可以指定下载实体范围，也就是说在一次请求内可以不加载整个的实体，而是只加载实体中的一部分。</p> <p><strong>如何实现？</strong></p> <p>例如有一个<code>10000</code>字节的实体，可以只请求<code>5001 ~ 10000</code>字节内的资源。</p> <ul><li><p>请求报文首部字段<code>Range</code> 来指定<code>byte</code>范围</p> <div class="language- extra-class"><pre class="language-text"><code>If-Range: 'userage-12234'
Range: bytes=5001-10000
</code></pre></div></li> <li><p>响应报文使用<code>Content-Range</code>告诉客户端此次的请求范围：</p> <div class="language- extra-class"><pre class="language-text"><code>HTTP/1.1 206 Partial Content
Accept-Ranges: bytes
Content-Range: bytes 5001-10000/10000
</code></pre></div><p>若是无法处理的话，则返回<code>200 OK</code>以及整个资源。</p></li></ul> <p>需要注意的点⚠️：</p> <ol><li><p>一般要配合<code>If-Range</code>来用，它告知服务器如果<code>If-Range</code>的值(<code>ETag</code>或者最后修改时间)的值和服务器资源 <code>ETage</code>或者时间一致则作为范围请求处理，也就是返回<code>Range</code>字段中的部分资源；否则就返回整个资源。</p></li> <li><p><code>If-Range</code> 和 <code>Range</code>以及 <code>Accept-Ranges</code> 和 <code>Content-Range</code></p> <p>这四个字段只有<code>Accept-Ranges</code>是有<code>s</code>的。</p></li></ol> <p><strong>案例🌰</strong>：</p> <p>可以来一个案例看看：</p> <p>请求：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 请求 --&gt;
GET /me.jpg HTTP/1.1
Host: lindaidai.com
Range: bytes=5001-10000

&lt;!-- 响应 --&gt;
HTTP/1.1 206 Partial Content
Data: Mon, 25 May 2020 12:56:52 GMT
Content-Range: bytes 5001-10000/10000
Content-Length: 5000
Content-Type: image/jpeg
</code></pre></div></div> <!----> <div class="readMore-wrapper"><span class="readMore">阅读全文</span></div>
                    </div>
                            <p>这是一个信息提示框。</p>
                        </div>

                        <div class="note warning">
                            <div class="note-title"><i class="fas fa-exclamation-triangle"></i> 注意</div>
                            <p>这是一个警告提示框。</p>
                        </div>

                        <div class="note success">
                            <div class="note-title"><i class="fas fa-check-circle"></i> 成功</div>
                            <p>这是一个成功提示框。</p>
                        </div>

                        <h2>代码示例</h2>
                        <pre><code class="language-javascript">// 示例代码
function example() {
    console.log('Hello, FrontendHub!');
}
</code></pre>
                    </div>

                    <!-- 文章底部导航 -->
                    <nav class="article-nav">
                        <a href="#" class="prev-article">
                            <i class="fas fa-chevron-left"></i>
                            <span>上一篇</span>
                        </a>
                        <a href="#" class="next-article">
                            <span>下一篇</span>
                            <i class="fas fa-chevron-right"></i>
                        </a>
                    </nav>
                </article>
            </div>
        </div>
    </main>

    <!-- 页脚 -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4><i class="fas fa-code"></i> FrontendHub</h4>
                    <p>专注于前端技术学习与面试准备</p>
                </div>
                <div class="footer-section">
                    <h4>快速链接</h4>
                    <ul>
                        <li><a href="../../index.html">首页</a></li>
                        <li><a href="../index.html#courses">课程体系</a></li>
                        <li><a href="../index.html#resources">学习资源</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 FrontendHub. 用于个人学习使用.</p>
            </div>
        </div>
    </footer>

    <!-- 返回顶部按钮 -->
    <button class="back-to-top" id="backToTop">
        <i class="fas fa-arrow-up"></i>
    </button>

    <script src="../../js/main.js"></script>
    <script src="../../js/content.js"></script>
</body>
</html>

