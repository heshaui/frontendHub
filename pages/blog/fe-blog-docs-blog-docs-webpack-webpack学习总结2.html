<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>webpack学习总结 - FrontendHub</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/content.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body class="content-page">
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="../../index.html" style="color: inherit; text-decoration: none; display: flex; align-items: center; gap: 0.5rem;">
                    <i class="fas fa-code"></i>
                    <span>FrontendHub</span>
                </a>
            </div>
            <button class="nav-toggle" id="navToggle">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-menu" id="navMenu">
                <li><a href="../../index.html">首页</a></li>
                <li><a href="../index.html#features">特色</a></li>
                <li><a href="../index.html#courses">课程</a></li>
                <li><a href="../index.html#resources">资源</a></li>
            </ul>
        </div>
    </nav>

    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <div class="container">
            <a href="../../index.html"><i class="fas fa-home"></i> 首页</a>
            <i class="fas fa-chevron-right"></i>
            <span>webpack学习总结</span>
        </div>
    </div>

    <!-- 主要内容区 -->
    <main class="content-main">
        <div class="container">
            <div class="content-layout">
                <!-- 侧边栏目录 -->
                <aside class="sidebar">
                    <div class="sidebar-sticky">
                        <h3><i class="fas fa-list"></i> 目录</h3>
                        <nav class="toc" id="toc">
                            <!-- 目录将通过JavaScript自动生成 -->
                        </nav>
                    </div>
                </aside>

                <!-- 文章内容 -->
                <article class="article">
                    <header class="article-header">
                        <h1>webpack学习总结</h1>
                        <div class="article-meta">
                            <span><i class="far fa-calendar"></i> 更新时间：2025-12-23</span>
                            <span><i class="far fa-clock"></i> 阅读时长：约 15 分钟</span>
                        </div>
                    </header>

                    <div class="article-content">
<div class="content__default"><blockquote><p>声明 本教程整理于互联网</p></blockquote> <blockquote><p><code>webpack</code>是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，到实际需要的时候再异步加载。通过 <code>loader</code> 的转换，任何形式的资源都可以视作模块，比如<code>CommonJs</code>模块、 <code>AMD</code> 模块、 <code>ES6</code> 模块、<code>CSS</code>、图片、 <code>JSON</code>、<code>Coffeescript</code>、 LESS等</p></blockquote> <h2 id="一、模块系统的演进"><a href="#一、模块系统的演进" class="header-anchor">#</a> 一、模块系统的演进</h2> <hr> <ul><li><p>模块系统主要解决模块的定义、依赖和导出，先来看看已经存在的模块系统</p></li> <li><p><code>&lt;script&gt;</code>标签</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;script src="module1.js"&gt;&lt;/script&gt;
&lt;script src="module2.js"&gt;&lt;/script&gt;
&lt;script src="libraryA.js"&gt;&lt;/script&gt;
&lt;script src="module3.js"&gt;&lt;/script&gt;
</code></pre></div><ul><li><p>这是最原始的 <code>JavaScript</code> 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 <code>window</code> 对象中，不同模块的接口调用都是一个作用域中，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子如 <code>YUI</code> 库</p></li> <li><p>这种原始的加载方式暴露了一些显而易见的弊端</p> <ul><li>全局作用域下容易造成变量冲突</li> <li>文件只能按照 <code>&lt;script&gt;</code>的书写顺序进行加载</li> <li>开发人员必须主观解决模块和代码库的依赖关系</li> <li>在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪</li></ul></li></ul> <h3 id="_1-1-commonjs"><a href="#_1-1-commonjs" class="header-anchor">#</a> 1.1 CommonJS</h3> <hr> <ul><li>服务器端的 <code>Node.js</code>遵循 <code>CommonJS</code>规范，该规范的核心思想是允许模块通过<code>require</code>方法来同步加载所要依赖的其他模块，然后通过 <code>exports</code> 或 <code>module.exports</code> 来导出需要暴露的接口</li></ul> <div class="language- extra-class"><pre class="language-text"><code>require("module");
require("../file.js");
exports.doStuff = function() {};
module.exports = someValue;
</code></pre></div><ul><li><p>优点：</p> <ul><li>服务器端模块便于重用</li> <li><code>NPM</code> 中已经有将近<code>20</code>万个可以使用模块包</li> <li>简单并容易使用</li></ul></li> <li><p>缺点：</p> <ul><li>同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的</li> <li>不能非阻塞的并行加载多个模块</li></ul></li> <li><p>实现</p></li> <li><p>服务器端的 <code>Node.js</code></p></li> <li><p><code>Browserify</code>，浏览器端的 <code>CommonJS</code> 实现，可以使用 <code>NPM</code>的模块，但是编译打包后的文件体积可能很大</p></li> <li><p><code>modules-webmake</code>，类似<code>Browserify</code>，还不如 <code>Browserify</code> 灵活</p></li> <li><p><code>wreq</code>，<code>Browserify</code>的前身</p></li></ul> <h3 id="_1-2-amd"><a href="#_1-2-amd" class="header-anchor">#</a> 1.2 AMD</h3> <hr> <blockquote><p><code>Asynchronous Module Definition</code> 规范其实只有一个主要接口<code>define(id?, dependencies?,factory)</code> ，它要在声明模块的时候指定所有的依赖 <code>dependencies</code>，并且还要当做形参传到<code>factory</code> 中，对于依赖的模块提前执行，依赖前置</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>define("module", ["dep1", "dep2"], function(d1, d2) {
return someExportedValue;
});require(["module", "../file"], function(module, file) { /* ... */ });
</code></pre></div><ul><li><p>优点：</p> <ul><li>适合在浏览器环境中异步加载模块</li> <li>可以并行加载多个模块</li></ul></li> <li><p>缺点：</p> <ul><li>提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义 不顺畅</li> <li>不符合通用的模块化思维方式，是一种妥协的实现</li></ul></li> <li><p>实现：</p> <ul><li><code>RequireJS</code></li> <li><code>curl</code></li></ul></li></ul> <h3 id="_1-3-cmd"><a href="#_1-3-cmd" class="header-anchor">#</a> 1.3 CMD</h3> <hr> <ul><li><code>Common Module Definition</code> 规范和 <code>AMD</code>很相似，尽量保持简单，并与 <code>CommonJS</code> 和<code>Node.js</code> 的 <code>Modules</code>规范保持了很大的兼容性</li></ul> <div class="language- extra-class"><pre class="language-text"><code>define(function(require, exports, module) {
var $ = require('jquery');
var Spinning = require('./spinning');
exports.doSomething = ...
module.exports = ...
})
</code></pre></div><ul><li>优点：
<ul><li>依赖就近，延迟执行</li> <li>可以很容易在 <code>Node.js</code> 中运行</li></ul></li> <li>缺点：
<ul><li>依赖 <code>SPM</code> 打包，模块的加载逻辑偏重</li></ul></li> <li>实现：
<ul><li><code>Sea.js</code></li> <li><code>coolie</code></li></ul></li></ul> <h3 id="_1-4-es6-模块"><a href="#_1-4-es6-模块" class="header-anchor">#</a> 1.4 ES6 模块</h3> <hr> <ul><li><code>EcmaScript6</code> 标准增加了 <code>JavaScript</code>语言层面的模块体系定义。<code>ES6</code> 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。<code>CommonJS</code> 和<code>AMD</code> 模块，都只能在运行时确定这些东西</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import "jquery";
export function doStuff() {}
module "localModule" {}
</code></pre></div><ul><li>优点：
<ul><li>容易进行静态分析</li> <li>面向未来的 <code>EcmaScript</code>标准</li></ul></li> <li>缺点：
<ul><li>原生浏览器端还没有实现该标准</li> <li>全新的命令字，新版的 <code>Node.js</code>才支持</li></ul></li> <li>实现：
<ul><li><code>Babel</code></li></ul></li></ul> <h3 id="_1-5-前端模块加载"><a href="#_1-5-前端模块加载" class="header-anchor">#</a> 1.5 前端模块加载</h3> <hr> <ul><li>前端模块要在客户端中执行，所以他们需要增量加载到浏览器中</li> <li>模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是把所有模块打包成一个文件然后只请求一次。显而易见，每个模块都发起单独的请求造成了请求次数过多，导致应用启动速度慢；一次请求加载所有模块导致流量浪费、初始化过程慢。这两种方式都不是好的解决方案，它们过于简单粗暴</li> <li>分块传输，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案</li> <li>要实现模块的按需加载，就需要一个对整个代码库中的模块进行静态分析、编译打包的过
程</li></ul> <h3 id="_1-6-所有资源都是模块"><a href="#_1-6-所有资源都是模块" class="header-anchor">#</a> 1.6 所有资源都是模块</h3> <hr> <blockquote><p>在上面的分析过程中，我们提到的模块仅仅是指<code>JavaScript</code>模块文件。然而，在前端开发过程中还涉及到样式、图片、字体、<code>HTML</code> 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 <code>coffeescript</code>、 <code>less</code>、 <code>sass</code>、众多的模板库、多语言系统（<code>i18n</code>）等</p></blockquote> <ul><li>如果他们都可以视作模块，并且都可以通过 <code>require</code> 的方式来加载，将带来优雅的开发体验，比如</li></ul> <div class="language- extra-class"><pre class="language-text"><code>require("./style.css");
require("./style.less");
require("./template.jade");
require("./image.png");
</code></pre></div><ul><li>那么如何做到让 <code>require</code> 能加载各种资源呢？</li></ul> <h3 id="_1-7-静态分析"><a href="#_1-7-静态分析" class="header-anchor">#</a> 1.7 静态分析</h3> <hr> <blockquote><p>在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们依赖关系，然后将不同类型的模块提交给适配的加载器来处理。比如一个用<code>LESS</code> 写的样式模块，可以先用<code>LESS</code> 加载器将它转成一个<code>CSS</code>模块，在通过 <code>CSS</code> 模块把他插入到页面的 <code>&lt;style&gt;</code> 标签中执行。<code>Webpack</code>就是在这样的需求中应运而生</p></blockquote> <h2 id="二、webpack基础知识"><a href="#二、webpack基础知识" class="header-anchor">#</a> 二、webpack基础知识</h2> <hr> <h3 id="_2-1-什么是-webpack"><a href="#_2-1-什么是-webpack" class="header-anchor">#</a> 2.1 什么是 Webpack</h3> <hr> <ul><li><code>Webpack</code> 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源</li></ul> <h3 id="_2-2-webpack-的特点"><a href="#_2-2-webpack-的特点" class="header-anchor">#</a> 2.2  Webpack 的特点</h3> <hr> <ul><li><p>代码拆分</p> <ul><li><code>Webpack</code>有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包</li></ul></li> <li><p>Loader</p> <ul><li><code>Webpack</code> 本身只能处理原生的 <code>JavaScript</code> 模块，但是 <code>loader</code> 转换器可以将各种类型的资源转换成 <code>JavaScript</code> 模块。这样，任何资源都可以成为 <code>Webpack</code>可以处理的模块</li></ul></li> <li><p>智能解析</p> <ul><li><code>Webpack</code> 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是<code>CommonJS</code>、 <code>AMD</code>还是普通的 <code>JS</code> 文件。甚至在加载依赖的时候，允许使用动态表达式<code>require("./templates/" + name + ".jade")</code></li></ul></li> <li><p>插件系统</p> <ul><li><code>Webpack</code> 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 <code>Webpack</code> 插件，来满足各式各样的需求</li></ul></li> <li><p>快速运行</p> <ul><li><code>Webpack</code> 使用异步 <code>I/O</code> 和多级缓存提高运行效率，这使得 <code>Webpack</code>能够以令人难以置信的速度快速增量编译</li></ul></li></ul> <h3 id="_2-3-总览"><a href="#_2-3-总览" class="header-anchor">#</a> 2.3 总览</h3> <hr> <ul><li>他的目的就是把有依赖关系的各种文件打包成一系列的静
态资源</li> <li><code>webpack</code>简单点来说就就是一个配置文件，所有的魔力都是在这一个文件中发生的。 这个配置文件主要分
为三大块
<ul><li><code>entry</code> 入口文件 让<code>webpack</code>用哪个文件作为项目的入口</li> <li><code>output</code> 出口 让<code>webpack</code>把处理完成的文件放在哪里</li> <li><code>module</code> 模块 要用什么不同的模块来处理各种类型的文件</li></ul></li></ul> <p><img src="https://s.poetries.top/gitee/2019/10/661.png" alt=""></p> <h3 id="_2-4-安装"><a href="#_2-4-安装" class="header-anchor">#</a> 2.4 安装</h3> <hr> <ul><li>先装好node和npm，因为webpack是一个基于node的项目。然后</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install -g webpack
</code></pre></div><ul><li>此时 <code>Webpack</code>已经安装到了全局环境下，可以通过命令行<code>webpack -h</code> 试试</li> <li>通常我们会将 <code>Webpack</code>安装到项目的依赖中，这样就可以使用项目本地版本的 <code>Webpack</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code># 进入项目目录
# 确定已经有 package.json，没有就通过 npm init 创建
# 安装 webpack 依赖
$ npm install webpack --save-dev
</code></pre></div><blockquote><p><code>Webpack</code> 目前有两个主版本，一个是在 master 主干的稳定版，一个是在 <code>webpack-2</code> 分支的测试版，测试版拥有一些实验性功能并且和稳定版不兼容，在正式项目中应该使用稳定版</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code># 查看 webpack 版本信息
$ npm info webpack
# 安装指定版本的 webpack
$ npm install webpack@1.12.x --save-dev
</code></pre></div><ul><li>如果需要使用 <code>Webpack</code>开发工具，要单独安装</li></ul> <div class="language- extra-class"><pre class="language-text"><code>$ npm install webpack-dev-server --save-dev
</code></pre></div><h3 id="_2-5-建立一个项目"><a href="#_2-5-建立一个项目" class="header-anchor">#</a> 2.5  建立一个项目</h3> <hr> <div class="language- extra-class"><pre class="language-text"><code>mkdir webpack
cd webpack
npm init
</code></pre></div><ul><li>如果你使用git管理你的这个项目的话，建议你新建一个<code>.gitignore</code>文件，不要让<code>git</code>提交一些<code>node</code>依赖的模
块</li> <li>创建一个静态页面 <code>index.html</code> 和一个 <code>JS</code> 入口文件 <code>entry.js：</code></li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- index.html --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bundle.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// entry.js</span>
document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'It works.'</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>然后编译 <code>entry.js</code> 并打包到 <code>bundle.js</code>：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>$ webpack entry.js bundle.js
</code></pre></div><ul><li>打包过程会显示日志：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Hash: e964f90ec65eb2c29bb9
Version: webpack 1.12.2
Time: 54ms
Asset Size Chunks Chunk Names
bundle.js 1.42 kB 0 [emitted] main
[0] ./entry.js 27 bytes {0} [built]
</code></pre></div><ul><li>用浏览器打开 <code>index.html</code> 将会看到 <code>It works.</code></li> <li>接下来添加一个模块 <code>module.js</code>并修改入口 <code>entry.js</code>：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// module.js
module.exports = 'It works from module.js.'
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// entry.js
document.write('It works.')
document.write(require('./module.js')) // 添加模块
</code></pre></div><ul><li><p>重新打包 <code>webpack entry.js bundle.js</code>后刷新页面看到变化 <code>It works.It works from module.js.</code></p></li> <li><p><code>Webpack</code> 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到<code>bundle.js</code> 。<code>Webpack</code> 会给每个模块分配一个唯一的<code>id</code>并通过这个<code>id</code> 索引和访问模块。在页面启动时，会先执<code>entry.js</code> 中的代码，其它模块会在运行<code>require</code>的时候再执行</p></li></ul> <h2 id="三、loader"><a href="#三、loader" class="header-anchor">#</a> 三、Loader</h2> <hr> <ul><li><code>Webpack</code> 本身只能处理 <code>JavaScript</code> 模块，如果要处理其他类型的文件，就需要使用 <code>loader</code>进行转换</li> <li><code>Loader</code> 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如CoffeeScript、 JSX、 LESS</li></ul> <h3 id="_3-1-loader-有哪些特性"><a href="#_3-1-loader-有哪些特性" class="header-anchor">#</a> 3.1  loader 有哪些特性</h3> <hr> <ul><li><code>Loader</code> 可以通过管道方式链式调用，每个 <code>loader</code> 可以把资源转换成任意格式并传递给下一个 <code>loader</code> ，但是最后一个 <code>loader</code> 必须返回 <code>JavaScript</code></li> <li><code>Loader</code>可以同步或异步执行。</li> <li><code>Loader</code> 运行在 <code>node.js</code> 环境中，所以可以做任何可能的事情。</li> <li><code>Loader</code> 可以接受参数，以此来传递配置项给 <code>loader</code>。</li> <li><code>Loader</code> 可以通过文件扩展名（或正则表达式）绑定给不同类型的文件。</li> <li><code>Loader</code>可以通过 <code>npm</code>发布和安装。</li> <li>除了通过 <code>package.json</code>的 <code>main</code>指定，通常的模块也可以导出一个 <code>loader</code>来使用。</li> <li><code>Loader</code> 可以访问配置。</li> <li>插件可以让 <code>loader</code> 拥有更多特性。</li> <li><code>Loader</code>可以分发出附加的任意文件</li></ul> <blockquote><ul><li><code>Loader</code>本身也是运行在 <code>node.js</code> 环境中的 <code>JavaScript</code>模块，它通常会返回一个函数。大多数情况下，我们通过 npm 来管理 <code>loader</code>，但是你也可以在项目中自己写 <code>loader</code> 模块</li></ul></blockquote> <ul><li>按照惯例，而非必须，<code>loader</code> 一般以 <code>xxx-loader</code> 的方式命名， <code>xxx</code> 代表了这个 <code>loader</code>要做的转换功能，比如 <code>json-loader</code></li> <li>在引用 <code>loader</code> 的时候可以使用全名 <code>json-loader</code> ，或者使用短名 <code>json</code>。这个命名规则和搜索优先级顺序在<code>webpack</code> 的<code>resolveLoader.moduleTemplates api</code>中定义</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Default: ["*-webpack-loader", "*-web-loader", "*-loader", "*"]
</code></pre></div><ul><li><code>Loader</code>可以在 <code>require()</code>引用模块的时候添加，也可以在 <code>webpack</code> 全局配置中进行绑定，还可以通过命令行的方式使用</li> <li>我们要在页面中引入一个<code>CSS</code>文件<code>style.css</code>，首页将 <code>style.css</code>也看成是一个模块，然后用 <code>css-loader</code> 来读取它，再用<code>style-loader</code>把它插入到页面中</li></ul> <div class="language- extra-class"><pre class="language-text"><code>/* style.css */
body { 
  background: yellow; 
}
</code></pre></div><p>修改 entry.js：</p> <div class="language- extra-class"><pre class="language-text"><code>require("!style!css!./style.css") // 载入 style.css
document.write('It works.')
document.write(require('./module.js'))
</code></pre></div><p>安装 loader：</p> <div class="language- extra-class"><pre class="language-text"><code>npm install css-loader style-loader
</code></pre></div><p>重新编译打包，刷新页面，就可以看到黄色的页面背景了</p> <blockquote><p>如果每次   require CSS   文件的时候都要写   loader   前缀，是一件很繁琐的事情。我们可以根据模块类型（扩展名）来自动绑定需要的   loader</p></blockquote> <ul><li>将   <code>entry.js</code>  中的 <code>require("!style!css!./style.css")</code>修改为 <code>require("./style.css")</code>，然后执行：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>$ webpack entry.js bundle.js --module-bind 'css=style!css'
# 有些环境下可能需要使用双引号
$ webpack entry.js bundle.js --module-bind "css=style!css"
</code></pre></div><ul><li>显然，这两种使用 <code>loader</code> 的方式，效果是一样的</li></ul> <h2 id="四、配置webpack"><a href="#四、配置webpack" class="header-anchor">#</a> 四、配置webpack</h2> <hr> <blockquote><p><code>Webpack</code>在执行的时候，除了在命令行传入参数，还可以通过指定的配置文件来执行。默认情况下，会搜索当前目<code>webpack.config.js</code> 文件，这个文件是一个 <code>node.js</code>模块，返回一个<code>json</code> 格式的配置信息对象，或者通过 <code>--config</code> 选项来指定配置文件</p></blockquote> <ul><li><p>现在开始配置<code>webpack</code>，目标是把这两个<code>js</code>文件合并成一个文件. 我们可以自己在<code>build</code>文件夹里面手动建一个<code>index.html</code>文件夹，然后再把合并以后的<code>js</code>引用在里面，但是这样有些麻烦，所以我们这里安装一个<code>plugin</code>，可以自动快速的帮我们生成<code>HTML</code></p></li> <li><p>创建一个配置文件 <code>webpack.config.js</code></p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>var webpack = require('webpack')
module.exports = {
entry: './entry.js',
output: {
path: __dirname,
filename: 'bundle.js'
},
module: {
loaders: [
{test: /\.css$/, loader: 'style!css'}
]
}
}
</code></pre></div><ul><li>同时简化 <code>entry.js</code> 中的 <code>style.css</code> 加载方式</li> <li><code>require('./style.css')</code></li> <li>最后运行 <code>webpack</code> ，可以看到 <code>webpack</code> 通过配置文件执行的结果和通过命令行<code>webpack entry.js bundle.js --module-bind 'css=style!css'</code>执行的结果是一样的</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install html-webpack-plugin --save-dev
</code></pre></div><ul><li>有了这个插件 开始写<code>config</code>文件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var path = require('path');
var HtmlwebpackPlugin = require('html-webpack-plugin');
//定义了一些文件夹的路径
var ROOT_PATH = path.resolve(__dirname);
var APP_PATH = path.resolve(ROOT_PATH, 'app');
var BUILD_PATH = path.resolve(ROOT_PATH, 'build');
module.exports = {
//项目的文件夹 可以直接用文件夹名称 默认会找index.js 也可以确定是哪个文件名字
entry: APP_PATH,
//输出的文件名 合并以后的js会命名为bundle.js
output: {
path: BUILD_PATH,
filename: 'bundle.js'
},
//添加我们的插件 会自动生成一个html文件
plugins: [
new HtmlwebpackPlugin({
title: 'Hello World app'
})
]
};
</code></pre></div><ul><li>然后在项目根目录运行</li></ul> <div class="language- extra-class"><pre class="language-text"><code>webpack
</code></pre></div><ul><li>你会发现多出来一个build文件夹，直接点开里面的html文件，你会发现我们可爱的<code>“hello world”</code>已经插入到页面了。我们的任务完成了，成功生成<code>html</code>，合并<code>js</code>，<code>html</code>引入了<code>js</code>，<code>js</code>被执行了</li></ul> <h3 id="_4-1-配置webpack-dev-server"><a href="#_4-1-配置webpack-dev-server" class="header-anchor">#</a> 4.1 配置webpack-dev-server</h3> <hr> <ul><li><p>上面任务虽然完成了，但是我们要不断运行程序然后查看页面，所以最好新建一个开发服务器，可以<code>serve</code>我们<code>pack</code>以后的代码，并且当代码更新的时候自动刷新浏览器</p></li> <li><p>安装<code>webpack-dev-server</code></p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install webpack-dev-server --save-dev
</code></pre></div><ul><li>安装完毕后在<code>config</code>中添加配置</li></ul> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {

devServer: {
historyApiFallback: true,
hot: true,
inline: true,
progress: true,
},

}
</code></pre></div><ul><li>然后再<code>package.json</code>里面配置一下运行的命令,<code>npm</code>支持自定义一些命令</li></ul> <div class="language- extra-class"><pre class="language-text"><code>"scripts": {
"start": "webpack-dev-server --hot --inline"
},
</code></pre></div><ul><li><p>在项目根目录下输入<code>npm start</code>,一堆花花绿绿的信息后server已经起来了，在浏览器里面输入<code>http://localhost:8080</code>发现<code>hello world</code>出现了，在<code>js</code>里面随便修改一些输出,然后保存,浏览器自动刷新，新的结果出现了</p></li> <li><p>拓展阅读 如果你的服务器端使用的是<code>express</code>框架，你还可以直接安装<code>express</code>的<code>middleware</code>，<code>webpack</code>配合<code>express</code>，很好用</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install webpack-dev-middleware --save-dev
</code></pre></div><h3 id="_4-2-添加css样式"><a href="#_4-2-添加css样式" class="header-anchor">#</a> 4.2 添加CSS样式</h3> <ul><li><p>现在来添加一些样式，<code>webpack</code>使用<code>loader</code>的方式来处理各种各样的资源，比如说样式文件，我们需要两种<code>loader</code>，<code>css-loader</code>和 <code>style－loader</code>，<code>css-loader</code>会遍历<code>css</code>文件，找到所有的<code>url(...)</code>并且处理。<code>style-loader</code>会把所有的样式插入到你页面的一个<code>style tag</code>中</p></li> <li><p>安装我们的<code>loader</code></p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install css-loader style-loader --save-dev
</code></pre></div><ul><li>配置<code>loader</code>，在<code>webpack.config.js</code>中</li></ul> <div class="language- extra-class"><pre class="language-text"><code>devServer: {
historyApiFallback: true,
hot: true,
inline: true,
progress: true,
},
...
module: {
loaders: [
{
test: /\.css$/,
loaders: ['style', 'css'],
include: APP_PATH
}
]
},
...
plugins: [
new HtmlwebpackPlugin({
title: 'Hello World app'
</code></pre></div><ul><li><p>看<code>loaders</code>的书写方式，test里面包含一个正则，包含需要匹配的文件，<code>loaders</code>是一个数组，包含要处理这些程序的<code>loaders</code>，这里我们用了<code>css</code>和<code>style</code>，注意<code>loaders</code>的处理顺序是从右到左的，这里就是先运行<code>css-loader</code>然后是<code>style-loader</code></p></li> <li><p>新建一个样式文件 <code>main.css</code></p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>h1 {
color: red;
}
</code></pre></div><ul><li>记得在入口文件<code>index.js</code>中引用</li></ul> <div class="language- extra-class"><pre class="language-text"><code>require('./main.css');
</code></pre></div><ul><li><p>然后发现标题变成红色的了，<code>webpack</code>的理念是基于项目处理的，把对应的文件格式给对应的<code>loader</code>处理，然后你就不用管了，它会决定怎么压缩，编译</p></li> <li><p>那现在想使用一些有爱的<code>css</code>预编译程序，来点<code>sass</code>吧。 你可能已经想到了，再来个loader就行啦，确实是
这样简单</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install sass-loader --save-dev
</code></pre></div><ul><li>稍微修改一下<code>config</code>，删掉我们先前添加的<code>css</code>规则，加上下面的<code>loader</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>{
test: /\.scss$/,
loaders: ['style', 'css', 'sass'],
include: APP_PATH
},
</code></pre></div><ul><li>添加两个<code>sass</code>文件，<code>variables.scss</code>和<code>main.scss</code></li></ul> <p><code>variables.scss</code></p> <div class="language- extra-class"><pre class="language-text"><code>$red: red;
</code></pre></div><p><code>main.scss</code></p> <div class="language- extra-class"><pre class="language-text"><code>@import "./variables.scss";
h1 {
color: $red;
}
</code></pre></div><p>在<code>index.js</code>中引用</p> <div class="language- extra-class"><pre class="language-text"><code>require('./main.scss');
</code></pre></div><ul><li>然后发现标题如愿变红</li></ul> <h3 id="_4-3-处理图片和其他静态文件"><a href="#_4-3-处理图片和其他静态文件" class="header-anchor">#</a> 4.3 处理图片和其他静态文件</h3> <hr> <ul><li><p>这个和其他一样，也许你也已经会玩了。安装<code>loader</code>，处理文件。诸如图片，字体等等，不过有个神奇的地方它可以根据你的需求将一些图片自动转成<code>base64</code>编码的，为你减轻很多的网络请求</p></li> <li><p>安装<code>url-loader</code></p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install url-loader --save-dev
</code></pre></div><ul><li>配置<code>config</code>文件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{
test: /\.(png|jpg)$/,
loader: 'url?limit=40000'
}
</code></pre></div><ul><li>注意后面那个limit的参数，当你图片大小小于这个限制的时候，会自动启用base64编码图片</li></ul> <p>新建一个<code>imgs</code>文件夹，往里面添加一张照片。在<code>scss</code>文件中添加如下的东西</p> <div class="language- extra-class"><pre class="language-text"><code>@import "./variables.scss";
h1 {
color: $red;
background: url('./imgs/avatar.jpg');
}
</code></pre></div><ul><li>npm start, 然后查看图片的url</li></ul> <h3 id="_4-4-添加第三方库"><a href="#_4-4-添加第三方库" class="header-anchor">#</a> 4.4 添加第三方库</h3> <hr> <ul><li>有的时候还想来点<code>jquery</code>，<code>moment</code>，<code>undersocre</code>之类的库<code>webpack</code>可以非常容易的做到这一点</li> <li>那么我们现在安装在我们的<code>app</code>中添加<code>jquery</code>和<code>moment</code>的支持</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install jquery moment --save-dev
</code></pre></div><ul><li>在js中引用</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var sub = require('./sub');
var $ = require('jquery');
var moment = require('moment');
var app = document.createElement('div');
app.innerHTML = '&lt;h1&gt;Hello World it&lt;/h1&gt;';
document.body.appendChild(app);
app.appendChild(sub());
$('body').append('&lt;p&gt;look at me! now is ' + moment().format() + '&lt;/p&gt;');
</code></pre></div><ul><li>看看浏览器，成功！ <code>jquery</code>和<code>moment</code>现在都起作用了</li></ul> <h3 id="_4-5-添加es6的支持"><a href="#_4-5-添加es6的支持" class="header-anchor">#</a> 4.5 添加ES6的支持</h3> <hr> <ul><li>首先 装各种<code>loader</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install babel-loader babel-preset-es2015 --save-dev
</code></pre></div><ul><li>配置我们的<code>config</code>文件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{
test: /\.jsx?$/,
loader: 'babel',
include: APP_PATH,
query: {
presets: ['es2015']
}
},
</code></pre></div><ul><li><p><code>es2015</code>这个参数是<code>babel</code>的<code>plugin</code>，可以支持各种最新的<code>es6</code>的特性，具体的情况看这个链接</p></li> <li><p>现在我们可以改掉<code>CommonJS</code>风格的文件了</p></li></ul> <p><code>sub.js</code></p> <div class="language- extra-class"><pre class="language-text"><code>export default function() {
  var element = document.createElement('h2');
  element.innerHTML = "Hello h2 world hahaha";
  return element;
}
</code></pre></div><p><code>index.js</code></p> <div class="language- extra-class"><pre class="language-text"><code>import './main.scss';
import generateText from './sub';
import $ from 'jquery';
import moment from 'moment';
let app = document.createElement('div');
const myPromise = Promise.resolve(42);
myPromise.then((number) =&gt; {
$('body').append('&lt;p&gt;promise result is ' + number + ' now is ' + moment().format() + '&lt;/p&gt;');
});
app.innerHTML = '&lt;h1&gt;Hello World it&lt;/h1&gt;';
document.body.appendChild(app);
app.appendChild(generateText());
</code></pre></div><ul><li>我们上面测试了<code>import</code>,<code>export</code>，<code>const</code>，<code>let</code>，<code>promise</code>等一系列<code>es6</code>的特性</li></ul> <h2 id="五、插件"><a href="#五、插件" class="header-anchor">#</a> 五、插件</h2> <hr> <blockquote><ul><li>插件可以完成更多 <code>loader</code> 不能完成的功能</li></ul></blockquote> <ul><li>插件的使用一般是在 <code>webpack</code> 的配置信息 <code>plugins</code> 选项中指定</li> <li><code>Webpack</code> 本身内置了一些常用的插件，还可以通过 <code>npm</code> 安装第三方插件</li> <li>接下来，我们利用一个最简单的 <code>BannerPlugin</code> 内置插件来实践插件的配置和运行，这个插件的作用是给输出的文件头部添加注释信息</li></ul> <p>修改 <code>webpack.config.js</code>，添加 <code>plugins</code></p> <div class="language- extra-class"><pre class="language-text"><code>var webpack = require('webpack')
module.exports = {
entry: './entry.js',
output: {
path: __dirname,
filename: 'bundle.js'
},
module: {
loaders: [
{test: /\.css$/, loader: 'style!css'}
]
},
plugins: [
new webpack.BannerPlugin('This file is created by zhaoda')
]
}
</code></pre></div><ul><li>然后运行 <code>webpack</code> ，打开 <code>bundle.js</code> ，可以看到文件头部出现了我们指定的注释信息</li></ul> <div class="language- extra-class"><pre class="language-text"><code>/*! This file is created by zhaoda */
/******/ (function(modules) { // webpackBootstrap
/******/ // The module cache
/******/ var installedModules = {};
// 后面代码省略
</code></pre></div><h2 id="六、开发环境"><a href="#六、开发环境" class="header-anchor">#</a> 六、开发环境</h2> <hr> <ul><li>当项目逐渐变大，<code>webpack</code> 的编译时间会变长，可以通过参数让编译的输出内容带有进度和颜色</li></ul> <div class="language- extra-class"><pre class="language-text"><code>$ webpack --progress --colors
</code></pre></div><ul><li>如果不想每次修改模块后都重新编译，那么可以启动监听模式。开启监听模式后，没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译，所以监听模式的整体速度是很快的</li></ul> <div class="language- extra-class"><pre class="language-text"><code>$ webpack --progress --colors --watch
</code></pre></div><blockquote><p>当然，使用 <code>webpack-dev-server</code>开发服务是一个更好的选择。它将在 localhost:8080 启动一个 <code>express</code> 静态资源 <code>web</code>服务器，并且会以监听模式自动运行 webpack，在浏览器打开<code>http://localhost:8080/</code>或 <code>http://localhost:8080/webpack-dev-server/</code> 可以浏览项目中的页面和
编译后的资源输出，并且通过一个 <code>socket.io</code> 服务实时监听它们的变化并自动刷新页面</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code># 安装
$ npm install webpack-dev-server -g
# 运行
$ webpack-dev-server --progress --colors
</code></pre></div><h2 id="七、故障处理"><a href="#七、故障处理" class="header-anchor">#</a> 七、故障处理</h2> <hr> <ul><li><code>Webpack</code> 的配置比较复杂，很容出现错误，下面是一些通常的故障处理手段</li> <li>一般情况下，<code>webpack</code>如果出问题，会打印一些简单的错误信息，比如模块没有找到。我们还可以通过参数 <code>--display-error-details</code>来打印错误详情</li></ul> <div class="language- extra-class"><pre class="language-text"><code>$ webpack --display-error-details
Hash: a40fbc6d852c51fceadb
Version: webpack 1.12.2
Time: 586ms
Asset Size Chunks Chunk Names
bundle.js 12.1 kB 0 [emitted] main
[0] ./entry.js 153 bytes {0} [built] [1 error]
[5] ./module.js 43 bytes {0} [built]
+ 4 hidden modules
ERROR in ./entry.js
Module not found: Error: Cannot resolve 'file' or 'directory' ./badpathmodule in /Users/zhaoda/data/projects/webpack-handbook/examples
resolve file
/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule doesn't exist
/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.webpack.js doesn't exist
/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.js doesn't exist
/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.web.js doesn't exist
/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.json doesn't exist
resolve directory
/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule doesn't exist (directory default file)
/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule/package.json doesn't exist (directory description file)
[/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule]
[/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.webpack.js]
[/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.js]
[/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.web.js]
[/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.json]
@ ./entry.js 3:0-26
</code></pre></div><ul><li><code>Webpack</code>的配置提供了 <code>resolve</code> 和<code>resolveLoader</code> 参数来设置模块解析的处理细节， <code>resolve</code>用来配置应用层的模块（要被打包的模块）解析， <code>resolveLoader</code>用来配置<code>loader</code>模块的解析</li> <li>当引入通过 <code>npm</code> 安装的 <code>node.js</code> 模块时，可能出现找不到依赖的错误。<code>Node.js</code>模块的依赖解析算法很简单，是通过查看模块的每一层父目录中的 <code>node_modules</code> 文件夹来查询依赖的。当出现 <code>Node.js</code>模块依赖查找失败的时候，可以尝试设置 <code>resolve.fallback</code>和<code>resolveLoader.fallback</code> 来解决问题</li></ul> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
resolve: { fallback: path.join(__dirname, "node_modules") },
resolveLoader: { fallback: path.join(__dirname, "node_modules") }
};
</code></pre></div><blockquote><p><code>Webpack</code>中涉及路径配置最好使用绝对路径，建议通过 <code>path.resolve(__dirname,"app/folder")</code> 或 <code>path.join(__dirname, "app", "folder")</code>的方式来配置，以兼容 <code>Windows</code>环境</p></blockquote> <h2 id="八、开发和部署技巧"><a href="#八、开发和部署技巧" class="header-anchor">#</a> 八、开发和部署技巧</h2> <hr> <h3 id="_8-1-启用source-map"><a href="#_8-1-启用source-map" class="header-anchor">#</a> 8.1 启用source-map</h3> <hr> <ul><li>现在的代码是合并以后的代码，不利于排错和定位，只需要在config中添加</li></ul> <div class="language- extra-class"><pre class="language-text"><code>devtool: 'eval-source-map',
</code></pre></div><ul><li>这样出错以后就会采用source-map的形式直接显示你出错代码的位置</li></ul> <h3 id="_8-2-使用preloaders和postloaders"><a href="#_8-2-使用preloaders和postloaders" class="header-anchor">#</a> 8.2 使用preLoaders和postLoaders</h3> <hr> <ul><li><p>也许你想在写代码的时候检查自己的<code>js</code>是否符合<code>jshint</code>的规范，那么隆重推荐<code>preLoaders</code>和<code>postLoaders</code></p></li> <li><p><code>perLoaders</code>顾名思义就是在<code>loaders</code>执行之前处理的，<code>webpack</code>的处理顺序是<code>perLoaders - loaders - postLoaders</code></p></li> <li><p>安装<code>jshint</code></p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install jshint-loader --save-dev
</code></pre></div><ul><li>在<code>config</code>文件中配置</li></ul> <div class="language- extra-class"><pre class="language-text"><code>module: {
...
//和loaders一样的语法，很简单
perLoaders: [
{
test: /\.jsx?$/,
include: APP_PATH,
loader: 'jshint-loader'
}
]
}
...
//配置jshint的选项，支持es6的校验
jshint: {
"esnext": true
},
</code></pre></div><ul><li>好了 现在每次npm run start的时候就可以看到jshint的提示信息啦</li></ul> <h3 id="_8-3-部署上线"><a href="#_8-3-部署上线" class="header-anchor">#</a> 8.3 部署上线</h3> <hr> <ul><li><p>刚才说的各种情况都是在开发时候的情况，那么假如项目已经开发完了，需要部署上线了。我们应该新创建一个单独的<code>config</code>文件，因为部署上线使用<code>webpack</code>的时候我们不需要一些<code>dev-tools</code>,<code>dev-server</code>和<code>jshint</code>校验等</p></li> <li><p>复制我们现有的<code>config</code>文件，命名<code>webpack.production.config.js</code>，将里面关于 <code>devServer</code>等和开发有关的东西删掉</p></li> <li><p>在<code>package.json</code>中添加一个命令</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>"scripts": {
"start": "webpack-dev-server --hot --inline",
"build": "webpack --progress --profile --colors --config webpack.production.config.js"
},
</code></pre></div><ul><li>当要上线的时候,运行</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm run build
</code></pre></div><ul><li>可以发现<code>build</code>文件夹中生成了所有东西</li></ul></div> <!----> <div class="readMore-wrapper"><span class="readMore">阅读全文</span></div>
                    </div>
                            <p>这是一个信息提示框。</p>
                        </div>

                        <div class="note warning">
                            <div class="note-title"><i class="fas fa-exclamation-triangle"></i> 注意</div>
                            <p>这是一个警告提示框。</p>
                        </div>

                        <div class="note success">
                            <div class="note-title"><i class="fas fa-check-circle"></i> 成功</div>
                            <p>这是一个成功提示框。</p>
                        </div>

                        <h2>代码示例</h2>
                        <pre><code class="language-javascript">// 示例代码
function example() {
    console.log('Hello, FrontendHub!');
}
</code></pre>
                    </div>

                    <!-- 文章底部导航 -->
                    <nav class="article-nav">
                        <a href="#" class="prev-article">
                            <i class="fas fa-chevron-left"></i>
                            <span>上一篇</span>
                        </a>
                        <a href="#" class="next-article">
                            <span>下一篇</span>
                            <i class="fas fa-chevron-right"></i>
                        </a>
                    </nav>
                </article>
            </div>
        </div>
    </main>

    <!-- 页脚 -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4><i class="fas fa-code"></i> FrontendHub</h4>
                    <p>专注于前端技术学习与面试准备</p>
                </div>
                <div class="footer-section">
                    <h4>快速链接</h4>
                    <ul>
                        <li><a href="../../index.html">首页</a></li>
                        <li><a href="../index.html#courses">课程体系</a></li>
                        <li><a href="../index.html#resources">学习资源</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 FrontendHub. 用于个人学习使用.</p>
            </div>
        </div>
    </footer>

    <!-- 返回顶部按钮 -->
    <button class="back-to-top" id="backToTop">
        <i class="fas fa-arrow-up"></i>
    </button>

    <script src="../../js/main.js"></script>
    <script src="../../js/content.js"></script>
</body>
</html>

