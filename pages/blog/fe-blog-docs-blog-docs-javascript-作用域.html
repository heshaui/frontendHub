<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>作用域 - FrontendHub</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/content.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body class="content-page">
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="../../index.html" style="color: inherit; text-decoration: none; display: flex; align-items: center; gap: 0.5rem;">
                    <i class="fas fa-code"></i>
                    <span>FrontendHub</span>
                </a>
            </div>
            <button class="nav-toggle" id="navToggle">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-menu" id="navMenu">
                <li><a href="../../index.html">首页</a></li>
                <li><a href="../index.html#features">特色</a></li>
                <li><a href="../index.html#courses">课程</a></li>
                <li><a href="../index.html#resources">资源</a></li>
            </ul>
        </div>
    </nav>

    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <div class="container">
            <a href="../../index.html"><i class="fas fa-home"></i> 首页</a>
            <i class="fas fa-chevron-right"></i>
            <span>作用域</span>
        </div>
    </div>

    <!-- 主要内容区 -->
    <main class="content-main">
        <div class="container">
            <div class="content-layout">
                <!-- 侧边栏目录 -->
                <aside class="sidebar">
                    <div class="sidebar-sticky">
                        <h3><i class="fas fa-list"></i> 目录</h3>
                        <nav class="toc" id="toc">
                            <!-- 目录将通过JavaScript自动生成 -->
                        </nav>
                    </div>
                </aside>

                <!-- 文章内容 -->
                <article class="article">
                    <header class="article-header">
                        <h1>作用域</h1>
                        <div class="article-meta">
                            <span><i class="far fa-calendar"></i> 更新时间：2025-12-23</span>
                            <span><i class="far fa-clock"></i> 阅读时长：约 15 分钟</span>
                        </div>
                    </header>

                    <div class="article-content">
<div class="content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>最近被一道面试题给难住了,其实就是说不清楚为什么是这个答案,有时候可能屏幕前的你,也会有这个疑惑,所以打算来补一补基础-作用域。</p> <p>先上题目:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>	<span class="token keyword">var</span> <span class="token function-variable function">Fn</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">fn2</span> <span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    obj<span class="token punctuation">.</span><span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我的答案认为两个都是打印Function,其实基础扎实的小伙伴估计明白我错哪了。</p> <p>话不多说,开始我们的正题吧🤭</p> <h2 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h2> <h4 id="什么是作用域"><a href="#什么是作用域" class="header-anchor">#</a> 什么是作用域</h4> <ol><li>任何语言都有作用域的概念,那有些语言作用域是动态的,有些语言作用域是静态的,我个人理解JavaScript作用域是静态的,为什么这么说,下面我会说明白的。</li> <li>作用域可以理解成:定义了一组明确的规则,它定义如何在某些位置存储变量,以及如何在稍后找到这些变量。</li></ol> <p>那么,就有人问了,作用域规则在哪里,如何被设置呢？</p> <p>官方给出解释:<a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20%26%20closures/ch1.md" target="_blank" rel="noopener noreferrer">点这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>那么我在这里就不咬文嚼字了,那么我们要探究的就是静态的问题了🤭</p> <h4 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="header-anchor">#</a> 静态作用域与动态作用域</h4> <p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p> <p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p> <p>让我们认真看个例子就能明白之间的区别：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token parameter">fun</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
        <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">show</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>假设JavaScript采用静态作用域，让我们分析下执行过程：</p> <p>执行fn函数,先从fn函数内部查找是否有局部变量x,如果没有,就根据书写的位置,查找上面一层的代码,也就是 value 等于 1,所以结果会打印 1。</p> <p>假设JavaScript采用静态作用域，让我们分析下执行过程：</p> <p>执行 fn函数,依然是从 fn 函数内部查找是否有局部变量 x。如果没有,就从调用函数的作用域,也就是 show函数内部查找 x变量,所以结果会打印 2。</p> <p>实际JavaScript打印的结果就是1,从结果上说明JavaScript是静态作用域。</p> <p>为了更好的理解,通过画一张简单图来理解静态作用域:</p> <p><img src="C:%5CUsers%5CDayDay%5CDesktop%5C%E5%89%8D%E7%AB%AF-%E7%AC%94%E8%AE%B0%5Cimages%5C%E4%BD%9C%E7%94%A8%E5%9F%9F1.png" alt=""></p> <p>这样子就很好理解这个关系了,Fn函数在自己的作用域中找变量x,根据变量查找规则,如果没有的话,会去上一级的作用域查找,也就是全局作用域,看是否存在变量x,有的话就取这个值,没有的话就返回undefined。</p> <p>**一旦找到第一个匹配,作用域查询就停止了。**相同的标识符名称可以在嵌套作用域的多个层中被指定，这称为“遮蔽（shadowing）”（内部的标识符“遮蔽”了外部的标识符）。</p> <p>上述这个查询的过程,叫做作用域查询,它总是从当前被执行的最内侧的作用域开始,向外/向上不断查找,直到第一个匹配才停止。</p> <h4 id="作用域分类"><a href="#作用域分类" class="header-anchor">#</a> 作用域分类</h4> <h5 id="全局作用域"><a href="#全局作用域" class="header-anchor">#</a> 全局作用域</h5> <p>在代码任何地方都能访问到的对象拥有全局作用域,更深入的了解可以结合<strong>全局执行上下文</strong>。比如: JavaScript的全局对象 函数 变量都能在全局访问到。</p> <h5 id="_3种情形会拥有全局作用域"><a href="#_3种情形会拥有全局作用域" class="header-anchor">#</a> 3种情形会拥有全局作用域</h5> <h6 id="最外层函数以及最外层定义的变量属于全局作用域"><a href="#最外层函数以及最外层定义的变量属于全局作用域" class="header-anchor">#</a> 最外层函数以及最外层定义的变量属于全局作用域</h6> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> demo <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">//全局变量</span>
        <span class="token keyword">let</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">alert</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span>
            <span class="token keyword">let</span> <span class="token function-variable function">inner</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">alert</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
        <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//1 </span>
        <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//ReferenceError</span>
</code></pre></div><h6 id="在任何位置不使用var声明的变量属于全局作用域"><a href="#在任何位置不使用var声明的变量属于全局作用域" class="header-anchor">#</a> 在任何位置不使用var声明的变量属于全局作用域</h6> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> demo <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">//全局变量</span>
        <span class="token keyword">let</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            demo1 <span class="token operator">=</span> <span class="token string">'未使用var定义'</span>
            <span class="token function">alert</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span>
            <span class="token keyword">let</span> <span class="token function-variable function">inner</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">alert</span><span class="token punctuation">(</span>demo1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//1 </span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>demo1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//未使用var定义</span>
</code></pre></div><h6 id="所以window对象的属性属于全局作用域"><a href="#所以window对象的属性属于全局作用域" class="header-anchor">#</a> 所以window对象的属性属于全局作用域</h6> <h5 id="局部作用域-函数作用域"><a href="#局部作用域-函数作用域" class="header-anchor">#</a> 局部作用域/函数作用域</h5> <p>和全局作用域相反，<strong>函数作用域一般只在函数的代码片段内可访问到</strong>，外部不能进行变量访问。在函数内部定义的变量存在于函数作用域中，其生命周期随着函数的执行结束而结束。例如:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">'李四'</span>
        <span class="token keyword">let</span>  <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'张三'</span><span class="token punctuation">;</span>
            <span class="token function">alert</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//张三</span>
        <span class="token punctuation">}</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//李四</span>
</code></pre></div><h5 id="块级作用域"><a href="#块级作用域" class="header-anchor">#</a> 块级作用域</h5> <p>在ES6中提出块级作用域概念,它的用途就是:变量的声明应该距离使用的地方越近越好。并最大限度的本地化。避免污染。</p> <p>块作用域由 { } 包括,let const可以形成块级作用域,也就是俗称的暂时性死区。具体的在这里就不详细的介绍了,感兴趣的可以了解下之前的文章-<a href="https://juejin.im/post/5ef3523ae51d45348837fb9d" target="_blank" rel="noopener noreferrer">JavaScript执行上下文-执行栈<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这里面讲了为什么let const 会存在暂时性死区,原理是什么？</p> <h5 id="动态作用域"><a href="#动态作用域" class="header-anchor">#</a> 动态作用域</h5> <p>与词法作用域不同于在定义时确定，<strong>动态作用域在执行时确定，其生存周期到代码片段执行为止</strong>。动态变量存在于动态作用域中，任何给定的绑定的值，在确定调用其函数之前，都是不可知的。</p> <p>从某种程度上来说,这会修改作用域,（也就是欺骗）词法作用域。在你的代码中建议不要使用它们,这是因为在某些方面: <strong>欺骗词法作用域会导致更低下的性能。</strong></p> <h6 id="eval"><a href="#eval" class="header-anchor">#</a> eval</h6> <p>JavaScript中的<code>eval(..)</code>函数接收一个字符串作为参数值，并将这个字符串的内容看作是好像它已经被实际编写在程序的那个位置上。</p> <p>在<code>eval(..)</code>被执行的后续代码行中，<em>引擎</em> 将不会“知道”或“关心”前面的代码是被动态翻译的，而且因此修改了词法作用域环境。<em>引擎</em> 将会像它一直做的那样，简单地进行词法作用域查询。</p> <p>考虑下面代码:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">function</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token parameter">str<span class="token punctuation">,</span> a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">eval</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 欺骗词法作用域</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">demo</span><span class="token punctuation">(</span><span class="token string">"var b = 12;"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1, 12</span>
</code></pre></div><p>在<code>eval(..)</code>调用的位置上，字符串<code>"var b = 12"</code>被看作是一直就存在第2行的代码。因为这个代码恰巧声明了一个新的变量<code>b</code>，它就修改了现存的<code>demo(..)</code>的词法作用域。事实上，就像上面提到的那样，这个代码实际上在<code>demo(..)</code>内部创建了变量<code>b</code>，它遮蔽了声明在外部（全局）作用域中的<code>b</code>。</p> <p>当<code>console.log(..)</code>调用发生时，它会在<code>demo(..)</code>的作用域中找到<code>a</code>和<code>b</code>，而且绝不会找到外部的<code>b</code>。这样，我们就打印出"1, 12"而不是一般情况下的"1, 2"。</p> <p><strong>假设</strong>:<code>eval(..)</code>执行的代码字符串包含一个或多个声明（变量或函数）的话，这个动作就会修改这个<code>eval(..)</code>所在的词法作用域。技术上讲，<code>eval(..)</code>可以通过种种技巧（超出了我们这里的讨论范围）被“间接”调用，而使它在全局作用域的上下文中执行，如此修改全局作用域。但不论那种情况，<code>eval(..)</code>都可以在运行时修改一个编写时的词法作用域。</p> <p><strong>注意：</strong> 当<code>eval(..)</code>被用于一个操作它自己的词法作用域的strict模式程序时，在<code>eval(..)</code>内部做出的声明不会实际上修改包围它的作用域。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">function</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token parameter">str<span class="token punctuation">,</span> a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token string">'use strict'</span>
            <span class="token function">eval</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 欺骗词法作用域不生效</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">demo</span><span class="token punctuation">(</span><span class="token string">"var b = 12;"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1, 2</span>
</code></pre></div><p>在JavaScript中还有其他的工具拥有与<code>eval(..)</code>非常类似的效果。<code>setTimeout(..)</code>和<code>setInterval(..)</code><em>可以</em> 为它们各自的第一个参数值接收一个字符串，其内容将会被<code>eval</code>为一个动态生成的函数的代码。这种老旧的，遗产行为早就被废弃了。别这么做！</p> <p><code>new Function(..)</code>函数构造器类似地为它的 <strong>最后</strong> 一个参数值接收一个代码字符串，来把它转换为一个动态生成的函数（前面的参数值，如果有的话，将作为新函数的命名参数）。这种函数构造器语法要比<code>eval(..)</code>稍稍安全一些，但在你的代码中它仍然应当被避免。</p> <p>在你的代码中动态生成代码的用例少的不可思议，因为在性能上的倒退使得这种能力几乎总是得不偿失。</p> <h6 id="with"><a href="#with" class="header-anchor">#</a> with</h6> <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with" target="_blank" rel="noopener noreferrer">MDN最新规范<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>不建议使用,所以接下来<strong>我们了解下with语句</strong>就行。</p> <p><code>with</code>语句接收一个对象，这个对象有0个或多个属性，并 <strong>将这个对象视为好像它是一个完全隔离的词法作用域</strong>，因此这个对象的属性被视为在这个“作用域”中词法定义的标识符。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">with</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">3</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">3</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">foo</span><span class="token punctuation">(</span> o1 <span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> o1<span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>

<span class="token function">foo</span><span class="token punctuation">(</span> o2 <span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> o2<span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 -- 哦，全局作用域被泄漏了！</span>
</code></pre></div><p>在这个代码示例中，创建了两个对象<code>o1</code>和<code>o2</code>。一个有<code>a</code>属性，而另一个没有。<code>foo(..)</code>函数接收一个对象引用<code>obj</code>作为参数值，并在这个引用上调用<code>with (obj) {..}</code>。在<code>with</code>块儿内部，我们制造了一个变量<code>a</code>的看似是普通词法引用的东西，并将值<code>2</code>赋予它。</p> <p>当我们传入<code>o1</code>时，赋值<code>a = 2</code>找到属性<code>o1.a</code>并赋予它值<code>2</code>，正如在后续的<code>console.log(o1.a)</code>语句反应的那样。然而，当我们传入<code>o2</code>，因为它没有<code>a</code>属性，没有这样的属性被创建，所以<code>o2.a</code>还是<code>undefined</code>。</p> <p>但是之后我们注意到一个特别的副作用，赋值<code>a = 2</code>创建了一个全局变量<code>a</code>。这怎么可能？</p> <p><strong>注意：</strong> 尽管一个<code>with</code>块儿将一个对象视为一个词法作用域，但是在<code>with</code>块儿内部的一个普通<code>var</code>声明将不会归于这个<code>with</code>块儿的作用域，而是归于包含它的函数作用域。</p> <p><code>with</code>语句实际上是从你传递给它的对象中凭空制造了一个 <strong>全新的词法作用域</strong>。</p> <p>以这种方式理解的话，当我们传入<code>o1</code>时<code>with</code>语句声明的“作用域”就是<code>o1</code>，而且这个“作用域”拥有一个对应于<code>o1.a</code>属性的“标识符”。但当我们使用<code>o2</code>作为“作用域”时，它里面没有这样的<code>a</code>“标识符”，于是就会出现undefined</p> <p>“作用域”<code>o2</code>中没有，<code>foo(..)</code>的作用域中也没有，甚至连全局作作用域中都没有找到标识符<code>a</code>，所以当<code>a = 2</code>被执行时，其结果就是自动全局变量被创建（因为我们没有在strict模式下）。</p> <p><code>with</code>在运行时将一个对象和它的属性转换为一个带有“标识符”的“作用域”，这个奇怪想法有些烧脑。但是对于我们看到的结果来说，这是我能给出的最清晰的解释。</p> <h6 id="性能"><a href="#性能" class="header-anchor">#</a> 性能</h6> <p>通过在运行时修改，或创建新的词法作用域，<code>eval(..)</code>和<code>with</code>都可以欺骗编写时定义的词法作用域。</p> <p>JavaScript <em>引擎</em> 在编译阶段期行许多性能优化工作。其中的一些优化原理都归结为实质上在进行词法分析时可以静态地分析代码，并提前决定所有的变量和函数声明都在什么位置，这样在执行期间就可以少花些力气来解析标识符。</p> <p>但如果 <em>引擎</em> 在代码中找到一个<code>eval(..)</code>或<code>with</code>，它实质上就不得不 <em>假定</em> 自己知道的所有的标识符的位置可能是不合法的，因为它不可能在词法分析时就知道你将会向<code>eval(..)</code>传递什么样的代码来修改词法作用域，或者你可能会向<code>with</code>传递的对象有什么样的内容来创建一个新的将被查询的词法作用域。</p> <p>换句话说，悲观地看，如果<code>eval(..)</code>或<code>with</code>出现，那么它 <em>将</em> 做的几乎所有的优化都会变得没有意义，所以它就会简单地根本不做任何优化。</p> <p>你的代码几乎肯定会趋于运行的更慢，只因为你在代码的任何地方引入了一个了<code>eval(..)</code>或<code>with</code>。无论 <em>引擎</em> 将在努力限制这些悲观臆测的副作用上表现得多么聪明，<strong>都没有任何办法可以绕过这个事实：没有优化，代码就运行的更慢。</strong></p> <h2 id="结论"><a href="#结论" class="header-anchor">#</a> 结论</h2> <ul><li>作用域是一组规则，它决定了一个变量（标识符）在哪里和如何被查找。</li> <li>作用域是由编写时函数被声明的位置的决策定义的,并不是说函数在哪里执行,哪里就开始生成作用域,这点理解很重要,这也时区分静态作用域和动态作用域区别的一个方法。</li> <li>查找一个变量时,都从当前执行中的 <em>作用域</em> 开始，如果有需要（也就是，它们在这里没能找到它们要找的东西），它们会在嵌套的 <em>作用域</em> 中一路向上，一次一个作用域（层）地查找这个标识符，直到它们到达全局作用域（顶层）并停止，既可能找到也可能没找到。</li> <li>eval(…) 和 with 都可以 '欺骗' 词法作用域,前者可以通过对一个拥有一个或多个声明的“代码”字符串进行求值，来（在运行时）修改现存的词法作用域。后者实质上是通过将一个对象引用看作一个“作用域”，并将这个对象的属性看作作用域中的标识符，（同样，也是在运行时）创建一个全新的词法作用域。</li> <li>以上两种机制的缺点也很明显,它们压制了引擎在作用域查询上进行编译期优化的能力,因为引擎不得不悲观的假定这样子的优化不合理,这两种机制会使代码运行的更慢!!! <strong>建议不使用它们</strong></li></ul></div> <!----> <div class="readMore-wrapper"><span class="readMore">阅读全文</span></div>
                    </div>
                            <p>这是一个信息提示框。</p>
                        </div>

                        <div class="note warning">
                            <div class="note-title"><i class="fas fa-exclamation-triangle"></i> 注意</div>
                            <p>这是一个警告提示框。</p>
                        </div>

                        <div class="note success">
                            <div class="note-title"><i class="fas fa-check-circle"></i> 成功</div>
                            <p>这是一个成功提示框。</p>
                        </div>

                        <h2>代码示例</h2>
                        <pre><code class="language-javascript">// 示例代码
function example() {
    console.log('Hello, FrontendHub!');
}
</code></pre>
                    </div>

                    <!-- 文章底部导航 -->
                    <nav class="article-nav">
                        <a href="#" class="prev-article">
                            <i class="fas fa-chevron-left"></i>
                            <span>上一篇</span>
                        </a>
                        <a href="#" class="next-article">
                            <span>下一篇</span>
                            <i class="fas fa-chevron-right"></i>
                        </a>
                    </nav>
                </article>
            </div>
        </div>
    </main>

    <!-- 页脚 -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4><i class="fas fa-code"></i> FrontendHub</h4>
                    <p>专注于前端技术学习与面试准备</p>
                </div>
                <div class="footer-section">
                    <h4>快速链接</h4>
                    <ul>
                        <li><a href="../../index.html">首页</a></li>
                        <li><a href="../index.html#courses">课程体系</a></li>
                        <li><a href="../index.html#resources">学习资源</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 FrontendHub. 用于个人学习使用.</p>
            </div>
        </div>
    </footer>

    <!-- 返回顶部按钮 -->
    <button class="back-to-top" id="backToTop">
        <i class="fas fa-arrow-up"></i>
    </button>

    <script src="../../js/main.js"></script>
    <script src="../../js/content.js"></script>
</body>
</html>

