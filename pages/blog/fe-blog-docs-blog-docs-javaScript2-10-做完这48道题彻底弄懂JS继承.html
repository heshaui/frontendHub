<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>做完这48道题彻底弄懂JS继承 - FrontendHub</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/content.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body class="content-page">
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="../../index.html" style="color: inherit; text-decoration: none; display: flex; align-items: center; gap: 0.5rem;">
                    <i class="fas fa-code"></i>
                    <span>FrontendHub</span>
                </a>
            </div>
            <button class="nav-toggle" id="navToggle">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-menu" id="navMenu">
                <li><a href="../../index.html">首页</a></li>
                <li><a href="../index.html#features">特色</a></li>
                <li><a href="../index.html#courses">课程</a></li>
                <li><a href="../index.html#resources">资源</a></li>
            </ul>
        </div>
    </nav>

    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <div class="container">
            <a href="../../index.html"><i class="fas fa-home"></i> 首页</a>
            <i class="fas fa-chevron-right"></i>
            <span>做完这48道题彻底弄懂JS继承</span>
        </div>
    </div>

    <!-- 主要内容区 -->
    <main class="content-main">
        <div class="container">
            <div class="content-layout">
                <!-- 侧边栏目录 -->
                <aside class="sidebar">
                    <div class="sidebar-sticky">
                        <h3><i class="fas fa-list"></i> 目录</h3>
                        <nav class="toc" id="toc">
                            <!-- 目录将通过JavaScript自动生成 -->
                        </nav>
                    </div>
                </aside>

                <!-- 文章内容 -->
                <article class="article">
                    <header class="article-header">
                        <h1>做完这48道题彻底弄懂JS继承</h1>
                        <div class="article-meta">
                            <span><i class="far fa-calendar"></i> 更新时间：2025-12-23</span>
                            <span><i class="far fa-clock"></i> 阅读时长：约 15 分钟</span>
                        </div>
                    </header>

                    <div class="article-content">
<div class="content__default"><h2 id="javascript对象封装、多态、继承"><a href="#javascript对象封装、多态、继承" class="header-anchor">#</a> JavaScript对象封装、多态、继承</h2> <h3 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h3> <p><strong>继承就是子类可以使用父类的所有功能，并且对这些功能进行扩展。</strong></p> <p>比如我有个构造函数<code>A</code>，然后又有个构造函数<code>B</code>，但是<code>B</code>想要使用<code>A</code>里的一些属性和方法，一种办法就是让我们自身化身为<code>CV侠</code>，复制粘贴一波。还有一种就是利用继承，我让<code>B</code>直接继承了<code>A</code>里的功能，这样我就能用它了。</p> <p>今天要介绍的八种继承方式在目录中都已经列举出来了。</p> <p>不着急，从浅到深咱一个个来看。</p> <h3 id="_1-原型链继承"><a href="#_1-原型链继承" class="header-anchor">#</a> 1. 原型链继承</h3> <p>将子类的原型对象指向父类的实例</p> <h4 id="_1-1-题目一"><a href="#_1-1-题目一" class="header-anchor">#</a> 1.1 题目一</h4> <p>（理解原型链继承的概念）</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Parent'</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'child'</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
</code></pre></div><p>好了，快告诉我答案吧，会打印出什么 🤔️ ？</p> <div class="language- extra-class"><pre class="language-text"><code>'child'
Child&nbsp;{name: "child"}
</code></pre></div><p>这...这很好理解呀</p> <ul><li><code>child1</code>是通过子类构造函数<code>Child</code>生成的对象，那我就有属性<code>name</code>，并且属性值也是自己的<code>child</code></li> <li>然后子类构造函数<code>Child</code>它的原型被指向了父类构造函数<code>Parent</code>创建出来的<code>"无名实例"</code></li> <li>这样的话，我<code>child1</code>就可以使用你这个<code>"无名实例"</code>里的所有属性和方法了呀，因此<code>child1.getName()</code>有效。并且打印出<code>child</code>。</li> <li>另外由于<code>sex、getName</code>都是<code>Child</code>原型对象上的属性，所以并不会表现在<code>child1</code>上。</li></ul> <p><img src="https://s.poetries.top/gitee/2020/09/181.png" alt=""></p> <p>所以现在你知道了吧，这种方式就叫做<strong>原型链继承</strong>。</p> <p><strong>将子类的原型对象指向父类的实例。</strong></p> <p>我们来写个伪代码，方便记忆：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>当然，更加严谨一点的做法其实还有一步：<code>Child.prototype.constructor = Child</code>，不过这边先卖个关子，到题目<code>4.2</code>中我们再来详细说它。</p> <h4 id="_1-2-题目二"><a href="#_1-2-题目二" class="header-anchor">#</a> 1.2 题目二</h4> <p>不知道你们在看到<strong>原型链继承</strong>这个词语的时候，第一时间想到的是什么？</p> <p>有没有和我一样，想到的是把子类的原型对象指向父类的原型对象的😂：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype
</code></pre></div><p>和我一样的举个手给我看下🙋‍♂️，😂</p> <p>之后我就为我xx似的想法感到惭愧...</p> <p>如果我只能拿到父类原型链上的属性和方法那也太废了吧，我可不止这样，我还想拿到父类构造函数上的属性。</p> <p>所以这道题：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Parent'</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSex</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sex<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'child'</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
</code></pre></div><p>结果为：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">undefined</span>
Child <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"child"</span><span class="token punctuation">}</span>
</code></pre></div><p>你可以结合上面👆的那张图，自个儿脑补一下，<code>child1</code>它的原型链现在长啥样了。</p> <p>解析：</p> <ul><li><code>child1</code>上能使用的属性和方法只有<code>name、getSex</code>，所以<code>getSex</code>打印出的会是<code>undefined</code></li> <li>打印出的<code>child1</code>只有<code>name</code>属性，<code>getSex</code>为原型上的方法所以并不会表现出来。</li></ul> <p>这道题是个错误的做法啊 😂</p> <p>我只是为了说明一下，为什么<strong>原型链继承</strong>是要用<code>Child.prototype = new Parent()</code>这种方式。</p> <h4 id="_1-3-题目三"><a href="#_1-3-题目三" class="header-anchor">#</a> 1.3 题目三</h4> <p>（理解原型链继承的优点和缺点）</p> <p>这道题的结果大家能想到吗？</p> <p>请注意对象是地址引用的哦。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>feature <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'cute'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">'parent'</span><span class="token punctuation">)</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> parent

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'girl'</span>
child1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span>feature<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'sunshine'</span><span class="token punctuation">)</span>

<span class="token keyword">var</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child2'</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
</code></pre></div><p>答案：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Child<span class="token punctuation">{</span> <span class="token literal-property property">feature</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'cute'</span><span class="token punctuation">,</span> <span class="token string">'sunshine'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">'girl'</span> <span class="token punctuation">}</span>
Child<span class="token punctuation">{</span> <span class="token literal-property property">feature</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'cute'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>

<span class="token string">'parent'</span>
<span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">,</span> <span class="token string">'yellow'</span><span class="token punctuation">]</span>

Parent <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"parent"</span><span class="token punctuation">,</span> <span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">'boy'</span><span class="token punctuation">,</span> <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">,</span> <span class="token string">'yellow'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
</code></pre></div><p>解析：</p> <ul><li><code>child1</code>在创建完之后，就设置了<code>sex</code>，并且给<code>colors</code>和<code>feature</code>都<code>push</code>了新的内容。</li> <li><code>child1.sex = 'girl'</code>这段代码相当于是给<code>child1</code>这个实例对象新增了一个<code>sex</code>属性。相当于是：原本我是没有<code>sex</code>这个属性的，我想要获取就得拿原型对象<code>parent</code>上的<code>sex</code>，但是现在你加了一句<code>child1.sex</code>就等于是我自己也有了这个属性了，就不需要你原型上的了，所以并不会影响到原型对象<code>parent</code>上😊。</li> <li>但是<code>child1.colors</code>这里，注意它的操作，它是直接使用了<code>.push()</code>的，也就是说我得先找到<code>colors</code>这个属性，发现实例对象<code>parent</code>上有，然后就拿来用了，之后执行<code>push</code>操作，所以这时候改变的是原型对象<code>parent</code>上的属性，会影响到后续所有的实例对象。(这里你会有疑问了，凭什么<code>sex</code>就是在实例对象<code>child</code>上新增，而我<code>colors</code>不行，那是因为操作的方式不同，<code>sex</code>那里是我不管你有没有，反正我就直接用<code>=</code>来覆盖你了，可是<code>push</code>它的前提是我得先有<code>colors</code>且类型是数组才行，不然你换成没有的属性，比如一个名为<code>clothes</code>的属性，<code>child1.clothes.push('jacket')</code>它直接就报错了，如果你使用的是<code>child1.colors = ['yellow']</code>这样才不会影响<code>parent</code>)</li> <li>而<code>feature</code>它是属于<code>child1</code>实例自身的属性，它添加还是减少都不会影响到其他实例。</li> <li>因此<code>child1</code>打印出了<code>feature</code>和<code>sex</code>两个属性。(<code>name</code>和<code>colors</code>属于原型对象上的属性并不会被表现出来)</li> <li><code>child2</code>没有做任何操作，所以它打印出的还是它自身的一个<code>feature</code>属性😁。</li> <li><code>child1.name</code>是原型对象<code>parent</code>上的<code>name</code>，也就是<code>'parent'</code>，虽然我们在<code>new Child</code>的时候传递了<code>'child1'</code>，但它显然是无效的，因为接收<code>name</code>属性的是构造函数<code>Parent</code>，而不是<code>Child</code>。</li> <li><code>child2.colors</code>由于用的也是原型对象<code>parent</code>上的<code>colors</code>，又由于之前被<code>child1</code>给改变了，所以打印出来的会是<code>['white', 'black', 'yellow']</code></li> <li>将最后的原型对象<code>parent</code>打印出来，<code>name</code>和<code>sex</code>没变，<code>colors</code>却变了。</li></ul> <p>分析的真漂亮，漂亮的这么一大串我都不想看了...</p> <p>咳咳，不过你要是能静下来认真的读一读的话就会觉得真没啥东西，甚至不需要记什么，我就理解了。</p> <h4 id="总结-原型链继承"><a href="#总结-原型链继承" class="header-anchor">#</a> 总结-原型链继承</h4> <p>现在我们就可以得出<strong>原型链继承</strong>它的优点和缺点了</p> <p><strong>优点：</strong></p> <ul><li>继承了父类的模板，又继承了父类的原型对象</li></ul> <p><strong>缺点：</strong></p> <ul><li>如果要给子类的原型上新增属性和方法，就必须放在<code>Child.prototype = new Parent()</code>这样的语句后面</li> <li>无法实现多继承(因为已经指定了原型对象了)</li> <li>来自原型对象的所有属性都被共享了，这样如果不小心修改了原型对象中的引用类型属性，那么所有子类创建的实例对象都会受到影响(这点从修改<code>child1.colors</code>可以看出来)</li> <li>创建子类时，无法向父类构造函数传参数(这点从<code>child1.name</code>可以看出来)</li></ul> <p>这...这看到没，压根就不需要记，想想出的这道变态的题面试的时候被问到脱口就来了。</p> <h3 id="_2-instanceof"><a href="#_2-instanceof" class="header-anchor">#</a> 2. instanceof</h3> <h4 id="_2-1-题目一"><a href="#_2-1-题目一" class="header-anchor">#</a> 2.1 题目一</h4> <p>这道题主要是想介绍一个重要的运算符: <strong>instanceof</strong></p> <p>先看看官方的简介：</p> <p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p> <p>再来看看通俗点的简介：</p> <p><code>a instanceof B</code></p> <p><code>实例对象a instanceof 构造函数B</code></p> <p>检测<code>a</code>的原型链<code>(__proto__)</code>上是否有<code>B.prototype</code>，有则返回<code>true</code>，否则返回<code>false</code>。</p> <p>上题吧：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'parent'</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Child</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span>
</code></pre></div><p>结果为：</p> <div class="language- extra-class"><pre class="language-text"><code>true
true
true
</code></pre></div><p>这里就利用了前面👆提到的原型链继承，而且三个构造函数的原型对象都存在于<code>child1</code>的原型链上。</p> <p>也就是说，左边的<code>child1</code>它会向它的原型链中不停的查找，看有没有右边那个构造函数的原型对象。</p> <p>例如<code>child1 instanceof Child</code>的查找顺序：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>child1 <span class="token operator">-</span><span class="token operator">&gt;</span> child1<span class="token punctuation">.</span>__proto__ <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype
</code></pre></div><p><code>child1 instanceof Parent</code>的查找顺序：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>child1 <span class="token operator">-</span><span class="token operator">&gt;</span> child1<span class="token punctuation">.</span>__proto__ <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype
<span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype
</code></pre></div><p>还不理解？</p> <p>没关系，我还有大招：</p> <p>我在上面👆原型链继承的思维导图上加了三个查找路线。</p> <p>被⭕️标记的<code>1、2、3</code>分别代表的是<code>Child、Parent、Object</code>的原型对象。</p> <p><img src="https://s.poetries.top/gitee/2020/09/182.png" alt=""></p> <p>好滴，一张图简洁明了。以后再碰到<code>instanceof</code>这种东西，按照我图上的查找路线来查找就可以了 😁 ～</p> <h4 id="_2-2-题目二"><a href="#_2-2-题目二" class="header-anchor">#</a> 2.2 题目二</h4> <p>（了解<code>isPrototypeOf()</code>的使用）</p> <p>既然说到了<code>instanceof</code>，那么就不得不提一下<code>isPrototypeOf</code>这个方法了。</p> <p>它属于<code>Object.prototype</code>上的方法，这点你可以将<code>Object.prototype</code>打印在控制台中看看。</p> <p><code>isPrototypeOf()</code>的用法和<code>instanceof</code>相反。</p> <p>它是用来判断指定对象<code>object1</code>是否存在于另一个对象<code>object2</code>的原型链中，是则返回<code>true</code>，否则返回<code>false</code>。</p> <p>例如还是上面👆这道题，我们将要打印的内容改一下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'parent'</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>这里输出的依然是三个<code>true</code>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token boolean">true</span>
<span class="token boolean">true</span>
<span class="token boolean">true</span>
</code></pre></div><p>判断的方式只要把<strong>原型链继承instanceof查找思维导图</strong>这张图反过来查找即可。</p> <h3 id="_3-构造继承"><a href="#_3-构造继承" class="header-anchor">#</a> 3. 构造继承</h3> <p>了解了最简单的<strong>原型链继承</strong>，再让我们来看看<strong>构造继承</strong>呀，也叫做<strong>构造函数继承</strong>。</p> <p>在子类构造函数内部使用<code>call或apply</code>来调用父类构造函数</p> <p>为了方便你查看，我们先来复习一波<code>.call</code>和<code>apply</code>方法。</p> <ul><li><p>通过<code>call()、apply()</code>或者<code>bind()</code>方法直接指定<code>this</code>的绑定对象, 如<code>foo.call(obj)</code></p></li> <li><p>使用<code>.call()</code>或者<code>.apply()</code>的函数是会直接执行的</p></li> <li><p>而<code>bind()</code>是创建一个新的函数，需要手动调用才会执行</p></li> <li><p><code>.call()</code>和<code>.apply()</code>用法基本类似，不过<code>call</code>接收若干个参数，而<code>apply</code>接收的是一个数组</p></li></ul> <h4 id="_3-1-题目一"><a href="#_3-1-题目一" class="header-anchor">#</a> 3.1 题目一</h4> <p>（构造继承的基本原理）</p> <p>所以来看看这道题？</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'child'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
</code></pre></div><p><code>child1</code>中会有哪些属性呢？</p> <p>首先<code>sex</code>我们知道肯定会有的，毕竟它就是构造函数<code>Child</code>里的。</p> <p>其次，我们使用了<code>Parent.call(this, 'child')</code>，<code>.call</code>函数刚刚已经说过了，它是会立即执行的，而这里又用了<code>.call</code>来改变<code>Parent</code>构造函数内的指向，所以我们是不是可以将它转化为伪代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
	<span class="token comment">// 伪代码</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'child'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你就理解为相当于是直接执行了<code>Parent</code>里的代码。使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类。</p> <p>所以构造继承的原理就是：</p> <p><strong>在子类构造函数内部使用<code>call或apply</code>来调用父类构造函数</strong></p> <p>同样的，来写下伪代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>（<code>arguments</code>表示的是你可以往里面传递参数，当然这只是伪代码）</p> <h4 id="_3-2-题目二"><a href="#_3-2-题目二" class="header-anchor">#</a> 3.2 题目二</h4> <p>如果你觉得上面👆这道题还不具有说明性，我们来看看这里。</p> <p>现在我在子类和父类中都加上<code>name</code>这个属性，你觉得生出来的会是<strong>好孩子</strong>还是<strong>坏孩子</strong>呢？</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'good boy'</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'bad boy'</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
</code></pre></div><p>其实是好是坏很好区分，只要想想<code>3.1</code>里，把<code>Parent.call(this, 'good boy')</code>换成伪代码就知道了。</p> <p>换成了伪代码之后，等于是重复定义了两个相同名称的属性，当然是后面的覆盖前面的啦。</p> <p>所以结果为：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Child <span class="token punctuation">{</span><span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">"boy"</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"bad boy"</span><span class="token punctuation">}</span>
</code></pre></div><p>这道题如果换一下位置：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'bad boy'</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'good boy'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这时候就是好孩子了。</p> <h4 id="_3-3-题目三"><a href="#_3-3-题目三" class="header-anchor">#</a> 3.3 题目三</h4> <p>（构造继承的优点）</p> <p>解决了<strong>原型链继承</strong>中子类共享父类引用对象的问题</p> <p>刚刚的题目都是一些基本数据类型，让我来加上引用类型看看</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> sex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> sex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> sex<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">,</span> <span class="token string">'boy'</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">)</span>

<span class="token keyword">var</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child2'</span><span class="token punctuation">,</span> <span class="token string">'girl'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">)</span>
</code></pre></div><p>这道题看着和<code>1.3</code>好像啊，没错，在父类构造函数中有一个叫<code>colors</code>的数组，它是地址引用的。</p> <p>在<strong>原型链继承</strong>中我们知道，子类构造函数创建的实例是会查找到原型链上的<code>colors</code>的，而且改动它会影响到其它的实例，这是<strong>原型链继承</strong>的一大缺点。</p> <p>而现在呢？你看看使用了<strong>构造继承</strong>，结果为：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Child<span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'child1'</span><span class="token punctuation">,</span> <span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">'boy'</span><span class="token punctuation">,</span> <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">,</span> <span class="token string">'yellow'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
Child<span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'child2'</span><span class="token punctuation">,</span> <span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">'girl'</span><span class="token punctuation">,</span> <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
</code></pre></div><p>我们发现修改<code>child1.colors</code>并不会影响到其它的实例(<code>child2</code>)耶。</p> <p>这里的原因其实我们前面也说了：</p> <p>使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类。</p> <p>所以现在<code>child1</code>和<code>child2</code>现在分别有它们各自的<code>colors</code>了，就不共享了。</p> <p>而且这种拷贝属于深拷贝，验证的方式是你可以把<code>colors</code>数组中的每一项改为一个对象，然后修改它看看。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">//...</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'white'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'black'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因此我们可以得出<strong>构造继承</strong>的优点：</p> <ul><li>解决了原型链继承中子类实例共享父类引用对象的问题，实现多继承，创建子类实例时，可以向父类传递参数</li></ul> <h4 id="_3-4-题目四"><a href="#_3-4-题目四" class="header-anchor">#</a> 3.4 题目四</h4> <p>（构造继承的缺点一）</p> <p>在了解继承的时候，我们总是会想到原型链上的属性和方法能不能被继承到。</p> <p>采用了这种<strong>构造继承</strong>的方式，能不能继承父类原型链上的属性呢？</p> <p>来看下面👇这道题目</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'good boy'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSex</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sex<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
child1<span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>我给子类和父类的原型对象上都分别加了一个方法，然后调用它们。</p> <p>结果竟然是：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Child <span class="token punctuation">{</span><span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">"boy"</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"good boy"</span><span class="token punctuation">}</span>
<span class="token string">'boy'</span>
Uncaught TypeError<span class="token operator">:</span> child1<span class="token punctuation">.</span>getName is not a <span class="token keyword">function</span>
</code></pre></div><ul><li><code>sex、name</code>属性都有这个我们都可以理解</li> <li><code>getSex</code>属于<code>Child</code>构造函数原型对象上的方法，我们肯定是能用它的，这个也好理解</li> <li>那<code>getName</code>呢？它属于父类构造函数原型对象上的方法，报错了？怎么滴？我子类不配使用你啊？</li></ul> <p>你确实是不配使用我。</p> <p>你使用<code>Parent.call(this, 'good boy')</code>只不过是让你复制了一下我构造函数里的属性和方法，可没说能让你复制我原型对象的啊～年轻人，不要这么贪嘛。</p> <h4 id="_3-5-题目五"><a href="#_3-5-题目五" class="header-anchor">#</a> 3.5 题目五</h4> <p>（构造继承的缺点二）</p> <p>它的第二个缺点是：实例并不是父类的实例，只是子类的实例。</p> <p>停一下，让我们先来思考一下这句话的意思，然后想想怎样来验证它呢 🤔️ ？</p> <p>一分钟...二分钟...三分钟...</p> <p>啊，我知道了，刚刚不是才学的一个叫<code>instanceof</code>的运算符吗？它就能检测某个实例的原型链上能不能找到构造函数的原型对象。</p> <p>换句话说就能检测某个对象是不是某个构造函数的实例啦。</p> <p>所以让我们来看看：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'child'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Child</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span>
</code></pre></div><p>结果为：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Child <span class="token punctuation">{</span><span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">"boy"</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"child"</span><span class="token punctuation">}</span>
<span class="token boolean">true</span>
<span class="token boolean">false</span>
<span class="token boolean">true</span>
</code></pre></div><ul><li>第一个<code>true</code>很好理解啦，我就是你生的，你不<code>true</code>谁<code>true</code></li> <li>第二个为<code>false</code>其实也很好理解啦，想想刚刚的<code>5.3</code>，我连你父类原型上的方法都不能用，那我和你可能也没有关系啦，我只不过是复制了你函数里的属性和方法而已。</li> <li>第三个<code>true</code>，必然的，实例的原型链如果没有发生改变的话最后都能找到<code>Object.prototype</code>啦。</li></ul> <p>（虽说构造继承出来的实例确实不是父类的实例，只是子类的实例。但我其实是不太明白教材中为什么要说它是一个缺点呢？鄙人愚昧，想的可能是：子类生成的实例既然能用到父类中的属性和方法，那我就应该也要确定这些属性和方法的来源，如果不能使用<code>instanceof</code>检测到你和父类有关系的话，那就会对这些凭空产生的属性和方法有所质疑...）</p> <p>因此<strong>构造继承</strong>第二个缺点是：</p> <ul><li>实例并不是父类的实例，只是子类的实例</li></ul> <h4 id="总结-构造继承"><a href="#总结-构造继承" class="header-anchor">#</a> 总结-构造继承</h4> <p>构造继承总结来说：</p> <p><strong>优点：</strong></p> <ul><li>解决了原型链继承中子类实例共享父类引用对象的问题，实现多继承，创建子类实例时，可以向父类传递参数(见题目<code>3.3</code>)</li></ul> <p><strong>缺点：</strong></p> <ul><li>构造继承<strong>只能</strong>继承父类的实例属性和方法，<strong>不能</strong>继承父类原型的属性和方法(见题目<code>3.4</code>)</li> <li>实例并不是父类的实例，只是子类的实例(见题目<code>3.5</code>)</li> <li><strong>无法实现函数复用</strong>，每个子类都有父类实例函数的副本，影响性能</li></ul> <p>(最后一个缺点‘无法实现函数复用’经过评论区小伙伴<a href="https://juejin.im/user/5c7747976fb9a049ac79d82c" target="_blank" rel="noopener noreferrer">matteokjh<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的提醒，我理解的大概是这个意思：父类构造函数中的某个函数可能只是一个功能型的函数，它不论被复制了多少份，输出的结果或者功能都是一样的，那么这类函数是完全可以拿来复用的。但是现在用了构造函数继承，由于它是复制了父类构造函数中的属性和方法，这样产生的每个子类实例中都会有一份自己各自的方法，可是有的方法完全没有必要复制，可以用来共用的，所以就说不能够「函数复用」。)</p> <h3 id="_4-组合继承"><a href="#_4-组合继承" class="header-anchor">#</a> 4. 组合继承</h3> <p>既然<strong>原型链继承</strong>和<strong>构造继承</strong>都有这么多的缺点，那我们为何不<strong>阴阳结合</strong>，把它们<strong>组合</strong>在一起呢？</p> <p>咦～</p> <p>好像是个好想法。</p> <p>把我们前面的伪代码拿来用用，想想该如何组合呢？</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 原型链继承</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 构造继承</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>...思考中🤔...</p> <p>看到这两段伪代码，我好像有所顿悟了，不就是按照伪代码里写的，把这两种继承组合在一起吗？</p> <p>哇！这都被我猜中了，搜索一下组合继承的概念，果然就是这样。</p> <p><strong>组合继承的概念：</strong></p> <p>组合继承就是将原型链继承与构造函数继承组合在一起，从而发挥两者之长的一种继承模式。</p> <p><strong>思路：</strong></p> <ul><li>使用<strong>原型链继承</strong>来保证子类能继承到父类原型中的属性和方法</li> <li>使用<strong>构造继承</strong>来保证子类能继承到父类的实例属性和方法</li></ul> <p><strong>基操：</strong></p> <ul><li>通过<code>call/apply</code>在子类构造函数内部调用父类构造函数</li> <li>将子类构造函数的原型对象指向父类构造函数创建的一个匿名实例</li> <li>修正子类构造函数原型对象的<code>constructor</code>属性，将它指向子类构造函数</li></ul> <p>基操中的第一点就是<strong>构造继承</strong>，第二点为<strong>原型链继承</strong>，第三点其实只是一个好的惯例，在后面的题目会细讲到它。</p> <h4 id="_4-1-题目一"><a href="#_4-1-题目一" class="header-anchor">#</a> 4.1 题目一</h4> <p>(理解组合继承的基本使用)</p> <p>现在我决定对你们不再仁慈，让我们换种想法，逆向思维来解解题好不好。</p> <p>阴笑～</p> <p>既然我都已经说了这么多关于<strong>组合继承</strong>的东西了，那想必你们也知道该如何设计一个组合继承了。</p> <p>我现在需要你们来实现这么一个<code>Child</code>和<code>Parent</code>构造函数(代码尽可能地少)，让它们代码的执行结果能如下：</p> <p>(请先不要着急看答案哦，花上2分钟来思考一下，弄清每个属性在什么位置上，都有什么公共属性就好办了)</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> parent1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">'parent1'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span> <span class="token comment">// Child{ name: 'child1', sex: 'boy' }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>parent1<span class="token punctuation">)</span><span class="token comment">// Parent{ name: 'parent1' }</span>
child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 'child1'</span>
child1<span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">// 'boy'</span>
parent1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">// 'parent1'</span>
parent1<span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// Uncaught TypeError: parent1.getSex is not a function</span>
</code></pre></div><p>解题思路：</p> <ul><li>首先来看看俩构造函数产生的实例(<code>child1和parent1</code>)上都有<code>name</code>这个属性，所以<code>name</code>属性肯定是在父类的构造函数里定义的啦，而且是通过传递参数进去的。</li> <li>其次，<code>sex</code>属性只有实例<code>child1</code>才有，表明它是子类构造函数上的定义的属性(也就是我们之前提到过的公有属性)</li> <li>再然后<code>child1</code>和<code>parent1</code>都可以调用<code>getName</code>方法，并且都没有表现在实例上，所以它们可能是在<code>Parent.prototype</code>上。</li> <li>而<code>getSex</code>对于<code>child1</code>是可以调用的，对于<code>father1</code>是不可调用的，说明它是在<code>Child.prototype</code>上。</li></ul> <p>好的👌，每个属性各自在什么位置上都已经找到了，再来看看如何实现它吧：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSex</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sex<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> parent1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">'parent1'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>parent1<span class="token punctuation">)</span>
child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
parent1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
parent1<span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>不知道是不是和你构想的一样呢 🤔️？</p> <p>其实这是一道开放式题，如果构想的不一样也是正常了，不过你得自己把自己构想的用代码跑一边看看是不是和需求一样。</p> <p>为什么说它比较开放呢？</p> <p>就比如第一点，<code>name</code>属性，它不一定就只存在于<code>Parent</code>里呀，我<code>Child</code>里也可以有一个自己的<code>name</code>属性，只不过题目要求代码尽可能地少，所以最好的就是存在与<code>Parent</code>中，并且用<code>.call</code>来实现<strong>构造继承</strong>。</p> <p>另外，<code>getName</code>方法也不一定要在<code>Parent.prototype</code>上，它只要存在于<code>parent1</code>的原型链中就可以了，所以也有可能在<code>Object.prototype</code>，脑补一下那张原型链的图，是不是这样呢？</p> <p>这就是<strong>组合继承</strong>带来的魅力，如果你能看懂这道题，就已经掌握其精髓了 👏。</p> <h4 id="_4-2-题目二"><a href="#_4-2-题目二" class="header-anchor">#</a> 4.2 题目二</h4> <p>（理解<code>constructor</code>有什么作用）</p> <p>拿上面👆那道题和最开始我们定义<strong>组合继承</strong>的基操做对比，发现第三点<code>constructor</code>好像并没有提到耶，但是也实现了我们想要的功能，那这样说来<code>constructor</code>好像并没有什么软用呀...</p> <p>你想的没错，就算我们不对它进行任何的设置，它也丝毫不会影响到<code>JS</code>的内部属性。</p> <p>它不过是给我们一个提示，用来标示实例对象是由哪个构造函数创建的。</p> <p>先用一张图来看看<code>constructor</code>它存在的位置吧：</p> <p><img src="https://s.poetries.top/gitee/2020/09/183.png" alt=""></p> <p>可以看到，它实际就是原型对象上的一个属性，指向的是构造函数。</p> <p>所以我们是不是可以有这么一层对应关系：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>guaiguai<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype
<span class="token class-name">Cat</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Cat
guaiguai<span class="token punctuation">.</span><span class="token class-name">__proto__</span><span class="token punctuation">.</span>constructor <span class="token operator">=</span> Cat
</code></pre></div><p>（结合图片来看，这样的三角恋关系俨然并不复杂）</p> <p>再结合题目<code>4.1</code>来看，你觉得以下代码会打印出什么呢？题目其实还是<code>4.1</code>的题目，要求打印的东西不同而已。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSex</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sex<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> parent1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">'parent1'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>parent1<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span>
</code></pre></div><p>一时不知道答案也没关系，我直接公布一下了：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>f <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
f <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>打印出的两个都是<code>Parent</code>函数。</p> <p><code>parent1.constructor</code>是<code>Parent</code>函数这个还好理解，结合上面👆的图片来看，只要通过原型链查找，我<code>parent1</code>实例自身没有<code>constructor</code>属性，那我就拿原型上的<code>constructor</code>，发现它指向的是构造函数<code>Parent</code>，因此第二个打印出<code>Parent</code>函数。</p> <p>而对于<code>child1</code>，想想<strong>组合继承</strong>用到了<strong>原型链继承</strong>，虽然也用到了<strong>构造继承</strong>，但是构造继承对原型链之间的关系没有影响。那么我<strong>组合继承</strong>的原型链关系是不是就可以用<strong>原型链继承</strong>那张关系图来看？</p> <p>如下：</p> <p><img src="https://s.poetries.top/gitee/2020/09/185.png" alt=""></p> <p>就像上面看到的一样，<strong>原型链继承</strong>切断了原本<code>Child</code>和<code>Child</code>原型对象的关系，而是重新指向了匿名实例。使得实例<code>child1</code>能够使用匿名实例原型链上的属性和方法。</p> <p>当我们想要获取<code>child1.constructor</code>，肯定是向上查找，通过<code>__proto__</code>找它构造函数的原型对象<code>匿名实例</code>。</p> <p>但是匿名实例它自身是没有<code>constructor</code>属性的呀，它只是<code>Parent</code>构造函数创建出来的一个对象而已，所以它也会继续向上查找，然后就找到了<code>Parent</code>原型对象上的<code>constructor</code>，也就是<code>Parent</code>了。</p> <p>所以回过头来看看这句话：</p> <p><strong>construcotr它不过是给我们一个提示，用来标示实例对象是由哪个构造函数创建的。</strong></p> <p>从人(常)性(理)的角度上来看，<code>child1</code>是<code>Child</code>构建的，<code>parent1</code>是<code>Parent</code>构建的。</p> <p>那么<code>child1</code>它的<code>constructor</code>就应该是<code>Child</code>呀，但是现在却变成了<code>Parent</code>，貌似并不太符合常理啊。</p> <p>所以才有了这么一句：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child
</code></pre></div><p>用以修复<code>constructor</code>的指向。</p> <p>现在让我们通过改造<code>原型链继承思维导图</code>来画画<code>组合继承的思维导图</code>吧。</p> <p><img src="https://s.poetries.top/gitee/2020/09/185.png" alt=""></p> <p>(至于为什么在<strong>组合继承</strong>中我修复了<code>constructor</code>，在<strong>原型链继承</strong>中没有，这个其实取决于你自己，因为你也看到了<code>constructor</code>实际并没有什么作用，不过面试被问到的话肯定是要知道的)</p> <p>总结来说：</p> <ul><li><code>constructor</code>它是构造函数原型对象中的一个属性，正常情况下它指向的是原型对象。</li> <li>它并不会影响任何<code>JS</code>内部属性，只是用来标示一下某个实例是由哪个构造函数产生的而已。</li> <li>如果我们使用了<strong>原型链继承</strong>或者<strong>组合继承</strong>无意间修改了<code>constructor</code>的指向，那么出于编程习惯，我们最好将它修改为正确的构造函数。</li></ul> <h4 id="_4-3-题目三"><a href="#_4-3-题目三" class="header-anchor">#</a> 4.3 题目三</h4> <p>（<code>constructor</code>的某个使用场景）</p> <p>先来看看下面👇这道题：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a<span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">A</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span>
  <span class="token punctuation">}</span>
  <span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">logA</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

a<span class="token punctuation">.</span><span class="token function">logA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>这里的输出结果：</p> <div class="language- extra-class"><pre class="language-text"><code>1
</code></pre></div><p>乍一看被整片的<code>a</code>给搞糊了，但是仔细分析来，就能得出结果了。</p> <ul><li>定义了一个全局的变量<code>a</code>，和一个构造函数<code>A</code></li> <li>在立即执行函数中，是可以访问到全局变量<code>a</code>的，因此<code>a</code>被赋值为了一个构造函数<code>A</code>生成的对象</li> <li>并且<code>a</code>对象中有两个属性：<code>a</code>和<code>b</code>，且值都是<code>1</code></li> <li>之后在外层调用<code>a.logA()</code>，打印出的就是<code>a.a</code>，也就是<code>1</code></li></ul> <p><strong>难度升级：</strong></p> <p>现在我想要在匿名函数外给<code>A</code>这个构造函数的原型对象中添加一个方法<code>logB</code>用以打印出<code>this.b</code>。</p> <p>你首先想到的是不是<code>B.prototype.logB = funciton() {}</code>。</p> <p>但是注意咯，我是要你在匿名函数外添加，而此时由于作用域的原因，我们在匿名函数外是访问不到<code>A</code>的，所以这样的做法就不可行了。</p> <p><strong>解决办法：</strong></p> <p>虽然我们在外层访问不到<code>A</code>，但是我们可以通过原型链查找，来获取<code>A</code>的原型对象呀。</p> <p>还是这张图：</p> <p><img src="https://s.poetries.top/gitee/2020/09/186.png" alt=""></p> <p>这里我们就有两种解决办法了：</p> <ol><li>通过<code>a.__proto__</code>来访问到原型对象：</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code>a<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span><span class="token function-variable function">logB</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
a<span class="token punctuation">.</span><span class="token function">logB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>通过<code>a.constructor.prototype</code>来访问到原型对象：</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code>a<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">logB</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
a<span class="token punctuation">.</span><span class="token function">logB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>想想是不是这样的？</p> <p>虽然我<code>a</code>实例上没有<code>constructor</code>，但是原型对象上有呀，所以<code>a.construtor</code>实际拿的是原型对象上的<code>construtor</code>。</p> <p>（个人愚见感觉并没什么软用...我用<code>__proto__</code>就可以了呀 😂）</p> <h4 id="_4-4-题目四"><a href="#_4-4-题目四" class="header-anchor">#</a> 4.4 题目四</h4> <p>(理解<strong>组合继承</strong>的优点)</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> colors</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> colors
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>features <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'cute'</span><span class="token punctuation">]</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> colors</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> colors<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span>features<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'sunshine'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child2'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'black'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Child</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span><span class="token punctuation">)</span>
</code></pre></div><p>有了前面几题作为基础，这道题也就不难了。</p> <p>答案：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Child<span class="token punctuation">{</span> <span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">"boy"</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"child1"</span><span class="token punctuation">,</span> <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"white"</span><span class="token punctuation">,</span> <span class="token string">"yellow"</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
Child<span class="token punctuation">{</span> <span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">"boy"</span><span class="token punctuation">,</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"child2"</span><span class="token punctuation">,</span> <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"black"</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
Parent<span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token literal-property property">constructor</span><span class="token operator">:</span> f <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span>

<span class="token boolean">true</span>
<span class="token boolean">true</span>
</code></pre></div><p>解析思路：</p> <ul><li>两个<code>child</code>的<code>sex</code>和<code>name</code>都没啥问题，而<code>colors</code>可能会有些疑问，因为<code>colors</code>是通过<strong>构造继承</strong>于父类的，并且是复制出来的属性，所以改变<code>child1.colors</code>并不会影响<code>child2.colors</code>。(类似题目<code>3.3</code>)</li> <li>而<code>Child.prototype</code>，是使用<code>new Parent</code>生成的，并且生成的时候是没有传递参数进去的，因此<code>name</code>和<code>colors</code>都是<code>undefined</code>。而且题目中又将<code>constructor</code>给修正指向了<code>Child</code>。</li> <li>最后两个<code>true</code>，是因为<code>child1</code>可以沿着它的原型链查找到<code>Child.prototype</code>和<code>Parent.prototype</code>。(类似题目<code>2.1</code>)</li></ul> <p>现在你就可以看出<strong>组合继承</strong>的优点了吧，它其实就是将两种继承方式的优点给结合起来。</p> <ul><li>可以继承父类实例属性和方法，也能够继承父类原型属性和方法</li> <li>弥补了原型链继承中引用属性共享的问题</li> <li>可传参，可复用</li></ul> <h4 id="_4-5-题目五"><a href="#_4-5-题目五" class="header-anchor">#</a> 4.5 题目五</h4> <p>（理解组合继承的缺点）</p> <p>人无完人，狗无完狗，就算是<strong>组合继承</strong>这么牛批的继承方式也还是有它的缺点 😁。</p> <p>一起来看看这里：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment">// 这里有个console.log()</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
</code></pre></div><p>执行结果为：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">undefined</span>
<span class="token string">'child1'</span>

Child<span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'child1'</span> <span class="token punctuation">}</span>
Parent<span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token punctuation">}</span>
</code></pre></div><p>我们虽然只调用了<code>new Child()</code>一次，但是在<code>Parent</code>中却两次打印出了<code>name</code>。</p> <ul><li>第一次是<strong>原型链继承</strong>的时候，<code>new Parent()</code></li> <li>第二次是<strong>构造继承</strong>的时候，<code>Parent.call()</code>调用的</li></ul> <p>也就是说，在使用组合继承的时候，会凭空多调用一次父类构造函数。</p> <p>另外，我们想要继承<strong>父类构造函数</strong>里的属性和方法采用的是<strong>构造继承</strong>，也就是复制一份到子类实例对象中，而此时由于调用了<code>new Parent()</code>，所以<code>Child.prototype</code>中也会有一份一模一样的属性，就例如这里的<code>name: undefined</code>，可是我子类实例对象自己已经有了一份了呀，所以我怎么也用不上<code>Child.prototype</code>上面的了，那你这凭空多出来的属性不就占了内存浪费了吗？</p> <p>因此我们可以看出<strong>组合继承</strong>的缺点：</p> <ul><li>使用组合继承时，父类构造函数会被调用两次</li> <li>并且生成了两个实例，子类实例中的属性和方法会覆盖子类原型(父类实例)上的属性和方法，所以增加了不必要的内存。</li></ul> <h4 id="_4-6-题目六"><a href="#_4-6-题目六" class="header-anchor">#</a> 4.6 题目六</h4> <p>（考察你是否理解<strong>实例对象</strong>上引用类型和<strong>原型对象</strong>上引用类型的区别）</p> <p>这里可就有一个坑了，得注意了⚠️：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> colors</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> colors
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>features <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'cute'</span><span class="token punctuation">]</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> colors</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> colors<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span>features<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'sunshine'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child2'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'black'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>features<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>features<span class="token punctuation">)</span>
</code></pre></div><p>题目解析：</p> <ul><li><code>colors</code>属性虽然定义在<code>Parent</code>构造函数中，但是<code>Child</code>通过<strong>构造继承</strong>复制了其中的属性，所以它存在于各个实例当中，改变<code>child1</code>里的<code>colors</code>就不会影响其它地方了</li> <li><code>features</code>是定义在<strong>父类构造函数原型对象</strong>中的，是比<code>new Parent()</code>还要更深一层的对象，在<code>child</code>实例还有<code>Child.prototype</code>(也就是<code>new Parent()</code>产生出了的匿名实例)上都没有<code>features</code>属性，因此它们只能去它们共有的<code>Parent.prototype</code>上面拿了，所以这时候它们就是共用了一个<code>features</code>，因此改变<code>child1.features</code>就会改变<code>child2.features</code>了。</li></ul> <p>结果为：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">[</span><span class="token string">"white"</span><span class="token punctuation">,</span> <span class="token string">"yellow"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"black"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"cute"</span><span class="token punctuation">,</span> <span class="token string">"sunshine"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"cute"</span><span class="token punctuation">,</span> <span class="token string">"sunshine"</span><span class="token punctuation">]</span>
</code></pre></div><p><strong>组合继承弥补了原型链继承中引用属性共享的问题</strong></p> <p>就在题<code>4.4</code>中，都还热乎着呢？怎么这里的<code>features</code>还是没有被解决啊，它们还是共享了。</p> <p><code>"冤枉啊！我从来不骗人"</code></p> <p>它确实是解决了<strong>原型链继承中引用属性共享的问题</strong>啊，你想想这里<code>Child.prototype</code>是谁？</p> <p>是不是<code>new Parent()</code>产生的那个匿名实例？而这个匿名实例中的引用类型是不是<code>colors</code>？而<code>colors</code>是不是确实不是共享的？</p> <p>那就对了呀，我已经帮你解决了原型(<code>匿名实例</code>)中引用属性共享的问题了呀。</p> <p>至于<code>features</code>是<code>Parent.prototype</code>上的属性，相当于是爷爷那一级别的了，这我可没法子。</p> <h4 id="总结-组合继承"><a href="#总结-组合继承" class="header-anchor">#</a> 总结-组合继承</h4> <p>同样的，让我们对<strong>组合继承</strong>也来做个总结吧：</p> <p><strong>实现方式：</strong></p> <ul><li>使用<strong>原型链继承</strong>来保证子类能继承到父类原型中的属性和方法</li> <li>使用<strong>构造继承</strong>来保证子类能继承到父类的实例属性和方法</li></ul> <p><strong>优点：</strong></p> <ul><li>可以继承父类实例属性和方法，也能够继承父类原型属性和方法</li> <li>弥补了原型链继承中引用属性共享的问题</li> <li>可传参，可复用</li></ul> <p><strong>缺点：</strong></p> <ul><li>使用组合继承时，父类构造函数会被调用两次</li> <li>并且生成了两个实例，子类实例中的属性和方法会覆盖子类原型(父类实例)上的属性和方法，所以增加了不必要的内存。</li></ul> <p><strong>constructor总结：</strong></p> <ul><li><code>constructor</code>它是构造函数原型对象中的一个属性，正常情况下它指向的是原型对象。</li> <li>它并不会影响任何<code>JS</code>内部属性，只是用来标示一下某个实例是由哪个构造函数产生的而已。</li> <li>如果我们使用了<strong>原型链继承</strong>或者<strong>组合继承</strong>无意间修改了<code>constructor</code>的指向，那么出于编程习惯，我们最好将它修改为正确的构造函数。</li></ul> <h3 id="_5-寄生组合继承"><a href="#_5-寄生组合继承" class="header-anchor">#</a> 5. 寄生组合继承</h3> <p>唔...寄生这个词听着有点可怕啊...</p> <p>它比<strong>组合继承</strong>还要牛批一点。</p> <p>刚刚我们提了<strong>组合继承</strong>的缺点无非就是：</p> <ol><li>父类构造函数会被调用两次</li> <li>生成了两个实例，在父类实例上产生了无用废弃的属性</li></ol> <p>那么有没有一种方式让我们直接跳过父类实例上的属性，而让我直接就能继承父类原型链上的属性呢？</p> <p>也就是说，我们需要一个<strong>干净</strong>的实例对象，来作为子类的原型。并且这个<strong>干净</strong>的实例对象还得能继承父类原型对象里的属性。</p> <p>咦～说到<strong>干净</strong>的对象，我就想到了一个方法：<code>Object.create()</code>。</p> <p>让我们先来回忆一波它的用法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>proto<span class="token punctuation">,</span> propertiesObject<span class="token punctuation">)</span>
</code></pre></div><ul><li>参数一，需要指定的原型对象</li> <li>参数二，可选参数，给新对象自身添加新属性以及描述器</li></ul> <p>在这里我们主要讲解一下第一个参数<code>proto</code>，它的作用就是能指定你要新建的这个对象它的原型对象是谁。</p> <p>怎么说呢？</p> <p>就好比，我们使用<code>var parent1 = new Parent()</code>创建了一个对象<code>parent1</code>，那<code>parent1.__proto__</code>就是<code>Parent.prototype</code>。</p> <p>使用<code>var obj = new Object()</code>创建了一个对象<code>obj</code>，那<code>obj.__proto__</code>就是<code>Object.prototype</code>。</p> <p>而这个<code>Object.create()</code>屌了，它现在能指定你新建对象的<code>__proto__</code>。</p> <p>哈哈哈哈～</p> <p>这正不是我们想要的吗？我们现在只想要一个<strong>干净</strong>并且能<strong>链接到父类原型链</strong>上的对象。</p> <p>来看看题目一。</p> <h4 id="_5-1-题目一"><a href="#_5-1-题目一" class="header-anchor">#</a> 5.1 题目一</h4> <p>（理解<strong>寄生组合继承</strong>的用法）</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 与组合继承的区别</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>可以看到，上面👆这道题就是一个标准的<strong>寄生组合继承</strong>，它与<strong>组合继承</strong>的区别仅仅是<code>Child.prototype</code>不同。</p> <p>我们使用了<code>Object.create(Parent.prototype)</code>创建了一个空的对象，并且这个对象的<code>__proto__</code>属性是指向<code>Parent.prototype</code>的。</p> <p>来看看<strong>寄生组合继承</strong>的思维导图：</p> <p>(灵魂画手再次上线)</p> <p><img src="https://s.poetries.top/gitee/2020/09/187.png" alt=""></p> <p>可以看到，现在<code>Parent()</code>已经和<code>child1</code>没有关系了，仅仅是用了<code>Parent.call(this)</code>来复制了一下<code>Parent</code>里的属性和方法 😁。</p> <p>因此这道题的答案为：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 与组合继承的区别</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span> <span class="token comment">// Child{ sex: "boy", name: "child1" }</span>
child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// "child1"</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span> <span class="token comment">// Parent{}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// {}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// {}</span>
</code></pre></div><p>题目解析：</p> <ul><li>使用<strong>寄生组合继承</strong>，<code>child1</code>不仅仅有自己的实例属性<code>sex</code>，而且还复制了父类中的属性<code>name</code></li> <li><strong>寄生组合继承</strong>使得实例<code>child1</code>能通过原型链查找，使用到<code>Parent.prototype</code>上的方法，因此打印出<code>child1</code>。</li></ul> <p>最后的三个空对象，我们就需要展开来看看了：</p> <p><img src="https://s.poetries.top/gitee/2020/09/188.png" alt=""></p> <ul><li><code>child1.__proto__</code>也就是<code>Child.prototype</code>，也就是<code>Object.create(Parent.prototype)</code>，这个空对象它的<code>__proto__</code>指向的就是我们想要的父类的原型对象，所以<code>child1</code>就能使用<code>Parent.prototype</code>上的方法了。</li> <li>而通过<code>Object.create(null)</code>创建的对象呢？哇，这可真的是空的不能再空了，因为我们创建它的时候传递的参数是<code>null</code>，也就是将它的<code>__proto__</code>属性设置为<code>null</code>，那它就相当于是没有原型链了，连<code>Object.prototype</code>上的方法它都不能用了(比如<code>toString()、hasOwnProperty()</code>)</li> <li>再来看看<code>new Object()</code>，这个其实很好理解了，<code>Object</code>本身就是一个构造函数，就像<code>Parent、Child</code>这种，只不过它的原型对象是我们常用的<code>Object.prototype</code>。</li></ul> <p>（看看，大家在学继承的同时，还顺便学习了一波<code>Object.create()</code>，多好啊 😁）</p> <h4 id="_5-2-题目二"><a href="#_5-2-题目二" class="header-anchor">#</a> 5.2 题目二</h4> <p>虽然<strong>寄生组合继承</strong>和<strong>组合继承</strong>非常像，不过我们还是来看一道题巩固巩固吧。</p> <p><img src="https://s.poetries.top/gitee/2020/09/189.png" alt=""></p> <p>执行结果：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Child<span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'child1'</span><span class="token punctuation">,</span> <span class="token literal-property property">face</span><span class="token operator">:</span> <span class="token string">'smile'</span><span class="token punctuation">,</span> <span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">'boy'</span><span class="token punctuation">,</span> <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">,</span> <span class="token string">'yellow'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
Child<span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'child2'</span><span class="token punctuation">,</span> <span class="token literal-property property">face</span><span class="token operator">:</span> <span class="token string">'smile'</span><span class="token punctuation">,</span> <span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">'boy'</span><span class="token punctuation">,</span> <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token literal-property property">features</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'sunshine'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>

<span class="token punctuation">[</span><span class="token string">"cute"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"sunshine"</span><span class="token punctuation">]</span>
</code></pre></div><p>哈哈哈，小伙伴们的答案和这里是否有出入呢？</p> <p>是不是发现一不小心就会做错 😂。</p> <p>让我们来看看解题思路：</p> <ul><li><code>name、face、sex</code>三个属性都没有啥问题，要注意的只是<code>face</code>属性，后面写的会覆盖前面的(类似题目<code>3.2</code>)</li> <li><code>colors</code>属性是通过<strong>构造继承</strong>复制过来的，所以改变<code>child1.colors</code>对其他实例没有影响，这个说过很多次了。</li> <li>要注意的就是这里的<code>features</code>，在没有执行<code>child2.features = ['sunshine']</code>这段代码之前，<code>child1</code>和<code>child2</code>都是共用原型链上的<code>features</code>，但是执行了这段代码之后，就相当于是给<code>child2</code>对象上新增了一个名为<code>features</code>属性，所以这时候<code>child2</code>取的就是它自身的了。</li></ul> <p>（另外，关于更多美化工具的使用可以查看我的这篇文章：<a href="https://juejin.im/post/5e4ca743f265da576b565ee1" target="_blank" rel="noopener noreferrer">你的掘金文章本可以这么炫（博客美化工具一波带走）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）</p> <h4 id="总结-寄生组合继承"><a href="#总结-寄生组合继承" class="header-anchor">#</a> 总结-寄生组合继承</h4> <p><strong>寄生组合继承</strong>算是<code>ES6</code>之前一种比较完美的继承方式吧。</p> <p>它避免了<strong>组合继承</strong>中调用两次父类构造函数，初始化两次实例属性的缺点。</p> <p>所以它拥有了上述所有继承方式的优点：</p> <ul><li>只调用了一次父类构造函数，只创建了一份父类属性</li> <li>子类可以用到父类原型链上的属性和方法</li> <li>能够正常的使用<code>instanceOf</code>和<code>isPrototypeOf</code>方法</li></ul> <h3 id="_6-原型式继承"><a href="#_6-原型式继承" class="header-anchor">#</a> 6. 原型式继承</h3> <p>算是翻了很多关于<code>JS</code>继承的文章吧，其中百分之九十都是这样介绍<strong>原型式继承</strong>的：</p> <p>该方法的原理是创建一个构造函数，构造函数的原型指向对象，然后调用 new 操作符创建实例，并返回这个实例，本质是一个浅拷贝。</p> <p>伪代码如下：</p> <p>(后面会细讲)</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">objcet</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token constant">F</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> <span class="token constant">F</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>开始以为是多神秘的东西，但后来真正了解了它之后感觉用的应该不多吧... 😢</p> <p>先来看看题目一。</p> <h4 id="_6-1-题目一"><a href="#_6-1-题目一" class="header-anchor">#</a> 6.1 题目一</h4> <p>在真正开始看<strong>原型式继承</strong>之前，先来看个我们比较熟悉的东西：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> cat <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">heart</span><span class="token operator">:</span> <span class="token string">'❤️'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> guaiguai <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span>
<span class="token keyword">var</span> huaihuai <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>guaiguai<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>huaihuai<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>guaiguai<span class="token punctuation">.</span>heart<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>huaihuai<span class="token punctuation">.</span>colors<span class="token punctuation">)</span>
</code></pre></div><p>这里的执行结果：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token string">'❤️'</span>
<span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">]</span>
</code></pre></div><p>这里用到了我们之前提到过的<code>Object.create()</code>方法。</p> <p>在这道题中，<code>Object.create(cat)</code>会创建出一个<code>__proto__</code>属性为<code>cat</code>的空对象。</p> <p>所以你可以看到<code>乖乖</code>和<code>坏坏</code>都是一只空猫，但是它们却能用猫<code>cat</code>的属性。</p> <p><img src="https://s.poetries.top/gitee/2020/09/190.png" alt=""></p> <h4 id="_6-2-题目二"><a href="#_6-2-题目二" class="header-anchor">#</a> 6.2 题目二</h4> <p>不怕你笑话，上面👆说的这种方式就是<strong>原型式继承</strong>，只不过在<code>ES5</code>之前，还没有<code>Object.create()</code>方法，所以就会用开头介绍的那段伪代码来代替它。</p> <p>将题目<code>6.1</code>改造一下，让我们自己来实现一个<code>Object.create()</code>。</p> <p>我们就将要实现的函数命名为<code>create()</code>。</p> <p>想想<code>Object.create()</code>的作用：</p> <ul><li>它接受的是一个对象</li> <li>返回的是一个新对象，</li> <li>新对象的原型链中必须能找到传进来的对象</li></ul> <p>所以就有了这么一个方法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">objcet</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token constant">F</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> <span class="token constant">F</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它满足了上述的几个条件。</p> <p>来看看效果是不是和题<code>6.1</code>一样呢？</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">objcet</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token constant">F</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> <span class="token constant">F</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> cat <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">heart</span><span class="token operator">:</span> <span class="token string">'❤️'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> guaiguai <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span>
<span class="token keyword">var</span> huaihuai <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>guaiguai<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>huaihuai<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>guaiguai<span class="token punctuation">.</span>heart<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>huaihuai<span class="token punctuation">.</span>colors<span class="token punctuation">)</span>
</code></pre></div><p>执行结果为：</p> <p><img src="https://s.poetries.top/gitee/2020/09/191.png" alt=""></p> <p>效果是和<code>Object.create()</code>差不多(只不过我们自定义的<code>create</code>返回的对象是构造函数<code>F</code>创建的)。</p> <p>这就有小伙伴要问了，既然是需要满足</p> <ul><li>新对象的原型链中必须能找到传进来的对象</li></ul> <p>这个条件的话，我这样写也可以实现啊：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">create</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    newObj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> obj
    <span class="token keyword">return</span> newObj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>请注意了，我们是要模拟<code>Object.create()</code>方法，如果你都能使用<code>__proto__</code>，那为何不干脆使用<code>Object.create()</code>呢？（它们是同一时期的产物）</p> <h4 id="总结-原型式继承"><a href="#总结-原型式继承" class="header-anchor">#</a> 总结-原型式继承</h4> <p>由于它使用的不太多，这里就不多说它了。</p> <p>不过还是要总结一下滴：</p> <p><strong>实现方式：</strong></p> <p>该方法的原理是创建一个构造函数，构造函数的原型指向对象，然后调用 new 操作符创建实例，并返回这个实例，本质是一个浅拷贝。</p> <p>在<code>ES5</code>之后可以直接使用<code>Object.create()</code>方法来实现，而在这之前就只能手动实现一个了(如题目<code>6.2</code>)。</p> <p><strong>优点：</strong></p> <ul><li>再不用创建构造函数的情况下，实现了原型链继承，代码量减少一部分。</li></ul> <p><strong>缺点：</strong></p> <ul><li>一些引用数据操作的时候会出问题，两个实例会公用继承实例的引用数据类</li> <li>谨慎定义方法，以免定义方法也继承对象原型的方法重名</li> <li>无法直接给父级构造函数使用参数</li></ul> <h3 id="_7-寄生式继承"><a href="#_7-寄生式继承" class="header-anchor">#</a> 7. 寄生式继承</h3> <p>cccc...</p> <p>怎么又来了个什么<strong>寄生式继承</strong>啊，还有完没完...</p> <p>心态放平和...</p> <p>其实这个<strong>寄生式继承</strong>也没啥东西的，它就是在<strong>原型式继承</strong>的基础上再封装一层，来增强对象，之后将这个对象返回。</p> <p>来看看伪代码你就知道了：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createAnother</span> <span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment">// 通过调用 Object.create() 函数创建一个新对象</span>
    clone<span class="token punctuation">.</span><span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 以某种方式来增强对象</span>
    <span class="token keyword">return</span> clone<span class="token punctuation">;</span> <span class="token comment">// 返回这个对象</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_7-1-题目一"><a href="#_7-1-题目一" class="header-anchor">#</a> 7.1 题目一</h4> <p>（了解寄生式继承的使用方式）</p> <p>它的使用方式，唔...</p> <p>例如我现在想要继承某个对象上的属性，同时又想在新创建的对象中新增上一些其它的属性。</p> <p>来看下面👇这两只猫咪</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> cat <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">heart</span><span class="token operator">:</span> <span class="token string">'❤️'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">createAnother</span> <span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>
    clone<span class="token punctuation">.</span><span class="token function-variable function">actingCute</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是一只会卖萌的猫咪'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> clone<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> guaiguai <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span>
<span class="token keyword">var</span> huaihuai <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span>

guaiguai<span class="token punctuation">.</span><span class="token function">actingCute</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>guaiguai<span class="token punctuation">.</span>heart<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>huaihuai<span class="token punctuation">.</span>colors<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>guaiguai<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>huaihuai<span class="token punctuation">)</span>
</code></pre></div><p>题目解析：</p> <ul><li><code>guaiguai</code>是一直经过加工的小猫咪，所以它会卖萌，因此调用<code>actingCute()</code>会打印卖萌</li> <li>两只猫都是通过<code>Object.create()</code>进行过<strong>原型式继承</strong><code>cat</code>对象的，所以是共享使用<code>cat</code>对象中的属性</li> <li><code>guaiguai</code>经过<code>createAnother</code>新增了自身的实例方法<code>actingCute</code>，所以会有这个方法</li> <li><code>huaihuai</code>是一只空猫，因为<code>heart、colors</code>都是原型对象<code>cat</code>上的属性</li></ul> <p>执行结果：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token string">'我是一只会卖萌的猫咪'</span>
<span class="token string">'❤️'</span>
<span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">]</span>
<span class="token punctuation">{</span> <span class="token literal-property property">actingCute</span><span class="token operator">:</span> ƒ <span class="token punctuation">}</span>
<span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><h4 id="总结-寄生式继承"><a href="#总结-寄生式继承" class="header-anchor">#</a> 总结-寄生式继承</h4> <p><strong>实现方式：</strong></p> <ul><li>在<strong>原型式继承</strong>的基础上再封装一层，来增强对象，之后将这个对象返回。</li></ul> <p><strong>优点：</strong></p> <ul><li>再不用创建构造函数的情况下，实现了原型链继承，代码量减少一部分。</li></ul> <p><strong>缺点：</strong></p> <ul><li>一些引用数据操作的时候会出问题，两个实例会公用继承实例的引用数据类</li> <li>谨慎定义方法，以免定义方法也继承对象原型的方法重名</li> <li>无法直接给父级构造函数使用参数</li></ul> <h3 id="_8-混入方式继承多个对象"><a href="#_8-混入方式继承多个对象" class="header-anchor">#</a> 8. 混入方式继承多个对象</h3> <p>过五关斩六将，咱终于到了<code>ES5</code>中的要讲的最后一种继承方式了。</p> <p>这个<strong>混入方式继承</strong>其实很好玩，之前我们一直都是以一个子类继承一个父类，而<strong>混入方式继承</strong>就是教我们如何一个子类继承多个父类的。</p> <p>在这边，我们需要用到<code>ES6</code>中的方法<code>Object.assign()</code>。</p> <p>它的作用就是可以把多个对象的属性和方法拷贝到目标对象中，若是存在同名属性的话，后面的会覆盖前面。(当然，这种拷贝是一种浅拷贝啦)</p> <p>来看看伪代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token function">OtherParent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token class-name">OtherParent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child
</code></pre></div><h4 id="_8-1-题目一"><a href="#_8-1-题目一" class="header-anchor">#</a> 8.1 题目一</h4> <p>(理解混入方式继承的使用)</p> <p>额，既然您都看到这了，说明实力以及很强了，要不？咱直接就上个复杂点的题？</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">sex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSex</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sex<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">OtherParent</span> <span class="token punctuation">(</span><span class="token parameter">colors</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> colors
<span class="token punctuation">}</span>
<span class="token class-name">OtherParent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getColors</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>colors<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token parameter">sex<span class="token punctuation">,</span> colors</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> sex<span class="token punctuation">)</span>
  <span class="token function">OtherParent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> colors<span class="token punctuation">)</span> <span class="token comment">// 新增的父类</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'child'</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token class-name">OtherParent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// 新增的父类原型对象</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'boy'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span><span class="token function">getColors</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
</code></pre></div><p>这里就是采用了混入方式继承，在题目中标出来的地方就是不同于<strong>寄生组合继承</strong>的地方。</p> <p>现在的<code>child1</code>不仅复制了<code>Parent</code>上的属性和方法，还复制了<code>OtherParent</code>上的。</p> <p>而且它不仅可以使用<code>Parent.prototype</code>的属性和方法，还能使用<code>OtherParent.prototype</code>上的。</p> <p>结果：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token string">'boy'</span>
<span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">]</span>
<span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'child'</span><span class="token punctuation">,</span> <span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">'boy'</span><span class="token punctuation">,</span> <span class="token literal-property property">colors</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
</code></pre></div><h4 id="_8-2-题目二"><a href="#_8-2-题目二" class="header-anchor">#</a> 8.2 题目二</h4> <p>(理解混入方式继承的原型链结构)</p> <p>同是上面👆的题，我现在多加上几个输出：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">sex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSex</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sex<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">OtherParent</span> <span class="token punctuation">(</span><span class="token parameter">colors</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> colors
<span class="token punctuation">}</span>
<span class="token class-name">OtherParent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getColors</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>colors<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token parameter">sex<span class="token punctuation">,</span> colors</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> sex<span class="token punctuation">)</span>
  <span class="token function">OtherParent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> colors<span class="token punctuation">)</span> <span class="token comment">// 新增的父类</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'child'</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token class-name">OtherParent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// 新增的父类原型对象</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'boy'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// child1.getSex()</span>
<span class="token comment">// child1.getColors()</span>
<span class="token comment">// console.log(child1)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">OtherParent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">OtherParent</span><span class="token punctuation">)</span>
</code></pre></div><p>这四个输出你感觉会是什么 🤔️？</p> <p>先不要着急，如果有条件的，自己动手在纸上把现在的原型链关系给画一下。</p> <p>反正是已经用<code>XMind</code>的画好了：</p> <p><img src="https://s.poetries.top/gitee/2020/09/193.png" alt=""></p> <p>可以看到，其实它与前面我们画的<strong>寄生组合继承思维导图</strong>就多了下面<code>OtherParent</code>的那部分东西。</p> <ul><li><code>Child</code>内使用了<code>call/apply</code>来复制构造函数<code>OtherParent</code>上的属性和方法</li> <li><code>Child.prototype</code>使用<code>Object.assign()</code>浅拷贝<code>OtherParent.prototype</code>上的属性和方法</li></ul> <p>根据这这幅图，我们很快就能得出答案了：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token boolean">true</span>
<span class="token boolean">false</span>
<span class="token boolean">true</span>
<span class="token boolean">false</span>
</code></pre></div><h3 id="_9-class中的继承"><a href="#_9-class中的继承" class="header-anchor">#</a> 9. class中的继承</h3> <p>构造函数中主要的几种继承方式都已经介绍的差不多了，接下来就让我们看看<code>ES6</code>中<code>class</code>的继承吧。</p> <p>在<code>class</code> 中继承主要是依靠两个东西：</p> <ul><li><code>extends</code></li> <li><code>super</code></li></ul> <p>而且对于该继承的效果和之前我们介绍过的<strong>寄生组合继承</strong>方式一样。（没错，就是那个最屌的继承方式）</p> <p>一起来看看题目一 😁。</p> <h4 id="_9-1-题目一"><a href="#_9-1-题目一" class="header-anchor">#</a> 9.1 题目一</h4> <p>(理解<code>class</code>中的继承)</p> <p>既然它的继承和<strong>寄生组合继承方式</strong>一样，那么让我们将题目<code>5.1</code>的题目改造一下，用<code>class</code>的继承方式来实现它。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token punctuation">}</span>
  <span class="token function">getName</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Child</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span><span class="token punctuation">)</span>
</code></pre></div><p>结果如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Child<span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'child1'</span><span class="token punctuation">,</span> <span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">'boy'</span> <span class="token punctuation">}</span>
<span class="token string">'child1'</span>
<span class="token boolean">true</span>
<span class="token boolean">true</span>
</code></pre></div><p>再让我们来写一下<strong>寄生组合继承</strong>的实现方式：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child

<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Child</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1 <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span><span class="token punctuation">)</span>
</code></pre></div><p>结果如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Child<span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'child1'</span><span class="token punctuation">,</span> <span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">'boy'</span> <span class="token punctuation">}</span>
<span class="token string">'child1'</span>
<span class="token boolean">true</span>
<span class="token boolean">true</span>
</code></pre></div><p>这样好像看不出个啥，没事，让我们上图：</p> <p><strong><code>class</code>继承</strong>：</p> <p><img src="https://s.poetries.top/gitee/2020/09/194.png" alt=""></p> <p><strong>寄生组合继承</strong>：</p> <p><img src="https://s.poetries.top/gitee/2020/09/195.png" alt=""></p> <p>可以看到，<code>class</code>的继承方式完全满足于寄生组合继承。</p> <h4 id="_9-2-题目二"><a href="#_9-2-题目二" class="header-anchor">#</a> 9.2 题目二</h4> <p>(理解<code>extends</code>的基本作用)</p> <p>可以看到上面👆那道题，我们用到了两个关键的东西：<code>extends</code>和<code>super</code>。</p> <p><code>extends</code>从字面上来看还是很好理解的，对某个东西的延伸，继承。</p> <p>那如果我们单单只用<code>extends</code>不用<code>super</code>呢？</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token punctuation">}</span>
  <span class="token function">getName</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token comment">// constructor (name) {</span>
  <span class="token comment">//   super(name)</span>
  <span class="token comment">//   this.sex = 'boy'</span>
  <span class="token comment">// }</span>
  sex <span class="token operator">=</span> <span class="token string">'boy'</span> <span class="token comment">// 实例属性sex放到外面来</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>其实这里的执行结果和没有隐去之前一样。</p> <p>执行结果：</p> <p><img src="https://s.poetries.top/gitee/2020/09/196.png" alt=""></p> <p>那我们是不是可以认为：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 等同于</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>OK👌，其实这一步很好理解啦，还记得之前我们就提到过，在<code>class</code>中如果没有定义<code>constructor</code>方法的话，这个方法是会被默认添加的，那么这里我们没有使用<code>constructor</code>，它其实已经被隐式的添加和调用了。</p> <p>所以我们可以看出<code>extends</code>的作用：</p> <ul><li><code>class</code>可以通过<code>extends</code>关键字实现继承父类的所有属性和方法</li> <li>若是使用了<code>extends</code>实现继承的子类内部没有<code>constructor</code>方法，则会被默认添加<code>constructor</code>和<code>super</code>。</li></ul> <h4 id="_9-3-题目三"><a href="#_9-3-题目三" class="header-anchor">#</a> 9.3 题目三</h4> <p>(理解<code>super</code>的基本作用)</p> <p>通过上面那道题看来，<code>constructor</code>貌似是可有可无的角色。</p> <p>那么<code>super</code>呢，它在 <code>class</code>中扮演的是一个什么角色 🤔️？</p> <p>还是上面的题目，但是这次我不使用<code>super</code>，看看会有什么效果：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'parent'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// super(name) // 把super隐去</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>哈哈哈，现在你保存刷新页面，就会发现它报错了：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Uncaught ReferenceError<span class="token operator">:</span> Must call <span class="token keyword">super</span> constructor <span class="token keyword">in</span> derived <span class="token keyword">class</span> <span class="token class-name">before</span> accessing <span class="token string">'this'</span> or returning from derived constructor
    at <span class="token keyword">new</span> <span class="token class-name">Child</span>
</code></pre></div><p>你品你细细品。</p> <p>大致意思就是你必须得在<code>constructor</code>中调用一下<code>super</code>函数。</p> <p>这样说来，<code>constructor</code>和<code>super</code>是一对好基友啊...</p> <p><code>super</code>函数咱还是不能省，很重要啊。</p> <p>然后再看了看它的写法，有点像是给父级类中传递参数的感觉啊 😄。</p> <p>唔...如果你这样想的话算是猜对了一部分吧。这其实和<code>ES6</code>的继承机制有关。</p> <ul><li>我们知道在<code>ES5</code>中的继承(例如<strong>构造继承、寄生组合继承</strong>) ，实质上是先创造子类的实例对象<code>this</code>，然后再将父类的属性和方法添加到<code>this</code>上(使用的是<code>Parent.call(this)</code>)。</li> <li>而在<code>ES6</code>中却不是这样的，它实质是<strong>先创造父类的实例对象<code>this</code>(也就是使用<code>super()</code>)，然后再用子类的构造函数去修改<code>this</code></strong>。</li></ul> <p>通俗理解就是，子类必须得在<code>constructor</code>中调用<code>super</code>方法，否则新建实例就会报错，因为子类自己没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，然后对其加工，如果不调用<code>super</code>的话子类就得不到<code>this</code>对象。</p> <p>哇哦～</p> <p>[果然是好基友～]</p> <p>这道题介绍的是<code>super</code>的基本作用，下面来说说它的具体用法吧。</p> <h4 id="_9-4-题目四"><a href="#_9-4-题目四" class="header-anchor">#</a> 9.4 题目四</h4> <p>(<code>super</code>当作函数调用时)</p> <p><code>super</code>其实有两种用法，一种是当作函数来调用，还有一种是当做对象来使用。</p> <p>之前那道题就是将它当成函数来调用的，而且我们知道在<code>constructor</code>中还必须得执行<code>super()</code>。</p> <p>其实，<strong>当<code>super</code>被当作函数调用时，代表着父类的构造函数</strong>。</p> <p>虽然它代表着父类的构造函数，但是返回的却是子类的实例，也就是说<code>super</code>内部的<code>this</code>指向的是<code>Child</code>。</p> <p>让我们来看道题验证一下：</p> <p>(<code>new.target</code>指向当前正在执行的那个函数，你可以理解为<code>new</code>后面的那个函数)</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">var</span> parent1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>parent1<span class="token punctuation">)</span>
</code></pre></div><p>这道题中，我在父类的<code>constructor</code>中打印出<code>new.target.name</code>。</p> <p>并且用了一个叫做<code>instance</code>的变量来盛放<code>super()</code>的返回值。</p> <p>而刚刚我们已经说了，<code>super</code>的调用代表着父类构造函数，那么这边我在调用<code>new Child</code>的时候，它里面也执行了父类的<code>constructor</code>函数，所以<code>console.log(new.target.name)</code>肯定被执行了两遍了(一遍是<code>new Child</code>，一遍是<code>new Parent</code>)</p> <p>所以这里的执行结果为：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token string">'Child'</span>
Child<span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token boolean">true</span>

<span class="token string">'Parent'</span>

Child<span class="token punctuation">{</span><span class="token punctuation">}</span>
Parent<span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><ul><li><code>new.target</code>代表的是<code>new</code>后面的那个函数，那么<code>new.target.name</code>表示的是这个函数名，所以在执行<code>new Child</code>的时候，由于调用了<code>super()</code>，所以相当于执行了<code>Parent</code>中的构造函数，因此打印出了<code>'Child'</code>。</li> <li>另外，关于<code>super()</code>的返回值<code>instance</code>，刚刚已经说了它返回的是子类的实例，因此<code>instance</code>会打印出<code>Child{}</code>；并且<code>instance</code>和子类<code>construtor</code>中的<code>this</code>相同，所以打印出<code>true</code>。</li> <li>而执行<code>new Parent</code>的时候，<code>new.target.name</code>打印出的就是<code>'Parent'</code>了。</li> <li>最后分别将<code>child1</code>和<code>parent1</code>打印出来，都没什么问题。</li></ul> <p>通过这道题我们可以看出：</p> <ul><li><code>super</code>当成函数调用时，代表父类的构造函数，且返回的是子类的实例，也就是此时<code>super</code>内部的<code>this</code>指向子类。</li> <li>在子类的<code>constructor</code>中<code>super()</code>就相当于是<code>Parent.constructor.call(this)</code></li></ul> <h4 id="_9-5-题目五"><a href="#_9-5-题目五" class="header-anchor">#</a> 9.5 题目五</h4> <p>(<code>super</code>当成函数调用时的限制)</p> <p>刚刚已经说明了<code>super</code>当成函数调用的时候就相当于是用<code>call</code>来改变了父类构造函数中的<code>this</code>指向，那么它的使用有什么限制呢？</p> <ul><li>子类<code>constructor</code>中如果要使用<code>this</code>的话就必须放到<code>super()</code>之后</li> <li><code>super</code>当成函数调用时只能在子类的<code>construtor</code>中使用</li></ul> <p>来看看这里：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'boy'</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
</code></pre></div><p>你觉得这里会打印出什么呢 🤔️？</p> <p>其实这里啥都不会打印，控制台是红色的。</p> <p>报了个和<code>7.3</code>一样的错：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Uncaught ReferenceError<span class="token operator">:</span> Must call <span class="token keyword">super</span> constructor <span class="token keyword">in</span> derived <span class="token keyword">class</span> <span class="token class-name">before</span> accessing <span class="token string">'this'</span> or returning from derived constructor
    at <span class="token keyword">new</span> <span class="token class-name">Child</span>
</code></pre></div><p>这也就符合了刚刚说到的第一点：子类<code>constructor</code>中如果要使用<code>this</code>的话就必须放到<code>super()</code>之后。</p> <p>这点其实非常好理解，还记得<code>super</code>的作用吗？在<code>constructor</code>中必须得有<code>super()</code>，它就是用来产生实例<code>this</code>的，那么再调用它之前，肯定是访问不到<code>this</code>的啦。</p> <p>也就是在<code>this.sex = 'boy'</code>这一步的时候就已经报错了。</p> <p>至于第二点，<code>super</code>被当成函数来调用的话就必须得放到<code>constructor</code>中，在其它的地方使用它就是我们接下来要说的<code>super</code>当成对象使用的情况。</p> <h4 id="_9-6-题目六"><a href="#_9-6-题目六" class="header-anchor">#</a> 9.6 题目六</h4> <p>(<code>super</code>当成对象来使用时)</p> <p><code>super</code>如果当成一个对象来调用的话，唔...那也可能存在于<code>class</code>里的不同地方呀。</p> <p>比如<code>constructor、子类实例方法、子类构造方法</code>，在这些地方它分别指代的是什么呢？</p> <p>我们只需要记住：</p> <ul><li>在子类的普通函数中<code>super</code>对象指向父类的原型对象</li> <li>在子类的静态方法中<code>super</code>对象指向父类</li></ul> <p>依靠着这个准则，我们来做做下面👇这道题：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token punctuation">}</span>
  <span class="token function">getName</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSex</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'boy'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
Parent<span class="token punctuation">.</span><span class="token function-variable function">getColors</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">instanceFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">staticFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getColors</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'child1'</span><span class="token punctuation">)</span>
child1<span class="token punctuation">.</span><span class="token function">instanceFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
Child<span class="token punctuation">.</span><span class="token function">staticFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
</code></pre></div><p>通过学习<a href="https://juejin.im/post/5e707417e51d45272054d5d3" target="_blank" rel="noopener noreferrer">《【何不三连】比继承家业还要简单的JS继承题-封装篇(牛刀小试)》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>我们知道各个方法所在的位置：</p> <ul><li><code>getName</code>为父类原型对象上的方法</li> <li><code>getSex</code>为父类原型对象上的方法</li> <li><code>getColors</code>为父类的静态方法</li> <li><code>instanceFn</code>为子类原型对象上方法</li> <li><code>staticFn</code>为子类的静态方法</li></ul> <p>题目分析：</p> <ul><li>在使用<code>new Child('child1')</code>创建<code>child1</code>的时候，会执行子类<code>constructor</code>中的方法，因此会执行<code>super.getName()</code>，而依靠准则一，此时的<code>constructor</code>中的第二个<code>super</code>指向的是父类的原型对象，因此此时<code>super.getName()</code>会被成功调用，并打印出<code>'child1'</code>。(第一个<code>super</code>是当成函数来调用)</li> <li>当<code>child1</code>创建完之后，执行了<code>child1.instanceFn()</code>，这时候依据准则一，<code>instanceFn</code>函数中的<code>super</code>指向的还是父类的原型对象，因此<code>super.getSex()</code>也会被成功调用，并打印出<code>'boy'</code>。</li> <li><code>staticFn</code>属于子类的静态方法，所以需要使用<code>Child.staticFn()</code>来调用，且依据准则二，此时<code>staticFn</code>中的<code>super</code>指向的是父类，也就是<code>Parent</code>这个类，因此调用其静态方法<code>getColors</code>成立，打印出<code>['white']</code>。</li> <li>最后需要打印出<code>child1</code>，我们只需要知道哪些是<code>child1</code>的实例属性和方法就可以了，通过比较很容易就发现，<code>child1</code>中就只有一个<code>name</code>属性是通过调用<code>super(name)</code>从父级那里复制来的，其它方法都不能被<code>child1</code>"表现"出来，但是可以调用。</li></ul> <p>所以执行结果为：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token string">'child1'</span>
<span class="token string">'boy'</span>
<span class="token punctuation">[</span><span class="token string">'white'</span><span class="token punctuation">]</span>
Child<span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'child1'</span> <span class="token punctuation">}</span>
</code></pre></div><h4 id="_9-7-题目七"><a href="#_9-7-题目七" class="header-anchor">#</a> 9.7 题目七</h4> <p>(<code>super</code>当成对象调用父类方法时<code>this</code>的指向)</p> <p>在做刚刚那道题的时候，额，你们就对<code>super.getName()</code>的打印结果没啥疑问吗 🤔️？</p> <p>(难道是我吹的太有模有样让你忽略了它？)</p> <p>既然<code>super.getName()</code>，<code>getName</code>是被<code>super</code>调用的，而我却说此时的<code>super</code>指向的是父类原型对象。那么<code>getName</code>内打印出的应该是父类原型对象上的<code>name</code>，也就是<code>undefined</code>呀，怎么会打印出<code>child1</code>呢？</p> <p>带着这个疑问我写下了这道题：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sex  <span class="token operator">=</span> <span class="token string">'boy'</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSex</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sex<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">'girl'</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
</code></pre></div><p>现在父类原型对象和子类实例对象<code>child1</code>上都有<code>sex</code>属性，且不相同。</p> <p>如果按照<code>this</code>指向来看，调用<code>super.getSex()</code>打印出的应该是<code>Parent.prototype</code>上的<code>sex</code>，<code>'boy'</code>。</p> <p>就像是这样调用一样：<code>Parent.prototype.getSex()</code>。</p> <p>但是结果却是：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token string">'girl'</span>
Child<span class="token punctuation">{</span> <span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">'girl'</span> <span class="token punctuation">}</span>
</code></pre></div><p>唔...其实扯了这么一大堆，我只是想告诉你：</p> <ul><li><code>ES6</code>规定，通过<code>super</code>调用父类的方法时，<code>super</code>会绑定子类的<code>this</code>。</li></ul> <p>也就是说，<code>super.getSex()</code>转换为伪代码就是：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token comment">// 即</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
</code></pre></div><p>(别看这里扯的多，但是多看点例子🌰的话理解一定会加深刻的)</p> <p>而且<code>super</code>其实还有一个特性，就是你在使用它的时候，必须得显式的指定它是作为函数使用还是对象来使用，否则会报错的。</p> <p>比如下面这样就不可以：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 不报错</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 不报错</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">)</span> <span class="token comment">// 这里会报错</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_9-8-题目八"><a href="#_9-8-题目八" class="header-anchor">#</a> 9.8 题目八</h4> <p>(了解<code>extends</code>的继承目标)</p> <p><code>extends</code>后面接着的继承目标不一定要是个<code>class</code>。</p> <p><code>class B extends A {}</code>，只要<code>A</code>是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。</p> <p>由于函数都有<code>prototype</code>属性，因此<code>A</code>可以是任意函数。</p> <p>来看看这一题：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'parent'</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Child1</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child2</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child3</span> <span class="token keyword">extends</span> <span class="token class-name">Array</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> child3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
child3<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child3<span class="token punctuation">)</span>
</code></pre></div><p>执行结果：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Child1<span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'parent'</span> <span class="token punctuation">}</span>
Child2<span class="token punctuation">{</span><span class="token punctuation">}</span>
Child3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre></div><ul><li>可以继承构造函数<code>Parent</code></li> <li>不存在任何继承，就是一个普通的函数，所以直接继承<code>Function.prototype</code></li> <li>可以继承原生构造函数</li></ul> <p>（其实这里只要作为一个知道的知识点就可以了，真正使用来说貌似不常用）</p> <h4 id="总结-class继承"><a href="#总结-class继承" class="header-anchor">#</a> 总结-class继承</h4> <p>我滴个乖乖...</p> <p><code>class</code>继承咋有这么多讲的啊。</p> <p>不过总算是我也说完，你也看完了...</p> <p>OK👌，来个总结呗。</p> <p><strong>ES6中的继承：</strong></p> <ul><li>主要是依赖<code>extends</code>关键字来实现继承，且继承的效果类似于<strong>寄生组合继承</strong></li> <li>使用了<code>extends</code>实现继承不一定要<code>constructor</code>和<code>super</code>，因为没有的话会默认产生并调用它们</li> <li><code>extends</code>后面接着的目标不一定是<code>class</code>，只要是个有<code>prototype</code>属性的函数就可以了</li></ul> <p><strong>super相关：</strong></p> <ul><li>在实现继承时，如果子类中有<code>constructor</code>函数，必须得在<code>constructor</code>中调用一下<code>super</code>函数，因为它就是用来产生实例<code>this</code>的。</li> <li><code>super</code>有两种调用方式：当成函数调用和当成对象来调用。</li> <li><code>super</code>当成函数调用时，代表父类的构造函数，且返回的是子类的实例，也就是此时<code>super</code>内部的<code>this</code>指向子类。在子类的<code>constructor</code>中<code>super()</code>就相当于是<code>Parent.constructor.call(this)</code>。</li> <li><code>super</code>当成对象调用时，普通函数中<code>super</code>对象指向父类的原型对象，静态函数中指向父类。且通过<code>super</code>调用父类的方法时，<code>super</code>会绑定子类的<code>this</code>，就相当于是<code>Parent.prototype.fn.call(this)</code>。</li></ul> <p><strong>ES5继承和ES6继承的区别：</strong></p> <ul><li>在<code>ES5</code>中的继承(例如<strong>构造继承、寄生组合继承</strong>) ，实质上是先创造子类的实例对象<code>this</code>，然后再将父类的属性和方法添加到<code>this</code>上(使用的是<code>Parent.call(this)</code>)。</li> <li>而在<code>ES6</code>中却不是这样的，它实质是<strong>先创造父类的实例对象<code>this</code>(也就是使用<code>super()</code>)，然后再用子类的构造函数去修改<code>this</code></strong>。</li></ul> <h3 id="所有继承总结"><a href="#所有继承总结" class="header-anchor">#</a> 所有继承总结</h3> <p>唔...写到最后我感觉还是要将所有的继承情况来做一个总结，这边只总结出实现方式的伪代码以及原型链思维导图，具体的优缺点在各个模块中已经总结好了就不重复了。</p> <h4 id="_1-原型链继承-2"><a href="#_1-原型链继承-2" class="header-anchor">#</a> 1. 原型链继承</h4> <p><code>伪代码：</code></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p><code>思维导图：</code></p> <p><img src="https://s.poetries.top/gitee/2020/09/198.png" alt=""></p> <h4 id="_2-构造继承"><a href="#_2-构造继承" class="header-anchor">#</a> 2. 构造继承</h4> <p><code>伪代码：</code></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_3-组合继承"><a href="#_3-组合继承" class="header-anchor">#</a> 3. 组合继承</h4> <p><code>伪代码：</code></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 构造继承</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 原型链继承</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 修正constructor</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child
</code></pre></div><p><code>思维导图：</code></p> <p><img src="https://s.poetries.top/gitee/2020/09/199.png" alt=""></p> <h4 id="_4-寄生组合继承"><a href="#_4-寄生组合继承" class="header-anchor">#</a> 4. 寄生组合继承</h4> <p><code>伪代码：</code></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 构造继承</span>
<span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 原型式继承</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
<span class="token comment">// 修正constructor</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child
</code></pre></div><p><code>思维导图：</code></p> <p><img src="https://s.poetries.top/gitee/2020/09/200.png" alt=""></p> <h4 id="_5-原型式继承"><a href="#_5-原型式继承" class="header-anchor">#</a> 5. 原型式继承</h4> <p><code>伪代码：</code></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> child <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
</code></pre></div><h4 id="_6-寄生式继承"><a href="#_6-寄生式继承" class="header-anchor">#</a> 6. 寄生式继承</h4> <p><code>伪代码：</code></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createAnother</span> <span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment">// 通过调用 Object.create() 函数创建一个新对象</span>
    clone<span class="token punctuation">.</span><span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 以某种方式来增强对象</span>
    <span class="token keyword">return</span> clone<span class="token punctuation">;</span> <span class="token comment">// 返回这个对象</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_7-混入方式继承"><a href="#_7-混入方式继承" class="header-anchor">#</a> 7. 混入方式继承</h4> <p><code>伪代码：</code></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token function">OtherParent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token class-name">OtherParent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child
</code></pre></div><p><code>思维导图：</code></p> <p><img src="https://s.poetries.top/gitee/2020/09/201.png" alt=""></p> <h4 id="_8-class中的继承"><a href="#_8-class中的继承" class="header-anchor">#</a> 8. class中的继承</h4> <p><code>伪代码：</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <!----> <div class="readMore-wrapper"><span class="readMore">阅读全文</span></div>
                    </div>
                            <p>这是一个信息提示框。</p>
                        </div>

                        <div class="note warning">
                            <div class="note-title"><i class="fas fa-exclamation-triangle"></i> 注意</div>
                            <p>这是一个警告提示框。</p>
                        </div>

                        <div class="note success">
                            <div class="note-title"><i class="fas fa-check-circle"></i> 成功</div>
                            <p>这是一个成功提示框。</p>
                        </div>

                        <h2>代码示例</h2>
                        <pre><code class="language-javascript">// 示例代码
function example() {
    console.log('Hello, FrontendHub!');
}
</code></pre>
                    </div>

                    <!-- 文章底部导航 -->
                    <nav class="article-nav">
                        <a href="#" class="prev-article">
                            <i class="fas fa-chevron-left"></i>
                            <span>上一篇</span>
                        </a>
                        <a href="#" class="next-article">
                            <span>下一篇</span>
                            <i class="fas fa-chevron-right"></i>
                        </a>
                    </nav>
                </article>
            </div>
        </div>
    </main>

    <!-- 页脚 -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4><i class="fas fa-code"></i> FrontendHub</h4>
                    <p>专注于前端技术学习与面试准备</p>
                </div>
                <div class="footer-section">
                    <h4>快速链接</h4>
                    <ul>
                        <li><a href="../../index.html">首页</a></li>
                        <li><a href="../index.html#courses">课程体系</a></li>
                        <li><a href="../index.html#resources">学习资源</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 FrontendHub. 用于个人学习使用.</p>
            </div>
        </div>
    </footer>

    <!-- 返回顶部按钮 -->
    <button class="back-to-top" id="backToTop">
        <i class="fas fa-arrow-up"></i>
    </button>

    <script src="../../js/main.js"></script>
    <script src="../../js/content.js"></script>
</body>
</html>

