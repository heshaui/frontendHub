<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="referrer" content="no-referrer">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React16.3新的生命周期详解 - FrontendHub</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/content.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body class="content-page">
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="../../index.html" style="color: inherit; text-decoration: none; display: flex; align-items: center; gap: 0.5rem;">
                    <i class="fas fa-code"></i>
                    <span>FrontendHub</span>
                </a>
            </div>
            <button class="nav-toggle" id="navToggle">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-menu" id="navMenu">
                <li><a href="../../index.html">首页</a></li>
                <li><a href="../index.html#features">特色</a></li>
                <li><a href="../index.html#courses">课程</a></li>
                <li><a href="../index.html#resources">资源</a></li>
            </ul>
        </div>
    </nav>

    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <div class="container">
            <a href="../../index.html"><i class="fas fa-home"></i> 首页</a>
            <i class="fas fa-chevron-right"></i>
            <span>React16.3新的生命周期详解</span>
        </div>
    </div>

    <!-- 主要内容区 -->
    <main class="content-main">
        <div class="container">
            <div class="content-layout">
                <!-- 侧边栏目录 -->
                <aside class="sidebar">
                    <div class="sidebar-sticky">
                        <h3><i class="fas fa-list"></i> 目录</h3>
                        <nav class="toc" id="toc">
                            <!-- 目录将通过JavaScript自动生成 -->
                        </nav>
                    </div>
                </aside>

                <!-- 文章内容 -->
                <article class="article">
                    <header class="article-header">
                        <h1>React16.3新的生命周期详解</h1>
                        <div class="article-meta">
                            <span><i class="far fa-calendar"></i> 更新时间：2025-12-23</span>
                            <span><i class="far fa-clock"></i> 阅读时长：约 15 分钟</span>
                        </div>
                    </header>

                    <div class="article-content">
<div class="content__default"><h2 id="一、react-v16-0前的生命周期"><a href="#一、react-v16-0前的生命周期" class="header-anchor">#</a> 一、React v16.0前的生命周期</h2> <p><img src="https://s.poetries.top/gitee/2019/10/417.png" alt=""></p> <h3 id="_1-1-第一个是组件初始化-initialization-阶段"><a href="#_1-1-第一个是组件初始化-initialization-阶段" class="header-anchor">#</a> 1.1 第一个是组件初始化(initialization)阶段</h3> <blockquote><p>也就是以下代码中类的构造方法( <code>constructor()</code> ),Test类继承了react <code>Component</code>这个基类，也就继承这个<code>react</code>的基类，才能有<code>render()</code>,生命周期等方法可以使用，这也说明为什么函数组件不能使用这些方法的原因</p></blockquote> <p><code>super(props)</code>用来调用基类的构造方法( <code>constructor()</code> ), 也将父组件的props注入给子组件，功子组件读取(组件中<code>props</code>只读不可变，<code>state</code>可变)而<code>constructor()</code>用来做一些组件的初始化工作，如定义<code>this.state</code>的初始内容</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_1-2-第二个是组件的挂载-mounting-阶段"><a href="#_1-2-第二个是组件的挂载-mounting-阶段" class="header-anchor">#</a> 1.2 第二个是组件的挂载(Mounting)阶段</h3> <p><strong>此阶段分为componentWillReceiveProps，shouldComponentUpdate，componentWillUpdate，render，componentDidUpdate</strong></p> <h4 id="_1-2-1-componentwillmount"><a href="#_1-2-1-componentwillmount" class="header-anchor">#</a> 1.2.1 componentWillMount</h4> <blockquote><p>在组件挂载到DOM前调用，且只会被调用一次，在这边调用<code>this.setState</code>不会引起组件重新渲染，也可以把写在这边的内容提前到<code>constructor()</code>中，所以项目中很少用</p></blockquote> <h4 id="_1-2-2-render"><a href="#_1-2-2-render" class="header-anchor">#</a> 1.2.2 render</h4> <blockquote><p>根据组件的<code>props</code>和<code>state</code>（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新<code>render</code>） ，<code>return</code> 一个<code>React</code>元素（描述组件，即<code>UI</code>），不负责组件实际渲染工作，之后由<code>React</code>自身根据此元素去渲染出页面<code>DOM</code>。<code>render</code>是纯函数（<code>Pure function</code>：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行<code>this.setState</code>，会有改变组件状态的副作用</p></blockquote> <h4 id="_1-2-3-componentdidmount"><a href="#_1-2-3-componentdidmount" class="header-anchor">#</a> 1.2.3 componentDidMount</h4> <blockquote><p>组件挂载到<code>DOM</code>后调用，且只会被调用一次</p></blockquote> <h3 id="_1-3-第三个是组件的更新-update-阶段"><a href="#_1-3-第三个是组件的更新-update-阶段" class="header-anchor">#</a> 1.3 第三个是组件的更新(update)阶段</h3> <blockquote><p><code>setState</code>引起的<code>state</code>更新或父组件重新<code>render</code>引起的<code>props</code>更新，更新后的<code>state</code>和<code>props</code>相对之前无论是否有变化，都将引起子组件的重新<code>render</code></p></blockquote> <h4 id="_1-3-1-造成组件更新有两类-三种-情况"><a href="#_1-3-1-造成组件更新有两类-三种-情况" class="header-anchor">#</a> 1.3.1 造成组件更新有两类（三种）情况</h4> <p><strong>1. 父组件重新render</strong></p> <blockquote><p>父组件重新<code>render</code>引起子组件重新<code>render</code>的情况有两种</p></blockquote> <ul><li>a. 直接使用,每当父组件重新<code>render</code>导致的重传<code>props</code>，子组件将直接跟着重新渲染，无论<code>props</code>是否有变化。可通过<code>shouldComponentUpdate</code>方法优化</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
   <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>someThings <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>someThings<span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>someThings<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>b.在<code>componentWillReceiveProps</code>方法中，将<code>props</code>转换成自己的<code>state</code></li></ul> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">someThings</span><span class="token operator">:</span> props<span class="token punctuation">.</span>someThings
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 父组件重传props时就会调用这个方法</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">someThings</span><span class="token operator">:</span> nextProps<span class="token punctuation">.</span>someThings<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>someThings<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><blockquote><p>在该函数(<code>componentWillReceiveProps</code>)中调用 <code>this.setState()</code> 将不会引起第二次渲染</p></blockquote> <p>是因为<code>componentWillReceiveProps</code>中判断<code>props</code>是否变化了，若变化了，<code>this.setState</code>将引起<code>state</code>变化，从而引起<code>render</code>，此时就没必要再做第二次因重传<code>props</code>引起的<code>render</code>了，不然重复做一样的渲染了</p> <p><strong>2. 组件本身调用setState，无论state有没有变化。可通过shouldComponentUpdate方法优化</strong></p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
   <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
          <span class="token literal-property property">someThings</span><span class="token operator">:</span><span class="token number">1</span>
        <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextStates</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nextStates<span class="token punctuation">.</span>someThings <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>someThings<span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

   <span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 虽然调用了setState ，但state并无变化</span>
        <span class="token keyword">const</span> preSomeThings <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>someThings
         <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            <span class="token literal-property property">someThings</span><span class="token operator">:</span> preSomeThings
         <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&lt;</span>div onClick <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>someThings<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_1-3-2-componentwillreceiveprops-nextprops"><a href="#_1-3-2-componentwillreceiveprops-nextprops" class="header-anchor">#</a> 1.3.2 componentWillReceiveProps(nextProps)</h4> <blockquote><p>此方法只调用于<code>props</code>引起的组件更新过程中，参数<code>nextProps</code>是父组件传给当前组件的新<code>props</code>。但父组件<code>render</code>方法的调用不能保证重传给当前组件的<code>props</code>是有变化的，所以在此方法中根据<code>nextProps</code>和<code>this.props</code>来查明重传的<code>props</code>是否改变，以及如果改变了要执行啥，比如根据新的<code>props</code>调用<code>this.setState</code>出发当前组件的重新<code>render</code></p></blockquote> <h4 id="_1-3-3-shouldcomponentupdate-nextprops-nextstate"><a href="#_1-3-3-shouldcomponentupdate-nextprops-nextstate" class="header-anchor">#</a> 1.3.3 shouldComponentUpdate(nextProps, nextState)</h4> <blockquote><p>此方法通过比较<code>nextProps</code>，<code>nextState</code>及当前组件的<code>this.props</code>，<code>this.state</code>，返回<code>true</code>时当前组件将继续执行更新过程，返回<code>false</code>则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。</p></blockquote> <p>ps：这边也可以看出，就算<code>componentWillReceiveProps()</code>中执行了<code>this.setState</code>，更新了<code>state</code>，但在<code>render</code>前（如<code>shouldComponentUpdate</code>，<code>componentWillUpdate</code>），<code>this.state</code>依然指向更新前的<code>state</code>，不然<code>nextState</code>及当前组件的<code>this.state</code>的对比就一直是<code>true</code>了</p> <h4 id="_1-3-4-componentwillupdate-nextprops-nextstate"><a href="#_1-3-4-componentwillupdate-nextprops-nextstate" class="header-anchor">#</a> 1.3.4 componentWillUpdate(nextProps, nextState)</h4> <blockquote><p>此方法在调用<code>render</code>方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用</p></blockquote> <h4 id="_1-3-5-componentdidupdate-prevprops-prevstate"><a href="#_1-3-5-componentdidupdate-prevprops-prevstate" class="header-anchor">#</a> 1.3.5 componentDidUpdate(prevProps, prevState)</h4> <blockquote><p>此方法在组件更新后被调用，可以操作组件更新的<code>DOM</code>，<code>prevProps</code>和<code>prevState</code>这两个参数指的是组件更新前的<code>props</code>和<code>state</code></p></blockquote> <h3 id="_1-4-卸载阶段"><a href="#_1-4-卸载阶段" class="header-anchor">#</a> 1.4 卸载阶段</h3> <blockquote><p>此阶段只有一个生命周期方法：<code>componentWillUnmount</code></p></blockquote> <p>此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清除<code>componentDidMount</code>中手动创建的<code>DOM</code>元素等，以避免引起内存泄漏</p> <h2 id="二、react-v16-4-的生命周期"><a href="#二、react-v16-4-的生命周期" class="header-anchor">#</a> 二、React v16.4 的生命周期</h2> <p><strong>React v16.4 的生命周期图</strong></p> <p><img src="https://s.poetries.top/gitee/2019/10/418.png" alt=""></p> <h3 id="_2-1-变更缘由"><a href="#_2-1-变更缘由" class="header-anchor">#</a> 2.1 变更缘由</h3> <blockquote><p>原来（<code>React v16.0</code>前）的生命周期在<code>React v16</code>推出的<code>Fiber</code>之后就不合适了，因为如果要开启<code>async rendering</code>，在<code>render</code>函数之前的所有函数，都有可能被执行多次</p></blockquote> <p><strong>原来（React v16.0前）的生命周期有哪些是在render前执行的呢？</strong></p> <ul><li><code>componentWillMount</code></li> <li><code>componentWillReceiveProps</code></li> <li><code>shouldComponentUpdate</code></li> <li><code>componentWillUpdate</code></li></ul> <blockquote><p>如果开发者开了<code>async rendering</code>，而且又在以上这些<code>render</code>前执行的生命周期方法做<code>AJAX</code>请求的话，那<code>AJAX</code>将被无谓地多次调用。而且在<code>componentWillMount</code>里发起<code>AJAX</code>，不管多快得到结果也赶不上首次<code>render</code>，而且<code>componentWillMount</code>在服务器端渲染也会被调用到</p></blockquote> <ul><li>所以除了<code>shouldComponentUpdate</code>，其他在<code>render</code>函数之前的所有函数（<code>componentWillMount</code>，<code>componentWillReceiveProps</code>，<code>componentWillUpdate</code>）都被<code>getDerivedStateFromProps</code>替代</li> <li>也就是用一个静态函数<code>getDerivedStateFromProps</code>来取代被<code>deprecate</code>的几个生命周期函数，就是强制开发者在<code>render</code>之前只做无副作用的操作，而且能做的操作局限在根据<code>props</code>和<code>state</code>决定新的<code>state</code></li></ul> <blockquote><p>React v16.0刚推出的时候，是增加了一个<code>componentDidCatch</code>生命周期函数，这只是一个增量式修改，完全不影响原有生命周期函数；但是，到了<code>React v16.3</code>，大改动来了，引入了两个新的生命周期函数</p></blockquote> <h3 id="_2-2-引入了两个新的生命周期函数"><a href="#_2-2-引入了两个新的生命周期函数" class="header-anchor">#</a> 2.2 引入了两个新的生命周期函数</h3> <h4 id="_2-2-1-getderivedstatefromprops"><a href="#_2-2-1-getderivedstatefromprops" class="header-anchor">#</a> 2.2.1 getDerivedStateFromProps</h4> <blockquote><p><code>getDerivedStateFromProps</code>本来（React v16.3中）是只在创建和更新（由父组件引发部分），也就是不是不由父组件引发，那么<code>getDerivedStateFromProps</code>也不会被调用，如自身<code>setState</code>引发或者<code>forceUpdate</code>引发</p></blockquote> <p><strong>React v16.3 的生命周期图</strong></p> <p><img src="https://s.poetries.top/gitee/2019/10/419.png" alt=""></p> <blockquote><p>这样的话理解起来有点乱，在<code>React v16.4</code>中改正了这一点，让<code>getDerivedStateFromProps</code>无论是<code>Mounting</code>还是<code>Updating</code>，也无论是因为什么引起的<code>Updating</code>，全部都会被调用，具体可看<code>React v16.4</code>的生命周期图</p></blockquote> <p><strong>React v16.4后的getDerivedStateFromProps</strong></p> <blockquote><p><code>static getDerivedStateFromProps(props, state)</code> 在组件创建时和更新时的render方法之前调用，它应该返回一个对象来更新状态，或者返回<code>null</code>来不更新任何内容</p></blockquote> <h4 id="_2-2-2-getsnapshotbeforeupdate"><a href="#_2-2-2-getsnapshotbeforeupdate" class="header-anchor">#</a> 2.2.2 getSnapshotBeforeUpdate</h4> <blockquote><p><code>getSnapshotBeforeUpdate()</code> 被调用于<code>render</code>之后，可以读取但无法使用DOM的时候。它使您的组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给<code>componentDidUpdate（）</code></p></blockquote> <p>官网给的例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">ScrollingList</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>listRef <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//我们是否要添加新的 items 到列表?</span>
    <span class="token comment">// 捕捉滚动位置，以便我们可以稍后调整滚动.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevProps<span class="token punctuation">.</span>list<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>list<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
      <span class="token keyword">return</span> list<span class="token punctuation">.</span>scrollHeight <span class="token operator">-</span> list<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">,</span> snapshot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//如果我们有snapshot值, 我们已经添加了 新的items.</span>
    <span class="token comment">// 调整滚动以至于这些新的items 不会将旧items推出视图。</span>
    <span class="token comment">// (这边的snapshot是 getSnapshotBeforeUpdate方法的返回值)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>snapshot <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
      list<span class="token punctuation">.</span>scrollTop <span class="token operator">=</span> list<span class="token punctuation">.</span>scrollHeight <span class="token operator">-</span> snapshot<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>listRef<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token comment">/* ...contents... */</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="三、参考"><a href="#三、参考" class="header-anchor">#</a> 三、参考</h2> <ul><li><a href="https://zhuanlan.zhihu.com/p/38030418" target="_blank" rel="noopener noreferrer">React v16.3之后的组件生命周期函数<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <!----> <div class="readMore-wrapper"><span class="readMore">阅读全文</span></div>
                    </div>
                            <p>这是一个信息提示框。</p>
                        </div>

                        <div class="note warning">
                            <div class="note-title"><i class="fas fa-exclamation-triangle"></i> 注意</div>
                            <p>这是一个警告提示框。</p>
                        </div>

                        <div class="note success">
                            <div class="note-title"><i class="fas fa-check-circle"></i> 成功</div>
                            <p>这是一个成功提示框。</p>
                        </div>

                        <h2>代码示例</h2>
                        <pre><code class="language-javascript">// 示例代码
function example() {
    console.log('Hello, FrontendHub!');
}
</code></pre>
                    </div>

                    <!-- 文章底部导航 -->
                    <nav class="article-nav">
                        <a href="#" class="prev-article">
                            <i class="fas fa-chevron-left"></i>
                            <span>上一篇</span>
                        </a>
                        <a href="#" class="next-article">
                            <span>下一篇</span>
                            <i class="fas fa-chevron-right"></i>
                        </a>
                    </nav>
                </article>
            </div>
        </div>
    </main>

    <!-- 页脚 -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4><i class="fas fa-code"></i> FrontendHub</h4>
                    <p>专注于前端技术学习与面试准备</p>
                </div>
                <div class="footer-section">
                    <h4>快速链接</h4>
                    <ul>
                        <li><a href="../../index.html">首页</a></li>
                        <li><a href="../index.html#courses">课程体系</a></li>
                        <li><a href="../index.html#resources">学习资源</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 FrontendHub. 用于个人学习使用.</p>
            </div>
        </div>
    </footer>

    <!-- 返回顶部按钮 -->
    <button class="back-to-top" id="backToTop">
        <i class="fas fa-arrow-up"></i>
    </button>

    <script src="../../js/main.js"></script>
    <script src="../../js/content.js"></script>
</body>
</html>

