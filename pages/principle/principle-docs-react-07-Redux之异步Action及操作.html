<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redux之异步Action及操作 - FrontendHub</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/content.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body class="content-page">
    <!-- 导航栏 -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="../../index.html" style="color: inherit; text-decoration: none; display: flex; align-items: center; gap: 0.5rem;">
                    <i class="fas fa-code"></i>
                    <span>FrontendHub</span>
                </a>
            </div>
            <button class="nav-toggle" id="navToggle">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-menu" id="navMenu">
                <li><a href="../../index.html">首页</a></li>
                <li><a href="../index.html#features">特色</a></li>
                <li><a href="../index.html#courses">课程</a></li>
                <li><a href="../index.html#resources">资源</a></li>
            </ul>
        </div>
    </nav>

    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <div class="container">
            <a href="../../index.html"><i class="fas fa-home"></i> 首页</a>
            <i class="fas fa-chevron-right"></i>
            <span>Redux之异步Action及操作</span>
        </div>
    </div>

    <!-- 主要内容区 -->
    <main class="content-main">
        <div class="container">
            <div class="content-layout">
                <!-- 侧边栏目录 -->
                <aside class="sidebar">
                    <div class="sidebar-sticky">
                        <h3><i class="fas fa-list"></i> 目录</h3>
                        <nav class="toc" id="toc">
                            <!-- 目录将通过JavaScript自动生成 -->
                        </nav>
                    </div>
                </aside>

                <!-- 文章内容 -->
                <article class="article">
                    <header class="article-header">
                        <h1>Redux之异步Action及操作</h1>
                        <div class="article-meta">
                            <span><i class="far fa-calendar"></i> 更新时间：2025-12-23</span>
                            <span><i class="far fa-clock"></i> 阅读时长：约 15 分钟</span>
                        </div>
                    </header>

                    <div class="article-content">
<!----> <div class="content__default"><h2 id="一、创建同步action"><a href="#一、创建同步action" class="header-anchor">#</a> 一、创建同步Action</h2> <blockquote><p><code>Action</code>是数据从应用传递到 <code>store</code>/<code>state</code> 的载体，也是开启一次完成数据流的开始</p></blockquote> <p><strong>普通的action对象</strong></p> <div class="language- extra-class"><pre class="language-text"><code>const action = {
	type:'ADD_TODO',
	name:'poetries'
}

dispatch(action)
</code></pre></div><p><strong>封装action creator</strong></p> <div class="language- extra-class"><pre class="language-text"><code>function actionCreator(data){
    return {
    	type:'ADD_TODO',
    	data:data
    }
}

dispatch(actionCreator('poetries'))
</code></pre></div><p><strong>bindActionCreators合并</strong></p> <div class="language- extra-class"><pre class="language-text"><code>function a(name,id){
	reurn {
		type:'a',
		name,
		id
	}
}
function b(name,id){
	reurn {
		type:'b',
		name,
		id
	}
}

let actions = Redux.bindActionCreators({a,b},store.dispatch)

//调用
actions.a('poetries','id001')
actions.b('jing','id002')
</code></pre></div><p><strong>action创建的标准</strong></p> <blockquote><p>在Flux的架构中，一个Action要符合 FSA(Flux Standard Action) 规范，需要满足如下条件</p></blockquote> <ul><li>是一个纯文本对象</li> <li>只具备 <code>type</code> 、<code>payload</code>、<code>error</code> 和 <code>meta</code>中的一个或者多个属性。<code>type</code> 字段不可缺省，其它字段可缺省</li> <li>若 <code>Action</code> 报错，<code>error</code> 字段不可缺省，切必须为 <code>true</code></li></ul> <blockquote><p><code>payload</code> 是一个对象，用作Action携带数据的载体</p></blockquote> <p><strong>标准action示例</strong></p> <ul><li>A basic Flux Standard Action:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{
  type: 'ADD_TODO',
  payload: {
    text: 'Do something.'  
  }
}
</code></pre></div><ul><li>An FSA that represents an error, analogous to a rejected Promise</li></ul> <div class="language- extra-class"><pre class="language-text"><code>{
  type: 'ADD_TODO',
  payload: new Error(),
  error: true
}
</code></pre></div><blockquote><p>https://github.com/acdlite/flux-standard-action</p></blockquote> <ul><li>可以采用如下一个简单的方式检验一个<code>Action</code>是否符合FSA标准</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// every有一个匹配不到返回false
let isFSA = Object.keys(action).every((item)=&gt;{
   return  ['payload','type','error','meta'].indexOf(item) &gt;  -1
})
</code></pre></div><h2 id="二、创建异步action的多种方式"><a href="#二、创建异步action的多种方式" class="header-anchor">#</a> 二、创建异步action的多种方式</h2> <blockquote><p>最简单的方式就是使用同步的方式来异步，将原来同步时一个<code>action</code>拆分成多个异步的<code>action</code>的，在异步开始前、异步请求中、异步正常返回（异常）操作分别使用同步的操作，从而模拟出一个异步操作了。这样的方式是比较麻烦的，现在已经有<code>redux-saga</code>等插件来解决这些问题了</p></blockquote> <p><strong>异步action的实现方式一：setTimeout</strong></p> <blockquote><p><code>redux-thunk</code>中间处理解析</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function thunkAction(data) {
    reutrn (dispatch)=&gt;{
        setTimeout(function(){
            dispatch({
                type:'ADD_TODO',
                data
            })
        },3000)
    }
}
</code></pre></div><p><strong>异步action的实现方式二：promise实现异步action</strong></p> <blockquote><div class="language- extra-class"><pre class="language-text"><code>redux-promise`中间处理这种`action
</code></pre></div></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function promiseAction(name){
    return new Promise((resolve,reject) =&gt; {
        setTimeout((param)=&gt;{
            resolve({
                type:'ADD_TODO',
                name
            })
        },3000)
    }).then((param)=&gt;{
        dispatch(action("action2"))
        return;
    }).then((param)=&gt;{
        dispatch(action("action3"))
    })
}
</code></pre></div><h2 id="三、redux异步流程"><a href="#三、redux异步流程" class="header-anchor">#</a> 三、redux异步流程</h2> <p><img alt="img" src="https://s.poetries.top/gitee/2019/10/492.png"></p> <ul><li>首先发起一个action，然后通过中间件，这里为什么要用中间件呢，因为这样<code>dispatch</code>的返回值才能是一个函数。</li> <li>通过<code>store.dispatch</code>，将状态的的改变传给<code>store</code>的小弟<code>reducer</code>，<code>reducer</code>根据<code>action</code>的改变，传递新的状态<code>state</code>。</li> <li>最后将所有的改变告诉给它的大哥，<code>store</code>。<code>store</code>保存着所有的数据，并将数据注入到组件的顶部，这样组件就可以获得它需要的数据了</li></ul> <h2 id="四、redux异步方案选型"><a href="#四、redux异步方案选型" class="header-anchor">#</a> 四、Redux异步方案选型</h2> <p><strong>redux-thunk</strong></p> <blockquote><p><code>Redux</code>本身只能处理同步的<code>Action</code>，但可以通过中间件来拦截处理其它类型的<code>action</code>，比如函数(<code>Thunk</code>)，再用回调触发普通<code>Action</code>，从而实现异步处理</p></blockquote> <ul><li>发送异步的<code>action</code>其实是被中间件捕获的，函数类型的action就被<code>middleware</code>捕获。至于怎么定义异步的<code>action</code>要看你用哪个中间件，根据他们的实例来定义，这样才会正确解析<code>action</code></li></ul> <blockquote><p><code>Redux</code> 本身不处理异步行为，需要依赖中间件。结合 <code>redux-actions</code> 使用，<code>Redux</code> 有两个推荐的异步中间件</p></blockquote> <ul><li><code>redux-thunk</code></li> <li><code>redux-promise</code></li></ul> <blockquote><p><code>redux-thunk</code> 的源码如下</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {
    if (typeof action === 'function') {
      return action(dispatch, getState, extraArgument);
    }

    return next(action);
  };
}

const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

export default thunk;
</code></pre></div><blockquote><p>源码可知，<code>action creator</code> 需要返回一个函数给 <code>redux-thunk</code> 进行调用，示例如下</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>export let addTodoWithThunk = (val) =&gt; async (dispatch, getState)=&gt;{
    //请求之前的一些处理

    let value = await Promise.resolve(val + ' thunk');
    dispatch({
        type:CONSTANT.ADD_TO_DO_THUNK,
        payload:{
            value
        }
    });
};
</code></pre></div><ul><li>而它使用起来最大的问题，就是重复的模板代码太多</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//action types
const GET_DATA = 'GET_DATA',
    GET_DATA_SUCCESS = 'GET_DATA_SUCCESS',
    GET_DATA_FAILED = 'GET_DATA_FAILED';
    
//action creator
const getDataAction = (id) =&gt; (dispatch, getState) =&gt; {
        dispatch({
            type: GET_DATA, 
            payload: id
        })
        api.getData(id) //注：本文所有示例的api.getData都返回promise对象
            .then(response =&gt; {
                dispatch({
                    type: GET_DATA_SUCCESS,
                    payload: response
                })
            })
            .catch(error =&gt; {
                dispatch({
                    type: GET_DATA_FAILED,
                    payload: error
                })
            }) 
    }
}

//reducer
const reducer = (oldState, action) =&gt; {
    switch(action.type) {
    case GET_DATA : 
        return oldState;
    case GET_DATA_SUCCESS : 
        return successState;
    case GET_DATA_FAILED : 
        return errorState;
    }
}
</code></pre></div><blockquote><p>这已经是最简单的场景了，请注意：我们甚至还没写一行业务逻辑，如果每个异步处理都像这样，重复且无意义的工作会变成明显的阻碍</p></blockquote> <ul><li>另一方面，像<code>GET_DATA_SUCCESS</code>、<code>GET_DATA_FAILED</code>这样的字符串声明也非常无趣且易错
上例中，<code>GET_DATA</code>这个<code>action</code>并不是多数场景需要的</li></ul> <p><strong>redux-promise</strong></p> <blockquote><p>由于<code>redux-thunk</code>写起来实在是太麻烦了，社区当然会有其它轮子出现。<code>redux-promise</code>则是其中比较知名的</p></blockquote> <ul><li><p>它自定义了一个</p> <div class="language- extra-class"><pre class="language-text"><code>middleware
</code></pre></div><p>，当检测到有</p> <div class="language- extra-class"><pre class="language-text"><code>action
</code></pre></div><p>的</p> <div class="language- extra-class"><pre class="language-text"><code>payload
</code></pre></div><p>属性是</p> <div class="language- extra-class"><pre class="language-text"><code>Promise
</code></pre></div><p>对象时，就会</p> <ul><li>若<code>resolve</code>，触发一个此<code>action</code>的拷贝，但<code>payload</code>为<code>promise</code>的<code>value</code>，并设<code>status</code>属性为<code>"success"</code></li> <li>若<code>reject</code>，触发一个此<code>action</code>的拷贝，但<code>payload</code>为<code>promise</code>的<code>reason</code>，并设<code>status</code>属性为<code>"error"</code></li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>//action types
const GET_DATA = 'GET_DATA';

//action creator
const getData = function(id) {
    return {
        type: GET_DATA,
        payload: api.getData(id) //payload为promise对象
    }
}

//reducer
function reducer(oldState, action) {
    switch(action.type) {
        case GET_DATA: 
            if (action.status === 'success') {
                return successState
            } else {
                   return errorState
            }
        }
}
</code></pre></div><blockquote><p><code>redux-promise</code>为了精简而做出的妥协非常明显：无法处理乐观更新</p></blockquote> <p><strong>场景解析之：乐观更新</strong></p> <blockquote><p>多数异步场景都是悲观更新的，即等到请求成功才渲染数据。而与之相对的乐观更新，则是不等待请求成功，在发送请求的同时立即渲染数据</p></blockquote> <ul><li>由于乐观更新发生在用户操作时，要处理它，意味着必须有action表示用户的初始动作</li> <li>在上面<code>redux-thunk</code>的例子中，我们看到了<code>GET_DATA</code>, <code>GET_DATA_SUCCESS</code>、<code>GET_DATA_FAILED</code>三个<code>action</code>，分别表示初始动作、异步成功和异步失败，其中第一个<code>action</code>使得<code>redux-thunk</code>具备乐观更新的能力</li> <li>而在<code>redux-promise</code>中，最初触发的action被中间件拦截然后过滤掉了。原因很简单，<code>redux</code>认可的<code>action</code>对象是 <code>plain JavaScript objects</code>，即简单对象，而在<code>redux-promise</code>中，初始<code>action</code>的<code>payload</code>是个<code>Promise</code></li></ul> <p><strong>redux-promise-middleware</strong></p> <blockquote><div class="language- extra-class"><pre class="language-text"><code>redux-promise-middleware`相比`redux-promise`，采取了更为温和和渐进式的思路，保留了和`redux-thunk`类似的三个`action
</code></pre></div></blockquote> <div class="language- extra-class"><pre class="language-text"><code>//action types
const GET_DATA = 'GET_DATA',
    GET_DATA_PENDING = 'GET_DATA_PENDING',
    GET_DATA_FULFILLED = 'GET_DATA_FULFILLED',
    GET_DATA_REJECTED = 'GET_DATA_REJECTED';
    
//action creator
const getData = function(id) {
    return {
        type: GET_DATA,
        payload: {
            promise: api.getData(id),
            data: id
        }
    }
}

//reducer
const reducer = function(oldState, action) {
    switch(action.type) {
    case GET_DATA_PENDING :
        return oldState; // 可通过action.payload.data获取id
    case GET_DATA_FULFILLED : 
        return successState;
    case GET_DATA_REJECTED : 
        return errorState;
    }
}
</code></pre></div><h2 id="五、redux异步操作代码演示"><a href="#五、redux异步操作代码演示" class="header-anchor">#</a> 五、redux异步操作代码演示</h2> <ul><li>根据官网的async例子分析 https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async</li></ul> <p><strong>action/index.js</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import fetch from 'isomorphic-fetch'
export const RECEIVE_POSTS = 'RECEIVE_POSTS'

//获取新闻成功的action
function receivePosts(reddit, json) {
  return {
    type: RECEIVE_POSTS,
    reddit: reddit,
    posts: json.data.children.map(child =&gt;child.data)
  }
}

function fetchPosts(subreddit) {

  return function (dispatch) {
    
    return fetch(`http://www.subreddit.com/r/${subreddit}.json`)
      .then(response =&gt; response.json())
      .then(json =&gt;
        dispatch(receivePosts(subreddit, json))
      )
  }
}

//如果需要则开始获取文章
export function fetchPostsIfNeeded(subreddit) {

  return (dispatch, getState) =&gt; {

      return dispatch(fetchPosts(subreddit))

    }
}
</code></pre></div><blockquote><p><code>fetchPostsIfNeeded</code>这里就是一个中间件。<code>redux-thunk</code>会拦截<code>fetchPostsIfNeeded</code>这个<code>action</code>，会先发起数据请求，如果成功，就将数据传给<code>action</code>从而到达<code>reducer</code>那里</p></blockquote> <p><strong>reducers/index.js</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import { combineReducers } from 'redux'
import {
  RECEIVE_POSTS
} from '../actions'


function posts(state = {
  items: []
}, action) {
  switch (action.type) {

    case RECEIVE_POSTS:
      // Object.assign是ES6的一个语法。合并对象，将对象合并为一个，前后相同的话，后者覆盖强者。详情可以看这里
      //  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
      return Object.assign({}, state, {
        items: action.posts //数据都存在了这里
      })
    default:
      return state
  }
}


// 将所有的reducer结合为一个,传给store
const rootReducer = combineReducers({
  postsByReddit
})

export default rootReducer
</code></pre></div><blockquote><p>这个跟正常的<code>reducer</code>差不多。判断<code>action</code>的类型，从而根据<code>action</code>的不同类型，返回不同的数据。这里将数据存储在了<code>items</code>这里。这里的<code>reducer</code>只有一个。最后结合成<code>rootReducer</code>,传给<code>store</code></p></blockquote> <p><strong>store/configureStore.js</strong></p> <div class="language- extra-class"><pre class="language-text"><code>import { createStore, applyMiddleware } from 'redux'
import thunkMiddleware from 'redux-thunk'
import createLogger from 'redux-logger'
import rootReducer from '../reducers'

const createStoreWithMiddleware = applyMiddleware(
  thunkMiddleware,  
  createLogger()  
)(createStore)

export default function configureStore(initialState) {
  const store = createStoreWithMiddleware(rootReducer, initialState)

  if (module.hot) {
    // Enable Webpack hot module replacement for reducers
    module.hot.accept('../reducers', () =&gt; {
      const nextRootReducer = require('../reducers')
      store.replaceReducer(nextRootReducer)
    })
  }

  return store
}
</code></pre></div><ul><li>我们是如何在 <code>dispatch</code> 机制中引入 <code>Redux Thunk middleware</code> 的呢？
我们使用了<code>applyMiddleware()</code></li> <li>通过使用指定的 <code>middleware</code>，<code>action creator</code> 除了返回 <code>action</code> 对象外还可以返回函数</li> <li>这时，这个 <code>action creator</code> 就成为了 <code>thunk</code></li></ul> <p><strong>界面上的调用：在containers/App.js</strong></p> <div class="language- extra-class"><pre class="language-text"><code>//初始化渲染后触发
  componentDidMount() {
    const { dispatch} = this.props
    // 这里可以传两个值，一个是 reactjs 一个是 frontend
    dispatch(fetchPostsIfNeeded('frontend'))
  }
</code></pre></div><blockquote><p>改变状态的时候也是需要通过<code>dispatch</code>来传递的</p></blockquote> <ul><li>数据的获取是通过<code>provider</code>,将<code>store</code>里面的数据注入给组件。让顶级组件提供给他们的子孙组件调用。代码如下：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import 'babel-core/polyfill'
import React from 'react'
import { render } from 'react-dom'
import { Provider } from 'react-redux'
import App from './containers/App'
import configureStore from './store/configureStore'
const store = configureStore()
render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById('root')
)
</code></pre></div><blockquote><p>这样就完成了<code>redux</code>的异步操作。其实最主要的区别还是<code>action</code>里面还有中间件的调用，其他的地方基本跟同步的<code>redux</code>差不多的。搞懂了中间件，就基本搞懂了<code>redux</code>的异步操作</p></blockquote> <p><img alt="img" src="https://s.poetries.top/gitee/2019/10/493.png"></p></div> <!----> <div class="readMore-wrapper"><span class="readMore">阅读全文</span></div>
                    </div>
                            <p>这是一个信息提示框。</p>
                        </div>

                        <div class="note warning">
                            <div class="note-title"><i class="fas fa-exclamation-triangle"></i> 注意</div>
                            <p>这是一个警告提示框。</p>
                        </div>

                        <div class="note success">
                            <div class="note-title"><i class="fas fa-check-circle"></i> 成功</div>
                            <p>这是一个成功提示框。</p>
                        </div>

                        <h2>代码示例</h2>
                        <pre><code class="language-javascript">// 示例代码
function example() {
    console.log('Hello, FrontendHub!');
}
</code></pre>
                    </div>

                    <!-- 文章底部导航 -->
                    <nav class="article-nav">
                        <a href="#" class="prev-article">
                            <i class="fas fa-chevron-left"></i>
                            <span>上一篇</span>
                        </a>
                        <a href="#" class="next-article">
                            <span>下一篇</span>
                            <i class="fas fa-chevron-right"></i>
                        </a>
                    </nav>
                </article>
            </div>
        </div>
    </main>

    <!-- 页脚 -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4><i class="fas fa-code"></i> FrontendHub</h4>
                    <p>专注于前端技术学习与面试准备</p>
                </div>
                <div class="footer-section">
                    <h4>快速链接</h4>
                    <ul>
                        <li><a href="../../index.html">首页</a></li>
                        <li><a href="../index.html#courses">课程体系</a></li>
                        <li><a href="../index.html#resources">学习资源</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 FrontendHub. 用于个人学习使用.</p>
            </div>
        </div>
    </footer>

    <!-- 返回顶部按钮 -->
    <button class="back-to-top" id="backToTop">
        <i class="fas fa-arrow-up"></i>
    </button>

    <script src="../../js/main.js"></script>
    <script src="../../js/content.js"></script>
</body>
</html>

