<!-- Section: # 七、React -->
<div class="section-content" data-section-id="七、react">
<h2 id="七、react"><a href="#七、react" class="header-anchor">#</a> 七、React</h2>
<h3 id="_0-对虚拟dom的理解"><a href="#_0-对虚拟dom的理解" class="header-anchor">#</a> 0 对虚拟DOM的理解</h3>
<blockquote><p><code>虚拟dom从来不是用来和直接操作dom对比的</code>，它们俩最终殊途同归。<code>虚拟dom只不过是局部更新的一个环节而已</code>，整个环节的对比对象是全量更新。虚拟dom对于state＝UI的意义是，虚拟dom使diff成为可能（理论上也可以直接用dom对象diff，但是太臃肿），促进了新的开发思想，又不至于性能太差。但是性能再好也不可能好过直接操作dom，人脑连diff都省了。还有一个很重要的意义是，<code>对视图抽象，为跨平台助力</code></p></blockquote>
<p>其实我最终希望你明白的事情只有一件：<code>虚拟 DOM 的价值不在性能，而在别处</code>。因此想要从性能角度来把握虚拟 DOM 的优势，无异于南辕北辙。偏偏在面试场景下，10 个人里面有 9 个都走这条歧路，最后9个人里面自然没有一个能自圆其说，实在让人惋惜。</p>
<p><a href="http://interview.poetries.top/principle-docs/react/15-%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM.html" target="_blank" rel="noopener noreferrer">真正理解虚拟DOM<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p>
<h3 id="_1-谈谈你对react的理解"><a href="#_1-谈谈你对react的理解" class="header-anchor">#</a> 1 谈谈你对React的理解</h3>
<blockquote><p>React 是一个网页 UI 框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架。</p></blockquote>
<ul><li>它的核心设计思路有三点，分别是<code>声明式、组件化与 通用性</code>。</li> <li>声明式的优势在于直观与组合。</li> <li>组件化的优势在于视图的拆分与模块复用，可以更容易做到高内聚低耦合。</li> <li>通用性在于一次学习，随处编写。比如 React Native，React 360 等， 这里主要靠虚拟 DOM 来保证实现。</li> <li>这使得 React 的适用范围变得足够广，无论是 Web、Native、VR，甚至 Shell 应用都可以进行开发。这也是 React 的优势。</li> <li>但作为一个视图层的框架，React 的劣势也十分明显。它并没有提供完整的一揽子解决方 案，在开发大型前端应用时，需要向社区寻找并整合解决方案。虽然一定程度上促进了社区的繁荣，但也为开发者在技术选型和学习适用上造成了一定的成本。</li> <li>承接在优势后，可以再谈一下自己对于 React 优化的看法、对虚拟 DOM 的看法</li></ul>
<h3 id="_2-如何避免react生命周期中的坑"><a href="#_2-如何避免react生命周期中的坑" class="header-anchor">#</a> 2 如何避免React生命周期中的坑</h3>
<p><strong>16.3版本</strong></p>
<p><img alt="" src="https://s.poetries.top/images/20210409153251.png"></p>
<p><strong>&gt;=16.4版本</strong></p>
<p><img alt="" src="https://s.poetries.top/images/20210409153312.png"></p>
<p><strong>在线查看</strong>：<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram" target="_blank" rel="noopener noreferrer">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p>
<p><img alt="" src="https://s.poetries.top/images/20210425121355.png"></p>
<ul><li>避免生命周期中的坑需要做好两件事：不在恰当的时候调用了不该调用的代码；在需要调用时，不要忘了调用。</li> <li>那么主要有这么 7 种情况容易造成生命周期的坑
<ul><li><code>getDerivedStateFromProps</code> 容易编写反模式代码，使受控组件与非受控组件区分模糊</li> <li><code>componentWillMount</code> 在 React 中已被标记弃用，不推荐使用，主要原因是<code>新的异步渲染架构会导致它被多次调用</code>。所以网络请求及事件绑定代码应移至 <code>componentDidMount</code> 中。</li> <li><code>componentWillReceiveProps</code> 同样被标记弃用，被 <code>getDerivedStateFromProps</code> 所取代，主要原因是性能问题</li> <li><code>shouldComponentUpdate</code> 通过返回 <code>true</code> 或者 <code>false</code> 来确定是否需要触发新的渲染。主要用于性能优化</li> <li><code>componentWillUpdate</code> 同样是由于新的异步渲染机制，而被标记废弃，不推荐使用，原先的逻辑可结合 <code>getSnapshotBeforeUpdate</code> 与 <code>componentDidUpdate</code> 改造使用。</li> <li>如果在 <code>componentWillUnmount</code> 函数中忘记解除事件绑定，取消定时器等清理操作，容易引发 bug</li> <li>如果没有添加错误边界处理，当渲染发生异常时，用户将会看到一个无法操作的白屏，所以一定要添加</li></ul></li></ul>
<p><strong>“React 的请求应该放在哪里，为什么?” 这也是经常会被追问的问题。你可以这样回答。</strong></p>
<p>对于异步请求，应该放在 <code>componentDidMount</code> 中去操作。从时间顺序来看，除了 <code>componentDidMount</code> 还可以有以下选择：</p>
<ul><li>constructor：可以放，但从设计上而言不推荐。constructor 主要用于初始化 state 与函数绑定，并不承载业务逻辑。而且随着类属性的流行，constructor 已经很少使用了</li> <li>componentWillMount：已被标记废弃，在新的异步渲染架构下会触发多次渲染，容易引发 Bug，不利于未来 React 升级后的代码维护。</li> <li>所以React 的请求放在 <code>componentDidMount 里是最好的选择</code>。</li></ul>
<p><strong>透过现象看本质：React 16 缘何两次求变？</strong></p>
<p>Fiber 架构简析</p>
<blockquote><p>Fiber 是 React 16 对 React 核心算法的一次重写。你只需要 get 到这一个点：<code>Fiber 会使原本同步的渲染过程变成异步的</code>。</p></blockquote>
<p>在 React 16 之前，每当我们触发一次组件的更新，React 都会构建一棵新的虚拟 DOM 树，通过与上一次的虚拟 DOM 树进行 diff，实现对 DOM 的定向更新。这个过程，是一个递归的过程。下面这张图形象地展示了这个过程的特征：</p>
<p><img alt="" src="https://s.poetries.top/images/20210426200953.png"></p>
<p>如图所示，<code>同步渲染的递归调用栈是非常深的，只有最底层的调用返回了，整个渲染过程才会开始逐层返回</code>。这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：<code>同步渲染一旦开始，便会牢牢抓住主线程不放，直到递归彻底完成</code>。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。</p>
<p>而 React 16 引入的 Fiber 架构，恰好能够解决掉这个风险：<code>Fiber 会将一个大的更新任务拆解为许多个小任务</code>。<code>每当执行完一个小任务时，渲染线程都会把主线程交回去</code>，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”，它的执行过程如下图所示：</p>
<p><img alt="" src="https://s.poetries.top/images/20210426201045.png"></p>
<p><strong>换个角度看生命周期工作流</strong></p>
<p>Fiber 架构的重要特征就是可以被打断的异步渲染模式。但这个“打断”是有原则的，根据“能否被打断”这一标准，<code>React 16 的生命周期被划分为了 render 和 commit 两个阶段</code>，而 commit 阶段又被细分为了 <code>pre-commit 和 commit</code>。每个阶段所涵盖的生命周期如下图所示：</p>
<p><img alt="" src="https://s.poetries.top/images/20210426201155.png"></p>
<p>我们先来看下三个阶段各自有哪些特征</p>
<ul><li><code>render 阶段</code>：纯净且没有副作用，可能会被 React 暂停、终止或重新启动。</li> <li><code>pre-commit 阶段</code>：可以读取 DOM。</li> <li><code>commit 阶段</code>：可以使用 DOM，运行副作用，安排更新。</li></ul>
<p>总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。</p>
<blockquote><p>为什么这样设计呢？简单来说，<code>由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知</code>。而 <code>commit 阶段的操作则涉及真实 DOM 的渲染</code>，所以<code>这个过程必须用同步渲染来求稳</code>。</p></blockquote>
<p><strong>为什么 React 16 要更改组件的生命周期详解</strong></p>
<blockquote><ul><li><a href="https://interview.poetries.top/principle-docs/react/11-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8A.html" target="_blank" rel="noopener noreferrer">React16为什么要更改生命周期<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://interview.poetries.top/principle-docs/react/12-React16%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9B%B4%E6%94%B9%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8B.html" target="_blank" rel="noopener noreferrer">React16为什么要更改生命周期<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></blockquote>
<h3 id="_3-react-fiber架构"><a href="#_3-react-fiber架构" class="header-anchor">#</a> 3 React Fiber架构</h3>
<p><strong>最主要的思想就是将任务拆分</strong>。</p>
<ul><li>DOM需要渲染时暂停，空闲时恢复。</li> <li><code>window.requestIdleCallback</code></li> <li>React内部实现的机制</li></ul>
<blockquote><p>React 追求的是 “快速响应”，那么，“快速响应“的制约因素都有什么呢</p></blockquote>
<ul><li><code>CPU</code>的瓶颈：当项目变得庞大、组件数量繁多、遇到大计算量的操作或者设备性能不足使得页面掉帧，导致卡顿。</li> <li><code>IO</code>的瓶颈：发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。</li></ul>
<blockquote><p><code>fiber</code> 架构主要就是用来解决 <code>CPU</code> 和网络的问题，这两个问题一直也是最影响前端开发体验的地方，一个会造成卡顿，一个会造成白屏。为此 react 为前端引入了两个新概念：Time Slicing <code>时间分片</code>和<code>Suspense</code>。</p></blockquote>
<p><strong>1. React 都做过哪些优化</strong></p>
<ul><li><strong>React渲染页面的两个阶段</strong> <ul><li>调度阶段（reconciliation）：在这个阶段 React 会更新数据生成新的 <code>Virtual DOM</code>，然后通过<code>Diff</code>算法，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。</li> <li>渲染阶段（commit）：这个阶段 React 会遍历更新队列，将其所有的变更一次性更新到DOM上</li></ul></li> <li><strong>React 15 架构</strong> <ul><li>React15架构可以分为两层
<ul><li>Reconciler（协调器）—— 负责找出变化的组件；</li> <li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上；</li></ul></li></ul></li></ul>
<blockquote><ul><li>在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，递归更新时间超过了16ms，用户交互就会卡顿。</li> <li>为了解决这个问题，React16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。</li></ul></blockquote>
<ul><li><p><strong>React 16 架构</strong></p> <ul><li>为了解决同步更新长时间占用线程导致页面卡顿的问题，也为了探索运行时优化的更多可能，React开始重构并一直持续至今。重构的目标是实现Concurrent Mode（并发模式）。</li> <li>从v15到v16，React团队花了两年时间将源码架构中的Stack Reconciler重构为Fiber Reconciler</li> <li><code>React16架构可以分为三层</code>：
<ul><li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler；</li> <li>Reconciler（协调器）—— 负责找出变化的组件：更新工作从递归变成了可以中断的循环过程。Reconciler内部采用了Fiber的架构；</li> <li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上。</li></ul></li></ul></li> <li><p><strong>React 17 优化</strong></p> <ul><li>使用Lane来管理任务的优先级。Lane用二进制位表示任务的优先级，方便优先级的计算（位运算），不同优先级占用不同位置的“赛道”，而且存在批的概念，优先级越低，“赛道”越多。高优先级打断低优先级，新建的任务需要赋予什么优先级等问题都是Lane所要解决的问题。</li> <li>Concurrent Mode的目的是实现一套可中断/恢复的更新机制。其由两部分组成：
<ul><li>一套协程架构：Fiber Reconciler</li> <li>基于协程架构的启发式更新算法：控制协程架构工作方式的算法</li></ul></li></ul></li></ul>
<p><strong>2. 浏览器一帧都会干些什么以及requestIdleCallback的启示</strong></p>
<blockquote><p>我们都知道，页面的内容都是一帧一帧绘制出来的，浏览器刷新率代表浏览器一秒绘制多少帧。原则上说 1s 内绘制的帧数也多，画面表现就也细腻。目前浏览器大多是 60Hz（60帧/s），每一帧耗时也就是在 16.6ms 左右。那么在这一帧的（16.6ms） 过程中浏览器又干了些什么呢</p></blockquote>
<p><img alt="" src="https://s.poetries.top/images/20210407173320.png"></p>
<p>通过上面这张图可以清楚的知道，浏览器一帧会经过下面这几个过程：</p>
<ol><li>接受输入事件</li> <li>执行事件回调</li> <li>开始一帧</li> <li>执行 RAF (RequestAnimationFrame)</li> <li>页面布局，样式计算</li> <li>绘制渲染</li> <li>执行 RIC (RequestIdelCallback)</li></ol>
<blockquote><p>第七步的 RIC 事件不是每一帧结束都会执行，只有在一帧的 16.6ms 中做完了前面 6 件事儿且还有剩余时间，才会执行。如果一帧执行结束后还有时间执行 RIC 事件，那么下一帧需要在事件执行结束才能继续渲染，所以 RIC 执行不要超过 30ms，如果长时间不将控制权交还给浏览器，会影响下一帧的渲染，导致页面出现卡顿和事件响应不及时。</p></blockquote>
<blockquote><p><code>requestIdleCallback 的启示</code>：我们以浏览器是否有剩余时间作微任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。</p></blockquote>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token function">requestIdleCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">deadline</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
<span class="token comment">// deadline 有两个参数</span>
  <span class="token comment">// timeRemaining(): 当前帧还剩下多少时间</span>
  <span class="token comment">// didTimeout: 是否超时</span>
<span class="token comment">// 另外 requestIdleCallback 后如果跟上第二个参数 {timeout: ...} 则会强制浏览器在当前帧执行完后执行。</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// TODO</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>otherTasks<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 用法示例</span>
<span class="token keyword">var</span> tasksNum <span class="token operator">=</span> <span class="token number">10000</span>

<span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>unImportWork<span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">unImportWork</span><span class="token punctuation">(</span><span class="token parameter">deadline</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> tasksNum <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">执行了</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token number">10000</span> <span class="token operator">-</span> tasksNum <span class="token operator">+</span> <span class="token number">1</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">个任务</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    tasksNum<span class="token operator">--</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tasksNum <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 在未来的帧中继续执行</span>
    <span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>unImportWork<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<blockquote><p>其实部分浏览器已经实现了这个API，这就是requestIdleCallback。但是由于以下因素，Facebook 抛弃了 <code>requestIdleCallback</code>的原生 API：</p></blockquote>
<ul><li>浏览器兼容性；</li> <li>触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的<code>requestIdleCallback</code>触发的频率会变得很低。</li></ul>
<blockquote><p>基于以上原因，在React中实现了功能更完备的<code>requestIdleCallbackpolyfill</code>，这就是<code>Scheduler</code>。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置</p></blockquote>
<p><strong>3. React Fiber是什么</strong></p>
<blockquote><p><code>React Fiber</code>是对核心算法的一次重新实现。<code>React Fiber</code>把更新过程碎片化，把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会</p></blockquote>
<ol><li>在<code>React Fiber</code>中，一次更新过程会分成多个分片完成，所以完全有可能一个更新任务还没有完成，就被另一个更高优先级的更新过程打断，这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来</li> <li>因为一个更新过程可能被打断，所以<code>React Fiber</code>一个更新过程被分为两个阶段(<code>Phase</code>)：第一个阶段<code>Reconciliation Phase</code>和第二阶段<code>Commit Phase</code></li> <li>在第一阶段<code>Reconciliation Phase</code>，<code>React Fiber</code>会找出需要更新哪些<code>DOM</code>，这个阶段是可以被打断的；但是到了第二阶段<code>Commit Phase</code>，那就一鼓作气把<code>DOM</code>更新完，绝不会被打断</li> <li>这两个阶段大部分工作都是<code>React Fiber</code>做，和我们相关的也就是生命周期函数</li></ol>
<blockquote><p><code>React Fiber</code>改变了之前<code>react</code>的组件渲染机制，新的架构使原来同步渲染的组件现在可以异步化，可中途中断渲染，执行更高优先级的任务。释放浏览器主线程</p></blockquote>
<p><strong>关键特性</strong></p>
<ul><li>增量渲染（把渲染任务拆分成块，匀到多帧）</li> <li>更新时能够暂停，终止，复用渲染任务</li> <li>给不同类型的更新赋予优先级</li> <li>并发方面新的基础能力</li></ul>
<blockquote><p>增量渲染用来解决掉帧的问题，渲染任务拆分之后，每次只做一小段，做完一段就把时间控制权交还给主线程，而不像之前长时间占用</p></blockquote>
<p><strong>4. 组件的渲染顺序</strong></p>
<blockquote><p>假如有A,B,C,D组件，层级结构为：</p></blockquote>
<p><img alt="" src="https://s.poetries.top/images/20210407174007.png"></p>
<p>我们知道组件的生命周期为：</p>
<p><strong>挂载阶段</strong>：</p>
<ul><li><code>constructor()</code></li> <li><code>componentWillMount()</code></li> <li><code>render()</code></li> <li><code>componentDidMount()</code></li></ul>
<p><strong>更新阶段为</strong>：</p>
<ul><li><code>componentWillReceiveProps()</code></li> <li><code>shouldComponentUpdate()</code></li> <li><code>componentWillUpdate()</code></li> <li><code>render()</code></li> <li><code>componentDidUpdate</code></li></ul>
<blockquote><p>那么在挂载阶段，<code>A,B,C,D</code>的生命周期渲染顺序是如何的呢？</p></blockquote>
<p>那么在挂载阶段，A,B,C,D的生命周期渲染顺序是如何的呢？</p>
<p><img alt="" src="https://s.poetries.top/images/20210407173933.png"></p>
<blockquote><p>以<code>render()</code>函数为分界线。从顶层组件开始，一直往下，直至最底层子组件。然后再往上</p></blockquote>
<p>组件<code>update</code>阶段同理</p>
<p>前面是<code>react16</code>以前的组建渲染方式。这就存在一个问题</p>
<blockquote><p>如果这是一个很大，层级很深的组件，<code>react</code>渲染它需要几十甚至几百毫秒，在这期间，<code>react</code>会一直占用浏览器主线程，任何其他的操作（包括用户的点击，鼠标移动等操作）都无法执行</p></blockquote>
<p><strong>Fiber架构就是为了解决这个问题</strong></p>
<blockquote><p>看一下fiber架构 组建的渲染顺序</p></blockquote>
<p><img alt="" src="https://s.poetries.top/images/20210407173949.png"></p>
<blockquote><p>加入<code>fiber</code>的<code>react</code>将组件更新分为两个时期</p></blockquote>
<p><strong>这两个时期以render为分界</strong></p>
<ul><li><code>render</code>前的生命周期为<code>phase1</code>,</li> <li><code>render</code>后的生命周期为<code>phase2</code></li></ul>
<blockquote><ul><li><code>phase1</code>的生命周期是可以被打断的，每隔一段时间它会跳出当前渲染进程，去确定是否有其他更重要的任务。此过程，<code>React</code>在 <code>workingProgressTree</code> （并不是真实的<code>virtualDomTree</code>）上复用 <code>current</code> 上的 <code>Fiber</code> 数据结构来一步地（通过<code>requestIdleCallback</code>）来构建新的 tree，标记处需要更新的节点，放入队列中</li> <li><code>phase2</code>的生命周期是不可被打断的，<code>React</code> 将其所有的变更一次性更新到<code>DOM</code>上</li></ul></blockquote>
<p><strong>这里最重要的是phase1这是时期所做的事。因此我们需要具体了解phase1的机制</strong></p>
<ul><li>如果不被打断，那么<code>phase1</code>执行完会直接进入<code>render</code>函数，构建真实的<code>virtualDomTree</code></li> <li>如果组件再<code>phase1</code>过程中被打断，即当前组件只渲染到一半（也许是在<code>willMount</code>,也许是<code>willUpdate</code>~反正是在render之前的生命周期），那么<code>react</code>会怎么干呢？ <code>react</code>会放弃当前组件所有干到一半的事情，去做更高优先级更重要的任务（当然，也可能是用户鼠标移动，或者其他react监听之外的任务），当所有高优先级任务执行完之后，<code>react</code>通过<code>callback</code>回到之前渲染到一半的组件，从头开始渲染。（看起来放弃已经渲染完的生命周期，会有点不合理，反而会增加渲染时长，但是<code>react</code>确实是这么干的）</li></ul>
<p><strong>所有phase1的生命周期函数都可能被执行多次，因为可能会被打断重来</strong></p>
<blockquote><p>这样的话，就和<code>react16</code>版本之前有很大区别了，因为可能会被执行多次，那么我们最好就得保证<code>phase1</code>的生命周期每一次执行的结果都是一样的，否则就会有问题，因此，最好都是纯函数</p></blockquote>
<ul><li>如果高优先级的任务一直存在，那么低优先级的任务则永远无法进行，组件永远无法继续渲染。这个问题facebook目前好像还没解决</li> <li>所以，facebook在<code>react16</code>增加<code>fiber</code>结构，其实并不是为了减少组件的渲染时间，事实上也并不会减少，最重要的是现在可以使得一些更高优先级的任务，如用户的操作能够优先执行，提高用户的体验，至少用户不会感觉到卡顿</li></ul>
<p><strong>5 React Fiber架构总结</strong></p>
<p><strong>React Fiber如何性能优化</strong></p>
<ul><li><strong>更新的两个阶段</strong> <ul><li>调度算法阶段-执行diff算法，纯js计算</li> <li>Commit阶段-将diff结果渲染dom</li></ul></li> <li>可能会有性能问题
<ul><li>JS是单线程的，且和DOM渲染公用一个线程</li> <li>当组件足够复杂，组件更新时计算和渲染压力都大</li> <li>同时再有DOM操作需求（动画、鼠标拖拽等），将卡顿</li></ul></li> <li><strong>解决方案fiber</strong> <ul><li>将调度算法阶段阶段任务拆分（Commit无法拆分）</li> <li>DOM需要渲染时暂停，空闲时恢复</li> <li><strong>分散执行:</strong> 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新API: <code>requestIdleCallback</code> 与 <code>requestAnimationFrame</code> <ul><li>低优先级的任务交给<code>requestIdleCallback</code>处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 <code>pollyfill</code>，而且拥有 <code>deadline</code> 参数，限制执行事件，以继续切分任务；</li> <li>高优先级的任务交给<code>requestAnimationFrame</code>处理；</li></ul></li></ul></li></ul>
<p><strong>React 的核心流程可以分为两个部分:</strong></p>
<ul><li><code>reconciliation</code> (调度算法，也可称为 <code>render</code>)
<ul><li>更新 <code>state</code> 与 <code>props</code>；</li> <li>调用生命周期钩子；</li> <li>生成 <code>virtual dom</code> <ul><li>这里应该称为 <code>Fiber Tree</code> 更为符合；</li></ul></li> <li>通过新旧 vdom 进行 diff 算法，获取 vdom change</li> <li>确定是否需要重新渲染</li></ul></li> <li><code>commit</code> <ul><li>如需要，则操作 <code>dom</code> 节点更新</li></ul></li></ul>
<blockquote><p>要了解 Fiber，我们首先来看为什么需要它</p></blockquote>
<ul><li><strong>问题</strong>: 随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 同步阻塞。在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用 同步递归 的方式进行遍历渲染，而这个过程最大的问题就是无法 暂停和恢复。</li> <li><strong>解决方</strong>案: 解决同步阻塞的方法，通常有两种: 异步 与 任务分割。而 React Fiber 便是为了实现任务分割而诞生的</li> <li><strong>简述</strong> <ul><li>在 <code>React V16</code> 将调度算法进行了重构， 将之前的 <code>stack reconciler</code> 重构成新版的 fiber <code>reconciler</code>，变成了具有链表和指针的 单链表树遍历算法。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启</li> <li>这里我理解为是一种 任务分割调度算法，主要是 将原先同步更新渲染的任务分割成一个个独立的 小任务单位，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制</li></ul></li> <li><strong>核心</strong> <ul><li><code>Fiber</code> 这里可以具象为一个 数据结构</li></ul></li></ul>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Fiber</span> <span class="token punctuation">{</span>
	<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">instance</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> instance
		<span class="token comment">// 指向第一个 child 节点</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> child
		<span class="token comment">// 指向父节点</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> parent
		<span class="token comment">// 指向第一个兄弟节点</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> previous
	<span class="token punctuation">}</span>	
<span class="token punctuation">}</span>
</code></pre></div>
<ul><li><strong>链表树遍历算法</strong>: 通过 节点保存与映射，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提
<ul><li>首先通过不断遍历子节点，到树末尾；</li> <li>开始通过 <code>sibling</code> 遍历兄弟节点；</li> <li>return 返回父节点，继续执行2；</li> <li>直到 root 节点后，跳出遍历；</li></ul></li> <li><strong>任务分割</strong>，React 中的渲染更新可以分成两个阶段
<ul><li><strong>reconciliation 阶段</strong>: vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对</li> <li><strong>Commit 阶段</strong>: 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。否则可能由于阻塞 UI 更新，而导致数据更新和 UI 不一致的情况</li></ul></li> <li><strong>分散执行:</strong> 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新API: <code>requestIdleCallback</code> 与 <code>requestAnimationFrame</code> <ul><li>低优先级的任务交给<code>requestIdleCallback</code>处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 <code>pollyfill</code>，而且拥有 <code>deadline</code> 参数，限制执行事件，以继续切分任务；</li> <li>高优先级的任务交给<code>requestAnimationFrame</code>处理；</li></ul></li></ul>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 类似于这样的方式</span>
<span class="token function">requestIdleCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">deadline</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当有空闲时间时，我们执行一个组件渲染；</span>
    <span class="token comment">// 把任务塞到一个个碎片时间中去；</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> deadline<span class="token punctuation">.</span>didTimeout<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nextComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nextComponent <span class="token operator">=</span> <span class="token function">performWork</span><span class="token punctuation">(</span>nextComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<ul><li><strong>优先级策略:</strong> 文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</li></ul>
<blockquote><ul><li>Fiber 其实可以算是一种编程思想，在其它语言中也有许多应用(Ruby Fiber)。</li> <li>核心思想是 任务拆分和协同，主动把执行权交给主线程，使主线程有时间空挡处理其他高优先级任务。</li> <li>当遇到进程阻塞的问题时，任务分割、异步调用 和 缓存策略 是三个显著的解决思路。</li></ul></blockquote>
<h3 id="_4-createelement过程"><a href="#_4-createelement过程" class="header-anchor">#</a> 4 createElement过程</h3>
<blockquote><p>React.createElement()： 根据指定的第一个参数创建一个React元素</p></blockquote>
<div class="language-js extra-class"><pre class="language-js"><code>React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>
  type<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>props<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token operator">...</span>children<span class="token punctuation">]</span>
<span class="token punctuation">)</span>
</code></pre></div>
<ul><li>第一个参数是必填，传入的是似HTML标签名称，eg: ul, li</li> <li>第二个参数是选填，表示的是属性，eg: className</li> <li>第三个参数是选填, 子节点，eg: 要显示的文本内容</li></ul>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//写法一：</span>

<span class="token keyword">var</span> child1 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'one'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> child2 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> content <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">className</span><span class="token operator">:</span> <span class="token string">'teststyle'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> child1<span class="token punctuation">,</span> child2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第三个参数可以分开也可以写成一个数组</span>
      ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
          content<span class="token punctuation">,</span>
        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//写法二：</span>

<span class="token keyword">var</span> child1 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'one'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> child2 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> content <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">className</span><span class="token operator">:</span> <span class="token string">'teststyle'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>child1<span class="token punctuation">,</span> child2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
          content<span class="token punctuation">,</span>
        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<h3 id="_5-调和阶段-setstate内部干了什么"><a href="#_5-调和阶段-setstate内部干了什么" class="header-anchor">#</a> 5 调和阶段 setState内部干了什么</h3>
<ul><li>当调用 setState 时，React会做的第一件事情是将传递给 setState 的对象合并到组件的当前状态</li> <li>这将启动一个称为和解（<code>reconciliation</code>）的过程。和解（<code>reconciliation</code>）的最终目标是以最有效的方式，根据这个新的状态来更新<code>UI</code>。 为此，<code>React</code>将构建一个新的 <code>React</code> 元素树（您可以将其视为 <code>UI</code> 的对象表示）</li> <li>一旦有了这个树，为了弄清 UI 如何响应新的状态而改变，React 会将这个新树与上一个元素树相比较（ diff ）</li></ul>
<blockquote><p>通过这样做， React 将会知道发生的确切变化，并且通过了解发生什么变化，只需在绝对必要的情况下进行更新即可最小化 UI 的占用空间</p></blockquote>
<h3 id="_6-setstate"><a href="#_6-setstate" class="header-anchor">#</a> 6 setState</h3>
<blockquote><p>在了解setState之前，我们先来简单了解下 React 一个包装结构: Transaction:</p></blockquote>
<p><strong>事务 (Transaction)</strong></p>
<blockquote><p>是 React 中的一个调用结构，用于包装一个方法，结构为: initialize - perform(method) - close。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作</p></blockquote>
<ul><li>setState: React 中用于修改状态，更新视图。它具有以下特点:</li></ul>
<p><strong>异步与同步:</strong> setState并不是单纯的异步或同步，这其实与调用时的环境相关:</p>
<ul><li>在<strong>合成事件</strong> 和 <strong>生命周期钩子</strong>(除 componentDidUpdate) 中，setState是"异步"的；
<ul><li>原因: 因为在setState的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入dirtyComponents队列中等待执行；否则，开始执行batchedUpdates队列更新；
<ul><li>在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；</li> <li>在合成事件中，React 是基于 事务流完成的事件委托机制 实现，也是处于事务流中；</li></ul></li> <li>问题: 无法在setState后马上从this.state上获取更新后的值。</li> <li>解决: 如果需要马上同步去获取新值，setState其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值；</li></ul></li> <li>在 <strong>原生事件</strong> 和 setTimeout 中，setState是同步的，可以马上获取更新后的值；
<ul><li>原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而setTimeout是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；</li></ul></li> <li><strong>批量更新</strong>: 在 合成事件 和 生命周期钩子 中，setState更新队列时，存储的是 合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新；</li> <li><strong>函数式</strong>: 由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在fn中返回新的state对象即可，例如this.setState((state, props) =&gt; newState)；
<ul><li>使用函数式，可以用于避免setState的批量更新的逻辑，传入的函数将会被 顺序调用；</li></ul></li></ul>
<p><strong>注意事项:</strong></p>
<ul><li>setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次；</li> <li>当组件已被销毁，如果再次调用setState，React 会报错警告，通常有两种解决办法
<ul><li>将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中；</li> <li>在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount中标记为 true，在setState前进行判断；</li></ul></li></ul>
<p><strong>总结</strong></p>
<blockquote><p>setState 并非真异步，只是看上去像异步。在源码中，通过 <code>isBatchingUpdates</code> 来判断</p></blockquote>
<ul><li><code>setState</code> 是先存进 <code>state</code> 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。</li> <li>那么什么情况下 <code>isBatchingUpdates</code> 会为 <code>true</code> 呢？在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。</li> <li>但在 React 无法控制的地方，比如原生事件，具体就是在 <code>addEventListener</code>&nbsp;、<code>setTimeout</code>、<code>setInterval</code> 等事件中，就只能同步更新。</li></ul>
<blockquote><p>一般认为，<code>做异步设计是为了性能优化、减少渲染次数</code>，React 团队还补充了两点。</p></blockquote>
<ul><li>保持内部一致性。如果将 state 改为同步更新，那尽管 state 的更新是同步的，但是 props不是。</li> <li>启用并发更新，完成异步渲染。</li></ul>
<p><img alt="" src="https://s.poetries.top/images/20210425140749.png"></p>
<ol><li><code>setState</code> 只有在 React 自身的合成事件和钩子函数中是异步的，在原生事件和 setTimeout 中都是同步的</li> <li><code>setState</code> 的异步并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的异步。当然可以通过 setState 的第二个参数中的 callback 拿到更新后的结果</li> <li><code>setState</code> 的批量更新优化也是建立在异步（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在异步中如果对同一个值进行多次 setState，setState 的批量更新策略会对其进行覆盖，去最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新</li></ol>
<ul><li>合成事件中是异步</li> <li>钩子函数中的是异步</li> <li>原生事件中是同步</li> <li>setTimeout中是同步</li></ul>
<p><img alt="" src="https://s.poetries.top/images/20210409153900.png"> <img alt="" src="https://s.poetries.top/images/20210409153914.png"> <img alt="" src="https://s.poetries.top/images/20210409153926.png"> <img alt="" src="https://s.poetries.top/images/20210409153942.png"> <img alt="" src="https://s.poetries.top/images/20210409154004.png"> <img alt="" src="https://s.poetries.top/images/20210409154015.png"></p>
<p><strong>这是一道经常会出现的 React setState 笔试题：下面的代码输出什么呢？</strong></p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  state  <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div>
<p>我们可以进行如下的分析：</p>
<ul><li>首先第一次和第二次的 <code>console.log</code>，都在 React 的生命周期事件中，所以是异步的处理方式，则输出都为 <code>0</code>；</li> <li>而在 <code>setTimeout</code> 中的 <code>console.log</code> 处于原生事件中，所以会同步的处理再输出结果，但需要注意，虽然 <code>count</code> 在前面经过了两次的 <code>this.state.count + 1</code>，但是每次获取的 <code>this.state.count</code> 都是初始化时的值，也就是 <code>0</code>；</li> <li>所以此时 <code>count</code> 是 <code>1</code>，那么后续在 <code>setTimeout</code>中的输出则是 <code>2</code> 和 <code>3</code>。</li></ul>
<p>所以完整答案是 <code>0,0,2,3</code></p>
<p><strong>同步场景</strong></p>
<p>异步场景中的案例使我们建立了这样一个认知：setState 是异步的，但下面这个案例又会颠覆你的认知。如果我们将 setState 放在 setTimeout 事件中，那情况就完全不同了。</p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
    state <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>

    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"setTimeout: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token operator">...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>那这时输出的应该是什么呢？如果你认为是 0,0，那么又错了。</p>
<p>正确的结果是 <code>0,2</code>。因为 <code>setState</code> 并不是真正的异步函数，它实际上是通过队列延迟执行操作实现的，通过 isBatchingUpdates 来判断 setState 是先存进 state 队列还是直接更新。值为 true 则执行异步操作，false 则直接同步更新</p>
<p><strong>接下来这个案例的答案是什么呢</strong></p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
    state <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>

    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
           <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>
         <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
         <span class="token punctuation">}</span><span class="token punctuation">)</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
           <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>
         <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
         <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token operator">...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>如果你觉得答案是 <code>1,2</code>，那肯定就错了。这种迷惑性极强的考题在面试中非常常见，因为它反直觉。</p>
<p>如果重新仔细思考，你会发现当前拿到的 <code>this.state.count</code> 的值并没有变化，都是 <code>0</code>，所以输出结果应该是 <code>1,1</code>。</p>
<p>当然，也可以在 <code>setState</code> 函数中获取修改后的 <code>state</code> 值进行修改。</p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
    state <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>

    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>
          <span class="token parameter">preState</span><span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
            <span class="token literal-property property">count</span><span class="token operator">:</span>preState<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>
          <span class="token parameter">preState</span><span class="token operator">=&gt;</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            <span class="token literal-property property">count</span><span class="token operator">:</span>preState<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token operator">...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>这些通通是异步的回调，如果你以为输出结果是 1,2，那就又错了，<code>实际上是 2,2</code>。</p>
<p>为什么会这样呢？当调用 <code>setState</code> 函数时，就会<code>把当前的操作放入队列中</code>。React 根据队列内容，合并 state 数据，完成后再逐一执行回调，根据结果更新虚拟 DOM，触发渲染。所以<code>回调时，state 已经合并计算完成了</code>，输出的结果就是 <code>2,2</code> 了。</p>
<h3 id="_7-setstate原理分析"><a href="#_7-setstate原理分析" class="header-anchor">#</a> 7 setState原理分析</h3>
<p><strong>1. setState异步更新</strong></p>
<ul><li>我们都知道，<code>React</code>通过<code>this.state</code>来访问<code>state</code>，通过<code>this.setState()</code>方法来更新<code>state</code>。当<code>this.setState()</code>方法被调用的时候，<code>React</code>会重新调用<code>render</code>方法来重新渲染<code>UI</code></li> <li>首先如果直接在<code>setState</code>后面获取<code>state</code>的值是获取不到的。在<code>React</code>内部机制能检测到的地方， <code>setState</code>就是异步的；<code>在React</code>检测不到的地方，例如<code>setInterval</code>,<code>setTimeout</code>，<code>setState</code>就是同步更新的</li></ul>
<p><img alt="img" src="https://s.poetries.top/gitee/2019/10/431.png"></p>
<blockquote><p>因为<code>setState</code>是可以接受两个参数的，一个<code>state</code>，一个回调函数。因此我们可以在回调函数里面获取值</p></blockquote>
<p><img alt="img" src="https://s.poetries.top/gitee/2019/10/432.png"></p>
<ul><li><code>setState</code>方法通过一个队列机制实现<code>state</code>更新，当执行<code>setState</code>的时候，会将需要更新的<code>state</code>合并之后放入状态队列，而不会立即更新<code>this.state</code></li> <li>如果我们不使用<code>setState</code>而是使用<code>this.state.key</code>来修改，将不会触发组件的<code>re-render</code>。</li> <li>如果将<code>this.state</code>赋值给一个新的对象引用，那么其他不在对象上的<code>state</code>将不会被放入状态队列中，当下次调用<code>setState</code>并对状态队列进行合并时，直接造成了<code>state</code>丢失</li></ul>
<p><strong>1.1 setState批量更新的过程</strong></p>
<blockquote><p>在<code>react</code>生命周期和合成事件执行前后都有相应的钩子，分别是<code>pre</code>钩子和<code>post</code>钩子，<code>pre</code>钩子会调用<code>batchedUpdate</code>方法将<code>isBatchingUpdates</code>变量置为<code>true</code>，开启批量更新，而<code>post</code>钩子会将<code>isBatchingUpdates</code>置为<code>false</code></p></blockquote>
<ul><li><code>isBatchingUpdates</code>变量置为<code>true</code>，则会走批量更新分支，<code>setState</code>的更新会被存入队列中，待同步代码执行完后，再执行队列中的<code>state</code>更新。 <code>isBatchingUpdates</code>为 <code>true</code>，则把当前组件（即调用了 <code>setState</code>的组件）放入 <code>dirtyComponents</code> 数组中；否则 <code>batchUpdate</code> 所有队列中的更新</li> <li>而在原生事件和异步操作中，不会执行<code>pre</code>钩子，或者生命周期的中的异步操作之前执行了<code>pre</code>钩子，但是<code>pos</code>钩子也在异步操作之前执行完了，<code>isBatchingUpdates</code>必定为<code>false</code>，也就不会进行批量更新</li></ul>
<p><img alt="img" src="https://s.poetries.top/gitee/2019/10/434.png"></p>
<blockquote><p><code>enqueueUpdate</code>包含了<code>React</code>避免重复<code>render</code>的逻辑。<code>mountComponent</code>和<code>updateComponent</code>方法在执行的最开始，会调用到<code>batchedUpdates</code>进行批处理更新，此时会将<code>isBatchingUpdates</code>设置为<code>true</code>，也就是将状态标记为现在正处于更新阶段了。 <code>isBatchingUpdates</code>为 <code>true</code>，则把当前组件（即调用了 <code>setState</code> 的组件）放入<code>dirtyComponents</code> 数组中；否则 <code>batchUpdate</code> 所有队列中的更新</p></blockquote>
<p><strong>1.2 为什么直接修改this.state无效</strong></p>
<ul><li>要知道<code>setState</code>本质是通过一个队列机制实现<code>state</code>更新的。 执行<code>setState</code>时，会将需要更新的state合并后放入状态队列，而不会立刻更新<code>state</code>，队列机制可以批量更新<code>state</code>。</li> <li>如果不通过<code>setState</code>而直接修改<code>this.state</code>，那么这个<code>state</code>不会放入状态队列中，下次调用<code>setState</code>时对状态队列进行合并时，会忽略之前直接被修改的<code>state</code>，这样我们就无法合并了，而且实际也没有把你想要的<code>state</code>更新上去</li></ul>
<p><strong>1.3 什么是批量更新 Batch Update</strong></p>
<blockquote><p>在一些<code>mv*</code>框架中，，就是将一段时间内对<code>model</code>的修改批量更新到<code>view</code>的机制。比如那前端比较火的<code>React</code>、<code>vue</code>（<code>nextTick</code>机制,视图的更新以及实现）</p></blockquote>
<p><strong>1.4 setState之后发生的事情</strong></p>
<ul><li><code>setState</code>操作并不保证是同步的，也可以认为是异步的</li> <li><code>React</code>在<code>setState</code>之后，会经对<code>state</code>进行<code>diff</code>，判断是否有改变，然后去<code>diff dom</code>决定是否要更新<code>UI</code>。如果这一系列过程立刻发生在每一个<code>setState</code>之后，就可能会有性能问题</li> <li>在短时间内频繁<code>setState</code>。<code>React</code>会将<code>state</code>的改变压入栈中，在合适的时机，批量更新<code>state</code>和视图，达到提高性能的效果</li></ul>
<p><strong>1.5 如何知道state已经被更新</strong></p>
<blockquote><p>传入回调函数</p></blockquote>
<div class="language- extra-class"><pre class="language-text"><code>setState({
    index: 1
}}, function(){
    console.log(this.state.index);
})
</code></pre></div>
<blockquote><p>在钩子函数中体现</p></blockquote>
<div class="language- extra-class"><pre class="language-text"><code>componentDidUpdate(){
    console.log(this.state.index);
}
</code></pre></div>
<p><strong>2. setState循环调用风险</strong></p>
<ul><li>当调用<code>setState</code>时，实际上会执行<code>enqueueSetState</code>方法，并对<code>partialState</code>以及<code>_pending-StateQueue</code>更新队列进行合并操作，最终通过<code>enqueueUpdate</code>执行<code>state</code>更新</li> <li>而<code>performUpdateIfNecessary</code>方法会获<code>取_pendingElement</code>,<code>_pendingStateQueue</code>，<code>_pending-ForceUpdate</code>，并调用<code>receiveComponent</code>和<code>updateComponent</code>方法进行组件更新</li> <li>如果在<code>shouldComponentUpdate</code>或者<code>componentWillUpdate</code>方法中调用<code>setState</code>，此时<code>this._pending-StateQueue != null</code>，就会造成循环调用，使得浏览器内存占满后崩溃</li></ul>
<p><strong>3 事务</strong></p>
<ul><li>事务就是将需要执行的方法使用<code>wrapper</code>封装起来，再通过事务提供的<code>perform</code>方法执行，先执行<code>wrapper</code>中的<code>initialize</code>方法，执行完<code>perform</code>之后，在执行所有的<code>close</code>方法，一组<code>initialize</code>及<code>close</code>方法称为一个<code>wrapper</code>。</li> <li>那么事务和<code>setState</code>方法的不同表现有什么关系，首先我们把<code>4</code>次<code>setStat</code>e简单归类，前两次属于一类，因为它们在同一调用栈中执行，<code>setTimeout</code>中的两次<code>setState</code>属于另一类</li> <li>在<code>setState</code>调用之前，已经处在<code>batchedUpdates</code>执行的事务中了。那么这次<code>batchedUpdates</code>方法是谁调用的呢，原来是<code>ReactMount.js</code>中的<code>_renderNewRootComponent</code>方法。也就是说，整个将<code>React</code>组件渲染到<code>DOM</code>中的过程就是处于一个大的事务中。而在<code>componentDidMount</code>中调用<code>setState</code>时，<code>batchingStrategy</code>的<code>isBatchingUpdates</code>已经被设为了<code>true</code>，所以两次<code>setState</code>的结果没有立即生效</li> <li>再反观<code>setTimeout</code>中的两次<code>setState</code>，因为没有前置的<code>batchedUpdates</code>调用，所以导致了新的<code>state</code>马上生效</li></ul>
<p><strong>4. 总结</strong></p>
<ul><li>通过<code>setState</code>去更新<code>this.state</code>，不要直接操作<code>this.state</code>，请把它当成不可变的</li> <li>调用<code>setState</code>更新<code>this.state</code>不是马上生效的，它是异步的，所以不要天真以为执行完<code>setState</code>后<code>this.state</code>就是最新的值了</li> <li>多个顺序执行的<code>setState</code>不是同步地一个一个执行滴，会一个一个加入队列，然后最后一起执行，即批处理</li></ul>
<h3 id="_8-react事务机制"><a href="#_8-react事务机制" class="header-anchor">#</a> 8 React事务机制</h3>
<p><img alt="" src="https://s.poetries.top/images/20210409154118.png"> <img alt="" src="https://s.poetries.top/images/20210409154127.png"> <img alt="" src="https://s.poetries.top/images/20210409154136.png"></p>
<h3 id="_9-react组件和渲染更新过程"><a href="#_9-react组件和渲染更新过程" class="header-anchor">#</a> 9 React组件和渲染更新过程</h3>
<p><strong>渲染和更新过程</strong></p>
<ul><li>jsx如何渲染为页面</li> <li>setState之后如何更新页面</li> <li>面试考察全流程</li></ul>
<p><strong>JSX本质和vdom</strong></p>
<ul><li>JSX即<code>createElement</code>函数</li> <li>执行生成vnode</li> <li><code>patch(elem,vnode)</code>和<code>patch(vnode,newNode)</code></li></ul>
<p><strong>组件渲染过程</strong></p>
<ul><li><code>props state</code></li> <li><code>render()</code>生成<code>vnode</code></li> <li><code>patch(elem, vnode)</code></li></ul>
<p><strong>组件更新过程</strong></p>
<ul><li><code>setState--&gt;dirtyComponents</code>(可能有子组件)</li> <li><code>render</code>生成<code>newVnode</code></li> <li><code>patch(vnode, newVnode)</code></li></ul>
<h3 id="_10-如何解释-react-的渲染流程"><a href="#_10-如何解释-react-的渲染流程" class="header-anchor">#</a> 10 如何解释 React 的渲染流程</h3>
<p><img alt="" src="https://s.poetries.top/images/20210425210718.png"></p>
<ul><li>React 的渲染过程大致一致，但协调并不相同，以 <code>React 16</code> 为分界线，分为 <code>Stack Reconciler</code> 和 <code>Fiber Reconciler</code>。这里的协调从狭义上来讲，特指 React 的 diff 算法，广义上来讲，有时候也指 React 的 <code>reconciler</code> 模块，它通常包含了 <code>diff</code> 算法和一些公共逻辑。</li> <li>回到 <code>Stack Reconciler</code> 中，<code>Stack Reconciler</code> 的<code>核心调度方式是递归</code>。<code>调度的基本处理单位是事务</code>，它的事务基类是 <code>Transaction</code>，这里的<code>事务是 React 团队从后端开发中加入的概念</code>。在 React 16 以前，<code>挂载主要通过 ReactMount 模块完成</code>，更新通过 <code>ReactUpdate</code> 模块完成，模块之间相互分离，落脚执行点也是事务。</li> <li>在 <code>React 16</code> 及以后，协调改为了 <code>Fiber Reconciler</code>。它的调度方式主要有两个特点，<code>第一个是协作式多任务模式</code>，在这个模式下，线程会定时放弃自己的运行权利，交还给主线程，通过<code>requestIdleCallback</code> 实现。<code>第二个特点是策略优先级</code>，调度任务通过标记 <code>tag</code> 的方式分优先级执行，比如动画，或者标记为 <code>high</code> 的任务可以优先执行。<code>Fiber Reconciler</code>的基本单位是 <code>Fiber</code>，<code>Fiber</code> 基于过去的 <code>React Element</code> 提供了二次封装，提供了指向父、子、兄弟节点的引用，为 <code>diff</code> 工作的双链表实现提供了基础。</li> <li>在新的架构下，整个生命周期被划分为 <code>Render 和 Commit 两个阶段</code>。<code>Render 阶段的执行特点是可中断、可停止、无副作用</code>，主要是通过构造 <code>workInProgress</code> 树计算出 <code>diff</code>。以 <code>current</code> 树为基础，将每个 <code>Fiber</code>作为一个基本单位，自下而上逐个节点检查并构造 workInProgress 树。这个过程不再是递归，而是基于循环来完成</li> <li>在执行上通过 <code>requestIdleCallback</code> 来调度执行每组任务，每组中的每个计算任务被称为 <code>work</code>，每个 <code>work</code> 完成后确认是否有优先级更高的 <code>work</code> 需要插入，如果有就让位，没有就继续。优先级通常是标记为动画或者 <code>high</code> 的会先处理。每完成一组后，将调度权交回主线程，直到下一次 <code>requestIdleCallback</code> 调用，再继续构建 <code>workInProgress</code> 树</li> <li>在 <code>commit</code> 阶段需要处理 <code>effect</code> 列表，这里的 <code>effect</code> 列表包含了根据 <code>diff 更新 DOM 树</code>、<code>回调生命周期</code>、<code>响应 ref</code> 等。</li> <li>但一定要注意，这个阶段是同步执行的，不可中断暂停，所以不要在 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWiilUnmount</code>中去执行重度消耗算力的任务</li> <li>如果只是一般的应用场景，比如管理后台、H5 展示页等，两者性能差距并不大，但在动画、画布及手势等场景下，<code>Stack Reconciler</code> 的设计会占用占主线程，造成卡顿，而 <code>fiber reconciler</code> 的设计则能带来高性能的表现</li></ul>
<h3 id="_11-diff算法是怎么运作"><a href="#_11-diff算法是怎么运作" class="header-anchor">#</a> 11 diff算法是怎么运作</h3>
<blockquote><p>每一种节点类型有自己的属性，也就是prop，每次进行diff的时候，react会先比较该节点类型，假如节点类型不一样，那么react会直接删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，那么会比较prop是否有更新，假如有prop不一样，那么react会判定该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，一层一层往下，直到没有子节点</p></blockquote>
<ul><li>把树形结构按照层级分解，只比较同级元素。</li> <li>给列表结构的每个单元添加唯一的<code>key</code>属性，方便比较。</li> <li><code>React</code> 只会匹配相同 <code>class</code> 的 <code>component</code>（这里面的<code>class</code>指的是组件的名字）</li> <li>合并操作，调用 <code>component</code> 的 <code>setState</code> 方法的时候, <code>React</code> 将其标记为 - <code>dirty</code>.到每一个事件循环结束, <code>React</code> 检查所有标记 <code>dirty</code>的 <code>component</code>重新绘制.</li> <li>选择性子树渲染。开发人员可以重写<code>shouldComponentUpdate</code>提高<code>diff</code>的性能</li></ul>
<p><strong>优化⬇️</strong></p>
<blockquote><p>为了降低算法复杂度，<code>React</code>的<code>diff</code>会预设三个限制：</p></blockquote>
<ol><li>只对同级元素进行<code>Diff</code>。如果一个<code>DOM节点</code>在前后两次更新中跨越了层级，那么<code>React</code>不会尝试复用他。</li> <li>两个不同类型的元素会产生出不同的树。如果元素由<code>div</code>变为<code>p</code>，React会销毁<code>div</code>及其子孙节点，并新建<code>p</code>及其子孙节点。</li> <li>开发者可以通过 <code>key prop</code>来暗示哪些子元素在不同的渲染下能保持稳定。考虑如下例子：</li></ol>
<p><strong>Diff的思路</strong></p>
<p>该如何设计算法呢？如果让我设计一个<code>Diff算法</code>，我首先想到的方案是：</p>
<ol><li>判断当前节点的更新属于哪种情况</li> <li>如果是<code>新增</code>，执行新增逻辑</li> <li>如果是<code>删除</code>，执行删除逻辑</li> <li>如果是<code>更新</code>，执行更新逻辑</li></ol>
<ul><li>按这个方案，其实有个隐含的前提——<strong>不同操作的优先级是相同的</strong></li> <li>但是<code>React团队</code>发现，在日常开发中，相较于<code>新增</code>和<code>删除</code>，<code>更新</code>组件发生的频率更高。所以<code>Diff</code>会优先判断当前节点是否属于<code>更新</code>。</li></ul>
<p>基于以上原因，<code>Diff算法</code>的整体逻辑会经历两轮遍历：</p>
<ul><li>第一轮遍历：处理<code>更新</code>的节点。</li> <li>第二轮遍历：处理剩下的不属于<code>更新</code>的节点。</li></ul>
<p><img alt="" src="https://s.poetries.top/images/20210307225249.png"></p>
<p><strong>diff算法的作用</strong></p>
<p>计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面。</p>
<p><strong>传统diff算法</strong></p>
<blockquote><p>通过循环递归对节点进行依次对比，算法复杂度达到 <code>O(n^3)</code> ，n是树的节点数，这个有多可怕呢？——如果要展示1000个节点，得执行上亿次比较。。即便是CPU快能执行30亿条命令，也很难在一秒内计算出差异。</p></blockquote>
<p><strong>React的diff算法</strong></p>
<ol><li>什么是调和？</li></ol>
<blockquote><p>将Virtual DOM树转换成actual DOM树的最少操作的过程 称为 调和 。</p></blockquote>
<ol start="2"><li>什么是React diff算法？</li></ol>
<blockquote><p><code>diff</code>算法是调和的具体实现。</p></blockquote>
<p><strong>diff策略</strong></p>
<blockquote><p>React用 三大策略 将O(n^3)复杂度 转化为 O(n)复杂度</p></blockquote>
<p><strong>策略一（tree diff）：</strong></p>
<ul><li>Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。</li></ul>
<p><strong>策略二（component diff）：</strong></p>
<ul><li>拥有相同类的两个组件 生成相似的树形结构，</li> <li>拥有不同类的两个组件 生成不同的树形结构。</li></ul>
<p><strong>策略三（element diff）：</strong></p>
<p>对于同一层级的一组子节点，通过唯一id区分。</p>
<p><strong>tree diff</strong></p>
<ul><li>React通过updateDepth对Virtual DOM树进行层级控制。</li> <li>对树分层比较，两棵树 只对同一层次节点 进行比较。如果该节点不存在时，则该节点及其子节点会被完全删除，不会再进一步比较。</li> <li>只需遍历一次，就能完成整棵DOM树的比较。</li></ul>
<p><img alt="image-20210307224725566" src="https://s.poetries.top/images/image-20210307224725566.png"></p>
<p>那么问题来了，如果DOM节点出现了跨层级操作,diff会咋办呢？</p>
<blockquote><p>答：diff只简单考虑同层级的节点位置变换，如果是跨层级的话，只有创建节点和删除节点的操作。</p></blockquote>
<p><img alt="image-20210307224829092" src="https://s.poetries.top/images/image-20210307224829092.png"></p>
<blockquote><p>如上图所示，以A为根节点的整棵树会被重新创建，而不是移动，因此 官方建议不要进行DOM节点跨层级操作，可以通过CSS隐藏、显示节点，而不是真正地移除、添加DOM节点</p></blockquote>
<p><strong>component diff</strong></p>
<blockquote><p>React对不同的组件间的比较，有三种策略</p></blockquote>
<ol><li>同一类型的两个组件，按原策略（层级比较）继续比较Virtual DOM树即可。</li> <li>同一类型的两个组件，组件A变化为组件B时，可能Virtual DOM没有任何变化，如果知道这点（变换的过程中，Virtual DOM没有改变），可节省大量计算时间，所以 用户 可以通过 <code>shouldComponentUpdate()</code> 来判断是否需要 判断计算。</li> <li>不同类型的组件，将一个（将被改变的）组件判断为<code>dirty component</code>（脏组件），从而替换 整个组件的所有节点。</li></ol>
<blockquote><p>注意：如果组件D和组件G的结构相似，但是 React判断是 不同类型的组件，则不会比较其结构，而是删除 组件D及其子节点，创建组件G及其子节点。</p></blockquote>
<p><strong>element diff</strong></p>
<blockquote><p>当节点处于同一层级时，diff提供三种节点操作：删除、插入、移动。</p></blockquote>
<ul><li>插入：组件 C 不在集合（A,B）中，需要插入</li> <li>删除：
<ul><li>组件 D 在集合（A,B,D）中，但 D的节点已经更改，不能复用和更新，所以需要删除 旧的 D ，再创建新的。</li> <li>组件 D 之前在 集合（A,B,D）中，但集合变成新的集合（A,B）了，D 就需要被删除。</li></ul></li> <li>移动：组件D已经在集合（A,B,C,D）里了，且集合更新时，D没有发生更新，只是位置改变，如新集合（A,D,B,C），D在第二个，无须像传统diff，让旧集合的第二个B和新集合的第二个D 比较，并且删除第二个位置的B，再在第二个位置插入D，而是 （对同一层级的同组子节点） 添加唯一key进行区分，移动即��。</li></ul>
<p><strong>总结</strong></p>
<ol><li><code>tree diff</code>：只对比同一层的 dom 节点，忽略 dom 节点的跨层级移动</li></ol>
<p>如下图，react 只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点不存在时，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。</p>
<p>这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。</p>
<p><img alt="image-20210302195610674" src="https://s.poetries.top/images/image-20210302195610674.png"></p>
<p>这就意味着，如果 dom 节点发生了跨层级移动，react 会删除旧的节点，生成新的节点，而不会复用。</p>
<ol start="2"><li><code>component diff</code>：如果不是同一类型的组件，会删除旧的组件，创建新的组件</li></ol>
<p><img alt="image-20210302195654736" src="https://s.poetries.top/images/image-20210302195654736.png"></p>
<ol start="3"><li><code>element diff</code>：对于同一层级的一组子节点，需要通过唯一 id 进行来区分</li></ol>
<ul><li>如果没有 id 来进行区分，一旦有插入动作，会导致插入位置之后的列表全部重新渲染</li> <li>这也是为什么渲染列表时为什么要使用唯一的 key。</li></ul>
<p><strong>diff的不足与待优化的地方</strong></p>
<blockquote><p>尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，会影响React的渲染性能</p></blockquote>
<p><strong>与其他框架相比，React 的 diff 算法有何不同？</strong></p>
<p><img alt="" src="https://s.poetries.top/images/20210425203918.png"></p>
<blockquote><p>diff 算法探讨的就是虚拟 DOM 树发生变化后，生成 DOM 树更新补丁的方式。它通过对比新旧两株虚拟 DOM 树的变更差异，将更新补丁作用于真实 DOM，以最小成本完成视图更新</p></blockquote>
<p><img alt="" src="https://s.poetries.top/images/20210425204127.png"></p>
<p>具体的流程是这样的：</p>
<ul><li>真实 DOM 与虚拟 DOM 之间存在一个映射关系。这个映射关系依靠初始化时的 JSX 建立完成；</li> <li>当虚拟 DOM 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；</li> <li>最后再根据 patch 去更新真实的 DOM，反馈到用户的界面上。</li></ul>
<p><img alt="" src="https://s.poetries.top/images/20210425204151.png"></p>
<p>在回答有何不同之前，首先需要说明下什么是 diff 算法。</p>
<ul><li><code>diff 算法是指生成更新补丁的方式</code>，主要应用于<code>虚拟 DOM 树变化后，更新真实 DOM</code>。所以 diff 算法一定存在这样一个过程：<code>触发更新 → 生成补丁 → 应用补丁</code></li> <li>React 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 DOM 树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。<code>将单一节点比对转化为了 3 种类型节点的比对</code>，分别是<code>树、组件及元素</code>，以此提升效率。
<ul><li><code>树比对</code>：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。</li> <li><code>组件比对</code>：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。</li> <li><code>元素比对</code>：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。同一层级的子节点，可以通过标记 key 的方式进行列表对比。</li></ul></li> <li>以上是经典的 React diff 算法内容。<code>自 React 16 起，引入了 Fiber 架构</code>。为了使整个更新过程<code>可随时暂停恢复</code>，节点与树分别采用了 <code>FiberNode 与 FiberTree 进行重构</code>。<code>fiberNode 使用了双链表的结构</code>，可以直接找到兄弟节点与子节点</li> <li>然后拿 Vue 和 Preact 与 React 的 diff 算法进行对比
<ul><li><code>Preact</code> 的 <code>Diff</code> 算法相较于 <code>React</code>，整体设计思路相似，但最底层的元素采用了真实 <code>DOM</code> 对比操作，也没有采用 <code>Fiber</code> 设计。Vue 的 <code>Diff</code> 算法整体也与 <code>React</code> 相似，同样未实现 <code>Fiber</code> 设计</li></ul></li> <li>然后进行横向比较，<code>React 拥有完整的 Diff 算法策略，且拥有随时中断更新的时间切片能力</code>，在大批量节点更新的极端情况下，拥有更友好的交互体验。</li> <li>Preact 可以在一些对性能要求不高，仅需要渲染框架的简单场景下应用。</li> <li>Vue 的整体 <code>diff 策略与 React 对齐</code>，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。</li></ul>
<p>**学习原理的目的就是应用。那如何根据 React diff 算法原理优化代码呢？**这个问题其实按优化方式逆向回答即可。</p>
<ul><li>根据 <code>diff</code> 算法的设计原则，应尽量避免跨层级节点移动。</li> <li>通过设置唯一 <code>key</code> 进行优化，尽量减少组件层级深度。因为过深的层级会加深遍历深度，带来性能问题。</li> <li>设置 <code>shouldComponentUpdate</code> 或者 <code>React.pureComponet</code> 减少 <code>diff</code> 次数。</li></ul>
<h3 id="_12-合成事件原理"><a href="#_12-合成事件原理" class="header-anchor">#</a> 12 合成事件原理</h3>
<blockquote><p>为了解决跨浏览器兼容性问题，<code>React</code> 会将浏览器原生事件（<code>Browser Native Event</code>）封装为合成事件（<code>SyntheticEvent</code>）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，<code>React</code> 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 <code>React</code> 在更新 <code>DOM</code> 的时候就不需要考虑如何去处理附着在 <code>DOM</code> 上的事件监听器，最终达到优化性能的目的</p></blockquote>
<ul><li>所有的事件挂在document上，DOM 事件触发后冒泡到 document；React 找到对应的组件，造出一个合成事件出来；并按组件树模拟一遍事件冒泡。</li> <li>event不是原生的，是SyntheticEvent合成事件对象</li> <li>和Vue事件不同,和DOM事件也不同</li></ul>
<p><strong>React 17 之前的事件冒泡流程图</strong></p>
<p><img alt="" src="https://s.poetries.top/images/20210425135711.png"></p>
<blockquote><p>所以这就造成了，在一个页面中，只能有一个版本的 React。如果有多个版本，事件就乱套了。值得一提的是，这个问题在 React 17 中得到了解决，事件委托不再挂在 document 上，而是挂在 DOM 容器上，也就是 <code>ReactDom.Render</code> 所调用的节点上。</p></blockquote>
<p><strong>React 17 后的事件冒泡流程图</strong></p>
<p><img alt="" src="https://s.poetries.top/images/20210425135751.png"></p>
<blockquote><p>那到底哪些事件会被捕获生成合成事件呢？可以从 React 的源码测试文件中一探究竟。下面的测试快照中罗列了大量的事件名，也只有在这份快照中的事件，才会被捕获生成合成事件。</p></blockquote>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// react/packages/react-dom/src/__tests__/__snapshots__/ReactTestUtils-test.js.snap</span>
Array <span class="token punctuation">[</span>
	  <span class="token string">"abort"</span><span class="token punctuation">,</span>
	  <span class="token string">"animationEnd"</span><span class="token punctuation">,</span>
	  <span class="token string">"animationIteration"</span><span class="token punctuation">,</span>
	  <span class="token string">"animationStart"</span><span class="token punctuation">,</span>
	  <span class="token string">"auxClick"</span><span class="token punctuation">,</span>
	  <span class="token string">"beforeInput"</span><span class="token punctuation">,</span>
	  <span class="token string">"blur"</span><span class="token punctuation">,</span>
	  <span class="token string">"canPlay"</span><span class="token punctuation">,</span>
	  <span class="token string">"canPlayThrough"</span><span class="token punctuation">,</span>
	  <span class="token string">"cancel"</span><span class="token punctuation">,</span>
	  <span class="token string">"change"</span><span class="token punctuation">,</span>
	  <span class="token string">"click"</span><span class="token punctuation">,</span>
	  <span class="token string">"close"</span><span class="token punctuation">,</span>
	  <span class="token string">"compositionEnd"</span><span class="token punctuation">,</span>
	  <span class="token string">"compositionStart"</span><span class="token punctuation">,</span>
	  <span class="token string">"compositionUpdate"</span><span class="token punctuation">,</span>
	  <span class="token string">"contextMenu"</span><span class="token punctuation">,</span>
	  <span class="token string">"copy"</span><span class="token punctuation">,</span>
	  <span class="token string">"cut"</span><span class="token punctuation">,</span>
	  <span class="token string">"doubleClick"</span><span class="token punctuation">,</span>
	  <span class="token string">"drag"</span><span class="token punctuation">,</span>
	  <span class="token string">"dragEnd"</span><span class="token punctuation">,</span>
	  <span class="token string">"dragEnter"</span><span class="token punctuation">,</span>
	  <span class="token string">"dragExit"</span><span class="token punctuation">,</span>
	  <span class="token string">"dragLeave"</span><span class="token punctuation">,</span>
	  <span class="token string">"dragOver"</span><span class="token punctuation">,</span>
	  <span class="token string">"dragStart"</span><span class="token punctuation">,</span>
	  <span class="token string">"drop"</span><span class="token punctuation">,</span>
	  <span class="token string">"durationChange"</span><span class="token punctuation">,</span>
	  <span class="token string">"emptied"</span><span class="token punctuation">,</span>
	  <span class="token string">"encrypted"</span><span class="token punctuation">,</span>
	  <span class="token string">"ended"</span><span class="token punctuation">,</span>
	  <span class="token string">"error"</span><span class="token punctuation">,</span>
	  <span class="token string">"focus"</span><span class="token punctuation">,</span>
	  <span class="token string">"gotPointerCapture"</span><span class="token punctuation">,</span>
	  <span class="token string">"input"</span><span class="token punctuation">,</span>
	  <span class="token string">"invalid"</span><span class="token punctuation">,</span>
	  <span class="token string">"keyDown"</span><span class="token punctuation">,</span>
	  <span class="token string">"keyPress"</span><span class="token punctuation">,</span>
	  <span class="token string">"keyUp"</span><span class="token punctuation">,</span>
	  <span class="token string">"load"</span><span class="token punctuation">,</span>
	  <span class="token string">"loadStart"</span><span class="token punctuation">,</span>
	  <span class="token string">"loadedData"</span><span class="token punctuation">,</span>
	  <span class="token string">"loadedMetadata"</span><span class="token punctuation">,</span>
	  <span class="token string">"lostPointerCapture"</span><span class="token punctuation">,</span>
	  <span class="token string">"mouseDown"</span><span class="token punctuation">,</span>
	  <span class="token string">"mouseEnter"</span><span class="token punctuation">,</span>
	  <span class="token string">"mouseLeave"</span><span class="token punctuation">,</span>
	  <span class="token string">"mouseMove"</span><span class="token punctuation">,</span>
	  <span class="token string">"mouseOut"</span><span class="token punctuation">,</span>
	  <span class="token string">"mouseOver"</span><span class="token punctuation">,</span>
	  <span class="token string">"mouseUp"</span><span class="token punctuation">,</span>
	  <span class="token string">"paste"</span><span class="token punctuation">,</span>
	  <span class="token string">"pause"</span><span class="token punctuation">,</span>
	  <span class="token string">"play"</span><span class="token punctuation">,</span>
	  <span class="token string">"playing"</span><span class="token punctuation">,</span>
	  <span class="token string">"pointerCancel"</span><span class="token punctuation">,</span>
	  <span class="token string">"pointerDown"</span><span class="token punctuation">,</span>
	  <span class="token string">"pointerEnter"</span><span class="token punctuation">,</span>
	  <span class="token string">"pointerLeave"</span><span class="token punctuation">,</span>
	  <span class="token string">"pointerMove"</span><span class="token punctuation">,</span>
	  <span class="token string">"pointerOut"</span><span class="token punctuation">,</span>
	  <span class="token string">"pointerOver"</span><span class="token punctuation">,</span>
	  <span class="token string">"pointerUp"</span><span class="token punctuation">,</span>
	  <span class="token string">"progress"</span><span class="token punctuation">,</span>
	  <span class="token string">"rateChange"</span><span class="token punctuation">,</span>
	  <span class="token string">"reset"</span><span class="token punctuation">,</span>
	  <span class="token string">"scroll"</span><span class="token punctuation">,</span>
	  <span class="token string">"seeked"</span><span class="token punctuation">,</span>
	  <span class="token string">"seeking"</span><span class="token punctuation">,</span>
	  <span class="token string">"select"</span><span class="token punctuation">,</span>
	  <span class="token string">"stalled"</span><span class="token punctuation">,</span>
	  <span class="token string">"submit"</span><span class="token punctuation">,</span>
	  <span class="token string">"suspend"</span><span class="token punctuation">,</span>
	  <span class="token string">"timeUpdate"</span><span class="token punctuation">,</span>
	  <span class="token string">"toggle"</span><span class="token punctuation">,</span>
	  <span class="token string">"touchCancel"</span><span class="token punctuation">,</span>
	  <span class="token string">"touchEnd"</span><span class="token punctuation">,</span>
	  <span class="token string">"touchMove"</span><span class="token punctuation">,</span>
	  <span class="token string">"touchStart"</span><span class="token punctuation">,</span>
	  <span class="token string">"transitionEnd"</span><span class="token punctuation">,</span>
	  <span class="token string">"volumeChange"</span><span class="token punctuation">,</span>
	  <span class="token string">"waiting"</span><span class="token punctuation">,</span>
	  <span class="token string">"wheel"</span><span class="token punctuation">,</span>
	<span class="token punctuation">]</span>
</code></pre></div>
<blockquote><p>如果DOM上绑定了过多的事件处理函数,整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用,同时屏蔽底层不同浏览器之间的事件系统的差异,实现了一个中间层 - SyntheticEvent</p></blockquote>
<ol><li>当用户在为onClick添加函数时,React并没有将Click绑定到DOM上面</li> <li>而是在document处监听所有支持的事件,当事件发生并冒泡至document处时,React将事件内容封装交给中间层 SyntheticEvent (负责所有事件合成)</li> <li>所以当事件触发的时候, 对使用统一的分发函数 dispatchEvent 将指定函数执行</li></ol>
<p><img alt="" src="https://s.poetries.top/images/20210409153648.png"></p>
<p><strong>为何要合成事件</strong></p>
<ul><li>兼容性和跨平台</li> <li>挂在统一的document上，减少内存消耗，避免频繁解绑</li> <li>方便事件的统一管理（事务机制）</li> <li>dispatchEvent事件机制</li></ul>
<h3 id="_13-jsx语法糖本质"><a href="#_13-jsx语法糖本质" class="header-anchor">#</a> 13 JSX语法糖本质</h3>
<blockquote><p>JSX是语法糖，通过babel转成<code>React.createElement</code>函数，在babel官网上可以在线把JSX转成React的JS语法</p></blockquote>
<ul><li>首先解析出来的话，就是一个<code>createElement</code>函数</li> <li>然后这个函数执行完后，会返回一个<code>vnode</code></li> <li>通过vdom的patch或者是其他的一个方法，最后渲染一个页面</li></ul>
<p><img alt="" src="https://s.poetries.top/images/20210407215708.png"> <img alt="" src="https://s.poetries.top/images/20210407215721.png"></p>
<blockquote><p>script标签中不添加<code>text/babel</code>解析jsx语法的情况下</p></blockquote>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">const</span> ele <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"h2"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"Hello React!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>ele<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<p><strong>JSX的本质是React.createElement()函数</strong></p>
<p><img alt="" src="https://s.poetries.top/images/20210407215754.png"></p>
<blockquote><p><code>createElement</code>函数返回的对象是<code>ReactEelement</code>对象。</p></blockquote>
<p><code>createElement</code>的写法如下</p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        <span class="token comment">/*第一个子元素，header*/</span>
        React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">className</span><span class="token operator">:</span> <span class="token string">"header"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
                            React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"h1"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">"\u6807\u9898"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"\u6211\u662F\u6807\u9898"</span><span class="token punctuation">)</span>
                          <span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token comment">/*第二个子元素，content*/</span>
        React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">className</span><span class="token operator">:</span> <span class="token string">"content"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
                            React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"h2"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"\u6211\u662F\u9875\u9762\u7684\u5185\u5BB9"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                            React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"button"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"\u6309\u94AE"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                            React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"button"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"+1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                            React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">href</span><span class="token operator">:</span> <span class="token string">"http://www.baidu.com"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
                                                <span class="token string">"\u767E\u5EA6\u4E00\u4E0B"</span><span class="token punctuation">)</span>
                          <span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token comment">/*第三个子元素，footer*/</span>
        React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">className</span><span class="token operator">:</span> <span class="token string">"footer"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
                            React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"\u6211\u662F\u5C3E\u90E8\u7684\u5185\u5BB9"</span><span class="token punctuation">)</span>
                          <span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<p>实际开发中不会使用<code>createElement</code>来创建<code>ReactElement</code>的，一般都是使用JSX的形式开发。</p>
<p><code>ReactElement</code>在程序中打印一下</p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> ele <span class="token operator">=</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">"header"</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>h1 title<span class="token operator">=</span><span class="token string">"标题"</span><span class="token operator">&gt;</span>我是标题<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">"content"</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span>我是页面的内容<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button<span class="token operator">&gt;</span>按钮<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button<span class="token operator">&gt;</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://www.baidu.com"</span><span class="token operator">&gt;</span>百度一下<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">"footer"</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是尾部的内容<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> ele<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p><img alt="" src="https://s.poetries.top/images/20210407220013.png"></p>
<blockquote><p>react通过babel把JSX转成<code>createElement</code>函数，生成<code>ReactElement</code>对象，然后通过<code>ReactDOM.render函</code>数把<code>ReactElement</code>渲染成真实的<code>DOM</code>元素</p></blockquote>
<p><strong>为什么 React 使用 JSX</strong></p>
<p><img alt="" src="https://s.poetries.top/images/20210425120721.png"></p>
<ul><li>在回答问题之前，我首先解释下什么是 JSX 吧。JSX 是一个 <code>JavaScript</code> 的语法扩展，结构类似 XML。</li> <li>JSX 主要用于声明 <code>React</code> 元素，但 React 中并不强制使用 <code>JSX</code>。即使使用了 <code>JSX</code>，也会在构建过程中，通过 Babel 插件编译为 <code>React.createElement</code>。所以 JSX 更像是 <code>React.createElement</code> 的一种语法糖</li> <li>接下来与 JSX 以外的三种技术方案进行对比
<ul><li>首先是模板，React 团队认为模板不应该是开发过程中的关注点，因为引入了模板语法、模板指令等概念，是一种不佳的实现方案</li> <li>其次是模板字符串，模板字符串编写的结构会造成多次内部嵌套，使整个结构变得复杂，并且优化代码提示也会变得困难重重</li> <li>所以 React 最后选用了 JSX，因为 JSX 与其设计思想贴合，不需要引入过多新的概念，对编辑器的代码提示也极为友好。</li></ul></li></ul>
<p><strong>Babel 插件如何实现 JSX 到 JS 的编译？ 在 React 面试中，这个问题很容易被追问，也经常被要求手写。</strong></p>
<p>它的实现原理是这样的。Babel 读取代码并解析，生成 AST，再将 AST 传入插件层进行转换，在转换时就可以将 JSX 的结构转换为 <code>React.createElement</code> 的函数。如下代码所示：</p>
<div class="language-js extra-class"><pre class="language-js"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">babel</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> t <span class="token operator">=</span> babel<span class="token punctuation">.</span>types<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">"custom-jsx-plugin"</span><span class="token punctuation">,</span>
    visitor<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">JSXElement</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> openingElement <span class="token operator">=</span> path<span class="token punctuation">.</span>node<span class="token punctuation">.</span>openingElement<span class="token punctuation">;</span>
        <span class="token keyword">var</span> tagName <span class="token operator">=</span> openingElement<span class="token punctuation">.</span>name<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
        <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
        args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">stringLiteral</span><span class="token punctuation">(</span>tagName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">var</span> attribs <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">nullLiteral</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>attribs<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">var</span> reactIdentifier <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">identifier</span><span class="token punctuation">(</span><span class="token string">"React"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//object</span>
        <span class="token keyword">var</span> createElementIdentifier <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">identifier</span><span class="token punctuation">(</span><span class="token string">"createElement"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">var</span> callee <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">memberExpression</span><span class="token punctuation">(</span>reactIdentifier<span class="token punctuation">,</span> createElementIdentifier<span class="token punctuation">)</span>
        <span class="token keyword">var</span> callExpression <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">callExpression</span><span class="token punctuation">(</span>callee<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        callExpression<span class="token punctuation">.</span>arguments <span class="token operator">=</span> callExpression<span class="token punctuation">.</span>arguments<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span>node<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
        path<span class="token punctuation">.</span><span class="token function">replaceWith</span><span class="token punctuation">(</span>callExpression<span class="token punctuation">,</span> path<span class="token punctuation">.</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> 
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div>
<p><strong>React.createElement源码分析</strong></p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 101. React的创建元素方法
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> config<span class="token punctuation">,</span> children</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// propName 变量用于储存后面需要用到的元素属性</span>
  <span class="token keyword">let</span> propName<span class="token punctuation">;</span> 
  <span class="token comment">// props 变量用于储存元素属性的键值对集合</span>
  <span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
  <span class="token comment">// key、ref、self、source 均为 React 元素的属性，此处不必深究</span>
  <span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> ref <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> 
  <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> 
  <span class="token keyword">let</span> source <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> 

  <span class="token comment">// config 对象中存储的是元素的属性</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>config <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// 进来之后做的第一件事，是依次对 ref、key、self 和 source 属性赋值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasValidRef</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ref <span class="token operator">=</span> config<span class="token punctuation">.</span>ref<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 此处将 key 值字符串化</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasValidKey</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      key <span class="token operator">=</span> <span class="token string">''</span> <span class="token operator">+</span> config<span class="token punctuation">.</span>key<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    self <span class="token operator">=</span> config<span class="token punctuation">.</span>__self <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> config<span class="token punctuation">.</span>__self<span class="token punctuation">;</span>
    source <span class="token operator">=</span> config<span class="token punctuation">.</span>__source <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> config<span class="token punctuation">.</span>__source<span class="token punctuation">;</span>
    <span class="token comment">// 接着就是要把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>propName <span class="token keyword">in</span> config<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>
        <span class="token comment">// 筛选出可以提进 props 对象里的属性</span>
        <span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> propName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token operator">!</span><span class="token constant">RESERVED_PROPS</span><span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>propName<span class="token punctuation">)</span> 
      <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        props<span class="token punctuation">[</span>propName<span class="token punctuation">]</span> <span class="token operator">=</span> config<span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token punctuation">;</span> 
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度</span>
  <span class="token keyword">const</span> childrenLength <span class="token operator">=</span> arguments<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> 
  <span class="token comment">// 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>childrenLength <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// 直接把这个参数的值赋给props.children</span>
    props<span class="token punctuation">.</span>children <span class="token operator">=</span> children<span class="token punctuation">;</span> 
    <span class="token comment">// 处理嵌套多个子元素的情况</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childrenLength <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// 声明一个子元素数组</span>
    <span class="token keyword">const</span> childArray <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>childrenLength<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment">// 把子元素推进数组里</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> childrenLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      childArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arguments<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 最后把这个数组赋值给props.children</span>
    props<span class="token punctuation">.</span>children <span class="token operator">=</span> childArray<span class="token punctuation">;</span> 
  <span class="token punctuation">}</span> 

  <span class="token comment">// 处理 defaultProps</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">&amp;&amp;</span> type<span class="token punctuation">.</span>defaultProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> defaultProps <span class="token operator">=</span> type<span class="token punctuation">.</span>defaultProps<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>propName <span class="token keyword">in</span> defaultProps<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      <span class="token keyword">if</span> <span class="token punctuation">(</span>props<span class="token punctuation">[</span>propName<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        props<span class="token punctuation">[</span>propName<span class="token punctuation">]</span> <span class="token operator">=</span> defaultProps<span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数</span>
  <span class="token keyword">return</span> <span class="token function">ReactElement</span><span class="token punctuation">(</span>
    type<span class="token punctuation">,</span>
    key<span class="token punctuation">,</span>
    ref<span class="token punctuation">,</span>
    self<span class="token punctuation">,</span>
    source<span class="token punctuation">,</span>
    ReactCurrentOwner<span class="token punctuation">.</span>current<span class="token punctuation">,</span>
    props<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p><strong>入参解读：创造一个元素需要知道哪些信息</strong></p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> config<span class="token punctuation">,</span> children</span><span class="token punctuation">)</span>
</code></pre></div>
<p>createElement 有 3 个入参，这 3 个入参囊括了 React 创建一个元素所需要知道的全部信息。</p>
<ul><li><code>type</code>：用于标识节点的类型。它可以是类似“h1”“div”这样的标准 HTML 标签字符串，也可以是 React 组件类型或 <code>React fragment</code> 类型。</li> <li><code>config</code>：以对象形式传入，组件所有的属性都会以键值对的形式存储在 config 对象中。</li> <li><code>children</code>：以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的“子节点”“子元素”</li></ul>
<div class="language-js extra-class"><pre class="language-js"><code>React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"ul"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 传入属性键值对</span>
  <span class="token literal-property property">className</span><span class="token operator">:</span> <span class="token string">"list"</span>
   <span class="token comment">// 从第三个入参开始往后，传入的参数都是 children</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"li"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token string">"1"</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"li"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token string">"2"</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<p>这个调用对应的 DOM 结构如下：</p>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<p><strong>createElement 函数体拆解</strong></p>
<p><img alt="" src="https://s.poetries.top/images/20210426192237.png"></p>
<blockquote><p>createElement 中并没有十分复杂的涉及算法或真实 DOM 的逻辑，它的每一个步骤几乎都是在格式化数据。</p></blockquote>
<p><img alt="" src="https://s.poetries.top/images/20210426192648.png"></p>
<blockquote><p>现在看来，<code>createElement</code> 原来只是个“参数中介”。此时我们的注意力自然而然地就聚焦在了 <code>ReactElement</code> 上</p></blockquote>
<p><strong>出参解读：初识虚拟 DOM</strong></p>
<blockquote><p><code>createElement</code> 执行到最后会 return 一个针对 ReactElement 的调用。这里关于 ReactElement，我依然先给出源码 + 注释形式的解析</p></blockquote>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">ReactElement</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> key<span class="token punctuation">,</span> ref<span class="token punctuation">,</span> self<span class="token punctuation">,</span> source<span class="token punctuation">,</span> owner<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// REACT_ELEMENT_TYPE是一个常量，用来标识该对象是一个ReactElement</span>
    $<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token constant">REACT_ELEMENT_TYPE</span><span class="token punctuation">,</span>

    <span class="token comment">// 内置属性赋值</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> type<span class="token punctuation">,</span>
    <span class="token literal-property property">key</span><span class="token operator">:</span> key<span class="token punctuation">,</span>
    <span class="token literal-property property">ref</span><span class="token operator">:</span> ref<span class="token punctuation">,</span>
    <span class="token literal-property property">props</span><span class="token operator">:</span> props<span class="token punctuation">,</span>

    <span class="token comment">// 记录创造该元素的组件</span>
    <span class="token literal-property property">_owner</span><span class="token operator">:</span> owner<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里是一些针对 __DEV__ 环境下的处理，对于大家理解主要逻辑意义不大，此处我直接省略掉，以免混淆视听</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> element<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div>
<blockquote><p><code>ReactElement</code> 其实只做了一件事情，那就是“创建”，说得更精确一点，是“组装”：<code>ReactElement</code> 把传入的参数按照一定的规范，“组装”进了 <code>element</code> 对象里，并把它返回给了 <code>eact.createElement</code>，最终 <code>React.createElement</code> 又把它交回到了开发者手中</p></blockquote>
<p><img alt="" src="https://s.poetries.top/images/20210426193812.png"></p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> AppJSX <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">"App"</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>h1 className<span class="token operator">=</span><span class="token string">"title"</span><span class="token operator">&gt;</span><span class="token constant">I</span> am the title<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>p className<span class="token operator">=</span><span class="token string">"content"</span><span class="token operator">&gt;</span><span class="token constant">I</span> am the content<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>AppJSX<span class="token punctuation">)</span>
</code></pre></div>
<p>你会发现它确实是一个标准的 <code>ReactElement</code> 对象实例</p>
<p><img alt="" src="https://s.poetries.top/images/20210426193901.png"></p>
<p>这个 <code>ReactElement</code> 对象实例，本质上是以 JavaScript 对象形式存在的对 <code>DOM</code> 的描述，也就是老生常谈的“虚拟 DOM”（准确地说，是虚拟 <code>DOM</code> 中的一个节点)</p>
<h3 id="_14-为什么-react-元素有一个-typeof-属性"><a href="#_14-为什么-react-元素有一个-typeof-属性" class="header-anchor">#</a> 14 为什么 React 元素有一个 $typeof 属性</h3>
<p><img alt="image-20210302200213923" src="https://s.poetries.top/images/image-20210302200213923.png"></p>
<blockquote><p>目的是为了防止 XSS 攻击。因为 Synbol 无法被序列化，所以 React 可以通过有没有 $typeof 属性来断出当前的 element 对象是从数据库来的还是自己生成的。</p></blockquote>
<ul><li>如果没有 $typeof 这个属性，react 会拒绝处理该元素。</li> <li>在 React 的古老版本中，下面的写法会出现 XSS 攻击：</li></ul>
<div class="language- extra-class"><pre class="language-text"><code>// 服务端允许用户存储 JSON
let expectedTextButGotJSON = {
  type: 'div',
  props: {
    dangerouslySetInnerHTML: {
      __html: '/* 把你想的搁着 */'
    },
  },
  // ...
};
let message = { text: expectedTextButGotJSON };

// React 0.13 中有风险
&lt;p&gt;
  {message.text}
&lt;/p&gt;
</code></pre></div>
<h3 id="_15-virtual-dom-的工作原理是什么"><a href="#_15-virtual-dom-的工作原理是什么" class="header-anchor">#</a> 15 Virtual DOM 的工作原理是什么</h3>
<p><img alt="" src="https://s.poetries.top/images/20210425201821.png"></p>
<ul><li>虚拟 DOM 的工作原理是<code>通过 JS 对象模拟 DOM 的节点</code>。在 Facebook 构建 React 初期时，考虑到要提升代码抽象能力、避免人为的 DOM 操作、降低代码整体风险等因素，所以引入了虚拟 DOM</li> <li>虚拟 DOM 在实现上通常是 <code>Plain Object</code>，以 React 为例，在 <code>render</code> 函数中写的 <code>JSX</code> 会在 <code>Babel</code> 插件的作用下，编译为 <code>React.createElement</code> 执行 <code>JSX</code> 中的属性参数</li> <li><code>React.createElement</code> 执行后会返回一个 <code>Plain Object</code>，它会描述自己的 <code>tag</code> 类型、<code>props</code> 属性以及 <code>children</code> 情况等。这些 <code>Plain Object</code> 通过树形结构组成一棵虚拟 <code>DOM</code> 树。当状态发生变更时，将变更前后的虚拟 <code>DOM</code> 树进行差异比较，这个过程称为 <code>diff</code>，生成的结果称为 <code>patch</code>。计算之后，会渲染 <code>Patch</code> 完成对真实 <code>DOM</code> 的操作。</li> <li>虚拟 DOM 的优点主要有三点：<code>改善大规模</code>DOM<code>操作的性能</code>、<code>规避 XSS 风险</code>、<code>能以较低的成本实现跨平台开发</code>。</li> <li>虚拟 DOM 的缺点在社区中主要有两点
<ul><li>内存占用较高，因为需要模拟整个网页的真实 <code>DOM</code></li> <li>高性能应用场景存在难以优化的情况，类似像 Google Earth 一类的高性能前端应用在技术选型上往往不会选择 React</li></ul></li></ul>
<p><strong>除了渲染页面，虚拟 DOM 还有哪些应用场景？</strong></p>
<blockquote><p>这个问题考验面试者的想象力。通常而言，我们只是将虚拟 DOM 与渲染绑定在一起，但实际上虚拟 DOM 的应用更为广阔。比如，只要你记录了真实 DOM 变更，它甚至可以应用于埋点统计与数据记录等。</p></blockquote>
<p><strong>SSR原理</strong></p>
<blockquote><p>借助虚拟dom,服务器中没有dom概念的，react巧妙的借助虚拟dom，然后可以在服务器中nodejs可以运行起来react代码。</p></blockquote>
<h3 id="_16-react有哪些优化性能的手段"><a href="#_16-react有哪些优化性能的手段" class="header-anchor">#</a> 16 React有哪些优化性能的手段</h3>
<p><strong>类组件中的优化手段</strong></p>
<ul><li>使用纯组件 <code>PureComponent</code> 作为基类。</li> <li>使用 <code>shouldComponentUpdate</code> 生命周期函数来自定义渲染逻辑。</li></ul>
<p><strong>方法组件中的优化手段</strong></p>
<ul><li>使用 <code>React.memo</code> 高阶函数包装组件，<code>React.memo</code> 可以实现类似于 <code>shouldComponentUpdate</code> 或者 <code>PureComponent</code> 的效果</li> <li>使用 <code>useMemo</code> <ul><li>使用<code>React.useMemo</code>精细化的管控，<code>useMemo 控制的则是是否需要重复执行某一段逻辑</code>，而<code>React.memo 控制是否需要重渲染一个组件</code></li></ul></li> <li>使用 <code>useCallBack</code>。</li></ul>
<p><strong>其他方式</strong></p>
<ul><li>在列表需要频繁变动时，使用唯一 id 作为 key，而不是数组下标。</li> <li>必要时通过改变 CSS 样式隐藏显示组件，而不是通过条件判断显示隐藏组件。</li> <li>使用 <code>Suspense</code> 和 lazy 进行懒加载，例如：</li></ul>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> lazy<span class="token punctuation">,</span> Suspense <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">CallingLazyComponents</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> ComponentToLazyLoad <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">"Mayank"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ComponentToLazyLoad <span class="token operator">=</span> <span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"./mayankComponent"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">"Anshul"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ComponentToLazyLoad <span class="token operator">=</span> <span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"./anshulComponent"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>This is the Base User<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Suspense fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Loading<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>ComponentToLazyLoad <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>Suspense<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h3 id="_17-redux实现原理解析"><a href="#_17-redux实现原理解析" class="header-anchor">#</a> 17 Redux实现原理解析</h3>
<blockquote><p><code>在 Redux 的整个工作过程中，数据流是严格单向的</code>。这一点一定一定要背下来，面试的时候也一定一定要记得说</p></blockquote>
<p><strong>为什么要用redux</strong></p>
<blockquote><p>在<code>React</code>中，数据在组件中是单向流动的，数据从一个方向父组件流向子组件（通过<code>props</code>）,所以，两个非父子组件之间通信就相对麻烦，<code>redux</code>的出现就是为了解决<code>state</code>里面的数据问题</p></blockquote>
<p><strong>Redux设计理念</strong></p>
<blockquote><p><code>Redux</code>是将整个应用状态存储到一个地方上称为<code>store</code>,里面保存着一个状态树<code>store tree</code>,组件可以派发(<code>dispatch</code>)行为(<code>action</code>)给<code>store</code>,而不是直接通知其他组件，组件内部通过订阅<code>store</code>中的状态<code>state</code>来刷新自己的视图</p></blockquote>
<p><img alt="" src="https://s.poetries.top/gitee/2020/07/68.png"></p>
<blockquote><p>如果你想对数据进行修改，<code>只有一种途径：派发 action</code>。action 会被 reducer 读取，进而根据 action 内容的不同对数据进行修改、生成新的 state（状态），这个新的 state 会更新到 store 对象里，进而驱动视图层面做出对应的改变。</p></blockquote>
<p><strong>Redux三大原则</strong></p>
<ul><li>唯一数据源</li></ul>
<blockquote><p>整个应用的state都被存储到一个状态树里面，并且这个状态树，只存在于唯一的store中</p></blockquote>
<ul><li>保持只读状态</li></ul>
<blockquote><p><code>state</code>是只读的，唯一改变<code>state</code>的方法就是触发<code>action</code>，<code>action</code>是一个用于描述以发生时间的普通对象</p></blockquote>
<ul><li>数据改变只能通过纯函数来执行</li></ul>
<blockquote><p>使用纯函数来执行修改，为了描述<code>action</code>如何改变<code>state</code>的，你需要编写<code>reducers</code></p></blockquote>
<p><strong>从编码的角度理解 Redux 工作流</strong></p>
<ol><li>使用 <code>createStore 来完成 store 对象的创建</code></li></ol>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 引入 redux</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createStore <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux'</span>
<span class="token comment">// 创建 store</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span>
    reducer<span class="token punctuation">,</span>
    initial_state<span class="token punctuation">,</span>
    <span class="token function">applyMiddleware</span><span class="token punctuation">(</span>middleware1<span class="token punctuation">,</span> middleware2<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<p>createStore 方法是一切的开始，它接收三个入参：</p>
<ul><li>reducer；</li> <li>初始状态内容；</li> <li>指定中间件</li></ul>
<ol start="2"><li><code>reducer 的作用是将新的 state 返回给 store</code></li></ol>
<p>一个 reducer 一定是一个纯函数，它可以有各种各样的内在逻辑，但它最终一定要返回一个 state：</p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">reducer</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 此处是各种样的 state处理逻辑</span>
    <span class="token keyword">return</span> new_state
<span class="token punctuation">}</span>
</code></pre></div>
<p>当我们基于某个 reducer 去创建 store 的时候，其实就是给这个 store 指定了一套更新规则：</p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 更新规则全都写在 reducer 里 </span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span>reducer<span class="token punctuation">)</span>
</code></pre></div>
<ol start="3"><li>action 的作用是通知 reducer “让改变发生”</li></ol>
<blockquote><p>要想让 state 发生改变，就必须用正确的 action 来驱动这个改变。</p></blockquote>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> action <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">"ADD_ITEM"</span><span class="token punctuation">,</span>
  <span class="token literal-property property">payload</span><span class="token operator">:</span> <span class="token string">'&lt;li&gt;text&lt;/li&gt;'</span>
<span class="token punctuation">}</span>
</code></pre></div>
<blockquote><p>action 对象中允许传入的属性有多个，但只有 type 是必传的。type 是 action 的唯一标识，reducer 正是通过不同的 type 来识别出需要更新的不同的 state，由此才能够实现精准的“定向更新”。</p></blockquote>
<ol start="4"><li>派发 action，靠的是 dispatch</li></ol>
<p>action 本身只是一个对象，要想让 reducer 感知到 action，还需要“派发 action”这个动作，<code>这个动作是由 store.dispatch 完成的</code>。这里我简单地示范一下：</p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createStore <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux'</span>
<span class="token comment">// 创建 reducer</span>
<span class="token keyword">const</span> <span class="token function-variable function">reducer</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 此处是各种样的 state处理逻辑</span>
    <span class="token keyword">return</span> new_state
<span class="token punctuation">}</span>
<span class="token comment">// 基于 reducer 创建 state</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span>reducer<span class="token punctuation">)</span>
<span class="token comment">// 创建一个 action，这个 action 用 “ADD_ITEM” 来标识 </span>
<span class="token keyword">const</span> action <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">"ADD_ITEM"</span><span class="token punctuation">,</span>
  <span class="token literal-property property">payload</span><span class="token operator">:</span> <span class="token string">'&lt;li&gt;text&lt;/li&gt;'</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用 dispatch 派发 action，action 会进入到 reducer 里触发对应的更新</span>
store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span>
</code></pre></div>
<p>以上这段代码，是从编码角度对 Redux 主要工作流的概括，这里我同样为你总结了一张对应的流程图：</p>
<p><img alt="" src="https://s.poetries.top/images/20210426215948.png"></p>
<p><strong>Redux源码</strong></p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">createStore</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">reducer</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> state<span class="token punctuation">;</span>
    <span class="token comment">//获取状态对象</span>
    <span class="token comment">//存放所有的监听函数</span>
    <span class="token keyword">let</span> listeners <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token function-variable function">getState</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">;</span>
    <span class="token comment">//提供一个方法供外部调用派发action</span>
    <span class="token keyword">let</span> <span class="token function-variable function">dispath</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">action</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">//调用管理员reducer得到新的state</span>
        state <span class="token operator">=</span> <span class="token function">reducer</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//执行所有的监听函数</span>
        listeners<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">l</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">l</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//订阅状态变化事件，当状态改变发生之后执行监听函数</span>
    <span class="token keyword">let</span> <span class="token function-variable function">subscribe</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">listener</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        listeners<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">dispath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        getState<span class="token punctuation">,</span>
        dispath<span class="token punctuation">,</span>
        subscribe
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token function-variable function">combineReducers</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">renducers</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token comment">//传入一个renducers管理组，返回的是一个renducer</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>action<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> newState<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> attr <span class="token keyword">in</span> renducers<span class="token punctuation">)</span><span class="token punctuation">{</span>
            newState<span class="token punctuation">[</span>attr<span class="token punctuation">]</span><span class="token operator">=</span>renducers<span class="token punctuation">[</span>attr<span class="token punctuation">]</span><span class="token punctuation">(</span>state<span class="token punctuation">[</span>attr<span class="token punctuation">]</span><span class="token punctuation">,</span>action<span class="token punctuation">)</span>

        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> newState<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span>createStore<span class="token punctuation">,</span>combineReducers<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div>
<p><strong>聊聊 Redux 和 Vuex 的设计思想</strong></p>
<ul><li><strong>共同点</strong></li></ul>
<blockquote><p>首先两者都是处理全局状态的工具库，大致实现思想都是：全局<code>state</code>保存状态----&gt;<code>dispatch(action)</code>------&gt;<code>reducer</code>(<code>vuex</code>里的<code>mutation</code>)----&gt; 生成<code>newState</code>; 整个状态为同步操作；</p></blockquote>
<ul><li><strong>区别</strong></li></ul>
<blockquote><p>最大的区别在于处理异步的不同，vuex里面多了一步<code>commit</code>操作，在<code>action</code>之后<code>commit(mutation)</code>之前处理异步，而<code>redux</code>里面则是通过中间件处理</p></blockquote>
<p><strong>redux 中间件</strong></p>
<blockquote><p>中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。变为 action -&gt; middlewares -&gt; reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过 滤，日志输出，异常报告等功能</p></blockquote>
<p>常见的中间件:</p>
<ul><li><code>redux-logger</code>:提供日志输出;</li> <li><code>redux-thunk</code>:处理异步操作;</li> <li><code>redux-promise</code>: 处理异步操作;</li> <li><code>actionCreator</code> 的返回值是 <code>promise</code></li></ul>
<p><strong>redux中间件的原理是什么</strong></p>
<p><code>applyMiddleware</code></p>
<p><strong>为什么会出现中间件？</strong></p>
<ul><li>它只是一个用来加工dispatch的工厂，而要加工什么样的dispatch出来，则需要我们传入对应的中间件函数</li> <li>让每一个中间件函数，接收一个dispatch，然后返回一个改造后的dispatch，来作为下一个中间件函数的next，以此类推。</li></ul>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">applyMiddleware</span><span class="token punctuation">(</span><span class="token parameter">middlewares</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  middlewares <span class="token operator">=</span> middlewares<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  middlewares<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">let</span> dispatch <span class="token operator">=</span> store<span class="token punctuation">.</span>dispatch
  middlewares<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">middleware</span> <span class="token operator">=&gt;</span>
    dispatch <span class="token operator">=</span> <span class="token function">middleware</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
  <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> store<span class="token punctuation">,</span> <span class="token punctuation">{</span> dispatch <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div>
<blockquote><p>上面的<code>middleware(store)(dispatch)</code> 就相当于是 <code>const logger = store =&gt; next =&gt; {}</code>，这就是构造后的dispatch，继续向下传递。这里<code>middlewares.reverse()</code>，进行数组反转的原因，是最后构造的<code>dispatch</code>，实际上是最先执行的。因为在<code>applyMiddleware</code>串联的时候，每个中间件只是返回一个新的<code>dispatch</code>函数给下一个中间件，实际上这个<code>dispatch</code>并不会执行。只有当我们在程序中通过<code>store.dispatch(action)</code>，真正派发的时候，才会执行。而此时的<code>dispatch</code>是最后一个中间件返回的包装函数。然后依次向前递推执行。</p></blockquote>
<p><a href="http://interview.poetries.top/principle-docs/react/08-%E6%B5%85%E6%9E%90%E4%B8%AD%E9%97%B4%E4%BB%B6.html" target="_blank" rel="noopener noreferrer">浅析中间件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p>
<p><strong>action、store、reducer分析</strong></p>
<blockquote><p>redux的核心概念就是store、action、reducer，从调用关系来看如下所示</p></blockquote>
<div class="language-javascript extra-class"><pre class="language-javascript"><code>store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token function">reducer</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> action<span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">&gt;</span> final state
</code></pre></div>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// reducer方法, 传入的参数有两个</span>
<span class="token comment">// state: 当前的state</span>
<span class="token comment">// action: 当前触发的行为, {type: 'xx'}</span>
<span class="token comment">// 返回值: 新的state</span>
<span class="token keyword">var</span> <span class="token function-variable function">reducer</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">'add_todo'</span><span class="token operator">:</span>
            <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>action<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">return</span> state<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 创建store, 传入两个参数</span>
<span class="token comment">// 参数1: reducer 用来修改state</span>
<span class="token comment">// 参数2(可选): [], 默认的state值,如果不传, 则为undefined</span>
<span class="token keyword">var</span> store <span class="token operator">=</span> redux<span class="token punctuation">.</span><span class="token function">createStore</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 通过 store.getState() 可以获取当前store的状态(state)</span>
<span class="token comment">// 默认的值是 createStore 传入的第二个参数</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'state is: '</span> <span class="token operator">+</span> store<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// state is:</span>

<span class="token comment">// 通过 store.dispatch(action) 来达到修改 state 的目的</span>
<span class="token comment">// 注意: 在redux里,唯一能够修改state的方法,就是通过 store.dispatch(action)</span>
store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'add_todo'</span><span class="token punctuation">,</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">'读书'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 打印出修改后的state</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'state is: '</span> <span class="token operator">+</span> store<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// state is: 读书</span>

store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'add_todo'</span><span class="token punctuation">,</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">'写作'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'state is: '</span> <span class="token operator">+</span> store<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// state is: 读书,写作</span>
</code></pre></div>
<ol><li>store、reducer、action关联</li></ol>
<p><strong>store</strong></p>
<ul><li><code>store</code>在这里代表的是数据模型，内部维护了一个<code>state</code>变量</li> <li><code>store</code>有两个核心方法，分别是<code>getState</code>、<code>dispatch</code>。前者用来获取<code>store</code>的状态（<code>state</code>），后者用来修改<code>store</code>的状态</li></ul>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 创建store, 传入两个参数</span>
<span class="token comment">// 参数1: reducer 用来修改state</span>
<span class="token comment">// 参数2(可选): [], 默认的state值,如果不传, 则为undefined</span>
<span class="token keyword">var</span> store <span class="token operator">=</span> redux<span class="token punctuation">.</span><span class="token function">createStore</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 通过 store.getState() 可以获取当前store的状态(state)</span>
<span class="token comment">// 默认的值是 createStore 传入的第二个参数</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'state is: '</span> <span class="token operator">+</span> store<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// state is:</span>

<span class="token comment">// 通过 store.dispatch(action) 来达到修改 state 的目的</span>
<span class="token comment">// 注意: 在redux里,唯一能够修改state的方法,就是通过 store.dispatch(action)</span>
store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'add_todo'</span><span class="token punctuation">,</span> <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">'读书'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<p><strong>action</strong></p>
<ul><li>对行为（如用户行为）的抽象，在<code>redux</code>里是一个普通的<code>js</code>对象</li> <li><code>action</code>必须有一个<code>type</code>字段来标识这个行为的类型</li></ul>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span><span class="token string">'add_todo'</span><span class="token punctuation">,</span> <span class="token literal-property property">text</span><span class="token operator">:</span><span class="token string">'读书'</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span><span class="token string">'add_todo'</span><span class="token punctuation">,</span> <span class="token literal-property property">text</span><span class="token operator">:</span><span class="token string">'写作'</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span><span class="token string">'add_todo'</span><span class="token punctuation">,</span> <span class="token literal-property property">text</span><span class="token operator">:</span><span class="token string">'睡觉'</span><span class="token punctuation">,</span> <span class="token literal-property property">time</span><span class="token operator">:</span><span class="token string">'晚上'</span><span class="token punctuation">}</span>
</code></pre></div>
<p><strong>reducer</strong></p>
<ul><li>一个普通的函数，用来修改<code>store</code>的状态。传入两个参数 <code>state</code>、<code>action</code></li> <li>其中，<code>state</code>为当前的状态（可通过<code>store.getState()</code>获得），而<code>action</code>为当前触发的行为（通过<code>store.dispatch(action)</code>调用触发）</li> <li><code>reducer(state, action)</code> 返回的值，就是<code>store</code>最新的<code>state</code>值</li></ul>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// reducer方法, 传入的参数有两个</span>
<span class="token comment">// state: 当前的state</span>
<span class="token comment">// action: 当前触发的行为, {type: 'xx'}</span>
<span class="token comment">// 返回值: 新的state</span>
<span class="token keyword">var</span> <span class="token function-variable function">reducer</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">'add_todo'</span><span class="token operator">:</span>
            <span class="token keyword">return</span> state<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>action<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">return</span> state<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div>
<ol start="2"><li>关于<code>actionCreator</code></li></ol>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token function">actionCreator</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> action
</code></pre></div>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">addTodo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'add_todo'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">text</span><span class="token operator">:</span> text
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">addTodo</span><span class="token punctuation">(</span><span class="token string">'睡觉'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回：{type: 'add_todo', text: '睡觉'}</span>
</code></pre></div>
<p><strong>异步Action及操作</strong></p>
<ol><li>创建同步Action</li></ol>
<blockquote><p><code>Action</code>是数据从应用传递到 <code>store</code>/<code>state</code> 的载体，也是开启一次完成数据流的开始</p></blockquote>
<p><strong>普通的action对象</strong></p>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> action <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">type</span><span class="token operator">:</span><span class="token string">'ADD_TODO'</span><span class="token punctuation">,</span>
	<span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'poetries'</span>
<span class="token punctuation">}</span>

<span class="token function">dispatch</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span>
</code></pre></div>
<p><strong>封装action creator</strong></p>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">actionCreator</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
    	<span class="token literal-property property">type</span><span class="token operator">:</span><span class="token string">'ADD_TODO'</span><span class="token punctuation">,</span>
    	<span class="token literal-property property">data</span><span class="token operator">:</span>data
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">actionCreator</span><span class="token punctuation">(</span><span class="token string">'poetries'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div>
<p><strong>bindActionCreators合并</strong></p>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>id</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	reurn <span class="token punctuation">{</span>
		<span class="token literal-property property">type</span><span class="token operator">:</span><span class="token string">'a'</span><span class="token punctuation">,</span>
		name<span class="token punctuation">,</span>
		id
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>id</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	reurn <span class="token punctuation">{</span>
		<span class="token literal-property property">type</span><span class="token operator">:</span><span class="token string">'b'</span><span class="token punctuation">,</span>
		name<span class="token punctuation">,</span>
		id
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> actions <span class="token operator">=</span> Redux<span class="token punctuation">.</span><span class="token function">bindActionCreators</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token punctuation">,</span>b<span class="token punctuation">}</span><span class="token punctuation">,</span>store<span class="token punctuation">.</span>dispatch<span class="token punctuation">)</span>

<span class="token comment">//调用</span>
actions<span class="token punctuation">.</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token string">'poetries'</span><span class="token punctuation">,</span><span class="token string">'id001'</span><span class="token punctuation">)</span>
actions<span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token string">'jing'</span><span class="token punctuation">,</span><span class="token string">'id002'</span><span class="token punctuation">)</span>
</code></pre></div>
<p><strong>action创建的标准</strong></p>
<blockquote><p>在Flux的架构中，一个Action要符合 FSA(Flux Standard Action) 规范，需要满足如下条件</p></blockquote>
<ul><li>是一个纯文本对象</li> <li>只具备 <code>type</code> 、<code>payload</code>、<code>error</code> 和 <code>meta</code>中的一个或者多个属性。<code>type</code> 字段不可缺省，其它字段可缺省</li> <li>若 <code>Action</code> 报错，<code>error</code> 字段不可缺省，切必须为 <code>true</code></li></ul>
<blockquote><p><code>payload</code> 是一个对象，用作Action携带数据的载体</p></blockquote>
<p><strong>标准action示例</strong></p>
<ul><li>A basic Flux Standard Action:</li></ul>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'ADD_TODO'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">payload</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">'Do something.'</span>  
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ul><li>An FSA that represents an error, analogous to a rejected Promise</li></ul>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'ADD_TODO'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">payload</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token literal-property property">error</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre></div>
<blockquote><p>https://github.com/acdlite/flux-standard-action</p></blockquote>
<ul><li>可以采用如下一个简单的方式检验一个<code>Action</code>是否符合FSA标准</li></ul>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// every有一个匹配不到返回false</span>
<span class="token keyword">let</span> isFSA <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span>  <span class="token punctuation">[</span><span class="token string">'payload'</span><span class="token punctuation">,</span><span class="token string">'type'</span><span class="token punctuation">,</span><span class="token string">'error'</span><span class="token punctuation">,</span><span class="token string">'meta'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">&gt;</span>  <span class="token operator">-</span><span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div>
<ol start="2"><li>创建异步action的多种方式</li></ol>
<blockquote><p>最简单的方式就是使用同步的方式来异步，将原来同步时一个<code>action</code>拆分成多个异步的<code>action</code>的，在异步开始前、异步请求中、异步正常返回（异常）操作分别使用同步的操作，从而模拟出一个异步操作了。这样的方式是比较麻烦的，现在已经有<code>redux-saga</code>等插件来解决这些问题了</p></blockquote>
<p><strong>异步action的实现方式一：setTimeout</strong></p>
<blockquote><p><code>redux-thunk</code>中间处理解析</p></blockquote>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">thunkAction</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">reutrn</span> <span class="token punctuation">(</span><span class="token parameter">dispatch</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                <span class="token literal-property property">type</span><span class="token operator">:</span><span class="token string">'ADD_TODO'</span><span class="token punctuation">,</span>
                data
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p><strong>异步action的实现方式二：promise实现异步action</strong></p>
<blockquote><p><code>redux-promise</code>中间处理这种<code>action</code></p></blockquote>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">promiseAction</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">param</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                <span class="token literal-property property">type</span><span class="token operator">:</span><span class="token string">'ADD_TODO'</span><span class="token punctuation">,</span>
                name
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">param</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token string">"action2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">param</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token string">"action3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="3"><li>redux异步流程</li></ol>
<p><img alt="" src="https://s.poetries.top/images/20210427115241.png"></p>
<ul><li>首先发起一个action，然后通过中间件，这里为什么要用中间件呢，因为这样<code>dispatch</code>的返回值才能是一个函数。</li> <li>通过<code>store.dispatch</code>，将状态的的改变传给<code>store</code>的小弟<code>reducer</code>，<code>reducer</code>根据<code>action</code>的改变，传递新的状态<code>state</code>。</li> <li>最后将所有的改变告诉给它的大哥，<code>store</code>。<code>store</code>保存着所有的数据，并将数据注入到组件的顶部，这样组件就可以获得它需要的数据了</li></ul>
<ol start="4"><li>Redux异步方案选型</li></ol>
<p><strong>redux-thunk</strong></p>
<blockquote><p><code>Redux</code>本身只能处理同步的<code>Action</code>，但可以通过中间件来拦截处理其它类型的<code>action</code>，比如函数(<code>Thunk</code>)，再用回调触发普通<code>Action</code>，从而实现异步处理</p></blockquote>
<ul><li>发送异步的<code>action</code>其实是被中间件捕获的，函数类型的action就被<code>middleware</code>捕获。至于怎么定义异步的<code>action</code>要看你用哪个中间件，根据他们的实例来定义，这样才会正确解析<code>action</code></li></ul>
<blockquote><p><code>Redux</code> 本身不处理异步行为，需要依赖中间件。结合 <code>redux-actions</code> 使用，<code>Redux</code> 有两个推荐的异步中间件</p></blockquote>
<ul><li><code>redux-thunk</code></li> <li><code>redux-promise</code></li></ul>
<blockquote><p><code>redux-thunk</code> 的源码如下</p></blockquote>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createThunkMiddleware</span><span class="token punctuation">(</span><span class="token parameter">extraArgument</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> getState <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token parameter">next</span> <span class="token operator">=&gt;</span> <span class="token parameter">action</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> action <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">action</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> getState<span class="token punctuation">,</span> extraArgument<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> thunk <span class="token operator">=</span> <span class="token function">createThunkMiddleware</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thunk<span class="token punctuation">.</span>withExtraArgument <span class="token operator">=</span> createThunkMiddleware<span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> thunk<span class="token punctuation">;</span>
</code></pre></div>
<blockquote><p>源码可知，<code>action creator</code> 需要返回一个函数给 <code>redux-thunk</code> 进行调用，示例如下</p></blockquote>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">let</span> <span class="token function-variable function">addTodoWithThunk</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">dispatch<span class="token punctuation">,</span> getState</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token comment">//请求之前的一些处理</span>

    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>val <span class="token operator">+</span> <span class="token string">' thunk'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">type</span><span class="token operator">:</span><span class="token constant">CONSTANT</span><span class="token punctuation">.</span><span class="token constant">ADD_TO_DO_THUNK</span><span class="token punctuation">,</span>
        <span class="token literal-property property">payload</span><span class="token operator">:</span><span class="token punctuation">{</span>
            value
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div>
<ul><li>而它使用起来最大的问题，就是重复的模板代码太多</li></ul>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//action types</span>
<span class="token keyword">const</span> <span class="token constant">GET_DATA</span> <span class="token operator">=</span> <span class="token string">'GET_DATA'</span><span class="token punctuation">,</span>
    <span class="token constant">GET_DATA_SUCCESS</span> <span class="token operator">=</span> <span class="token string">'GET_DATA_SUCCESS'</span><span class="token punctuation">,</span>
    <span class="token constant">GET_DATA_FAILED</span> <span class="token operator">=</span> <span class="token string">'GET_DATA_FAILED'</span><span class="token punctuation">;</span>
    
<span class="token comment">//action creator</span>
<span class="token keyword">const</span> <span class="token function-variable function">getDataAction</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token parameter">dispatch<span class="token punctuation">,</span> getState</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token constant">GET_DATA</span><span class="token punctuation">,</span> 
            <span class="token literal-property property">payload</span><span class="token operator">:</span> id
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        api<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token comment">//注：本文所有示例的api.getData都返回promise对象</span>
            <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token constant">GET_DATA_SUCCESS</span><span class="token punctuation">,</span>
                    <span class="token literal-property property">payload</span><span class="token operator">:</span> response
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token constant">GET_DATA_FAILED</span><span class="token punctuation">,</span>
                    <span class="token literal-property property">payload</span><span class="token operator">:</span> error
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//reducer</span>
<span class="token keyword">const</span> <span class="token function-variable function">reducer</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">oldState<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token constant">GET_DATA</span> <span class="token operator">:</span> 
        <span class="token keyword">return</span> oldState<span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">GET_DATA_SUCCESS</span> <span class="token operator">:</span> 
        <span class="token keyword">return</span> successState<span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">GET_DATA_FAILED</span> <span class="token operator">:</span> 
        <span class="token keyword">return</span> errorState<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<blockquote><p>这已经是最简单的场景了，请注意：我们甚至还没写一行业务逻辑，如果每个异步处理都像这样，重复且无意义的工作会变成明显的阻碍</p></blockquote>
<ul><li>另一方面，像<code>GET_DATA_SUCCESS</code>、<code>GET_DATA_FAILED</code>这样的字符串声明也非常无趣且易错
上例中，<code>GET_DATA</code>这个<code>action</code>并不是多数场景需要的</li></ul>
<p><strong>redux-promise</strong></p>
<blockquote><p>由于<code>redux-thunk</code>写起来实在是太麻烦了，社区当然会有其它轮子出现。<code>redux-promise</code>则是其中比较知名的</p></blockquote>
<ul><li>它自定义了一个<code>middleware</code>，当检测到有<code>action</code>的<code>payload</code>属性是<code>Promise</code>对象时，就会
<ul><li>若<code>resolve</code>，触发一个此<code>action</code>的拷贝，但<code>payload</code>为<code>promise</code>的<code>value</code>，并设<code>status</code>属性为<code>"success"</code></li> <li>若<code>reject</code>，触发一个此<code>action</code>的拷贝，但<code>payload</code>为<code>promise</code>的<code>reason</code>，并设<code>status</code>属性为<code>"error"</code></li></ul></li></ul>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//action types</span>
<span class="token keyword">const</span> <span class="token constant">GET_DATA</span> <span class="token operator">=</span> <span class="token string">'GET_DATA'</span><span class="token punctuation">;</span>

<span class="token comment">//action creator</span>
<span class="token keyword">const</span> <span class="token function-variable function">getData</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token constant">GET_DATA</span><span class="token punctuation">,</span>
        <span class="token literal-property property">payload</span><span class="token operator">:</span> api<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token comment">//payload为promise对象</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//reducer</span>
<span class="token keyword">function</span> <span class="token function">reducer</span><span class="token punctuation">(</span><span class="token parameter">oldState<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token constant">GET_DATA</span><span class="token operator">:</span> 
            <span class="token keyword">if</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token string">'success'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> successState
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                   <span class="token keyword">return</span> errorState
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<blockquote><p><code>redux-promise</code>为了精简而做出的妥协非常明显：无法处理乐观更新</p></blockquote>
<p><strong>场景解析之：乐观更新</strong></p>
<blockquote><p>多数异步场景都是悲观更新的，即等到请求成功才渲染数据。而与之相对的乐观更新，则是不等待请求成功，在发送请求的同时立即渲染数据</p></blockquote>
<ul><li>由于乐观更新发生在用户操作时，要处理它，意味着必须有action表示用户的初始动作</li> <li>在上面<code>redux-thunk</code>的例子中，我们看到了<code>GET_DATA</code>, <code>GET_DATA_SUCCESS</code>、<code>GET_DATA_FAILED</code>三个<code>action</code>，分别表示初始动作、异步成功和异步失败，其中第一个<code>action</code>使得<code>redux-thunk</code>具备乐观更新的能力</li> <li>而在<code>redux-promise</code>中，最初触发的action被中间件拦截然后过滤掉了。原因很简单，<code>redux</code>认可的<code>action</code>对象是 <code>plain JavaScript objects</code>，即简单对象，而在<code>redux-promise</code>中，初始<code>action</code>的<code>payload</code>是个<code>Promise</code></li></ul>
<p><strong>redux-promise-middleware</strong></p>
<blockquote><p><code>redux-promise-middleware</code>相比<code>redux-promise</code>，采取了更为温和和渐进式的思路，保留了和<code>redux-thunk</code>类似的三个<code>action</code></p></blockquote>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//action types</span>
<span class="token keyword">const</span> <span class="token constant">GET_DATA</span> <span class="token operator">=</span> <span class="token string">'GET_DATA'</span><span class="token punctuation">,</span>
    <span class="token constant">GET_DATA_PENDING</span> <span class="token operator">=</span> <span class="token string">'GET_DATA_PENDING'</span><span class="token punctuation">,</span>
    <span class="token constant">GET_DATA_FULFILLED</span> <span class="token operator">=</span> <span class="token string">'GET_DATA_FULFILLED'</span><span class="token punctuation">,</span>
    <span class="token constant">GET_DATA_REJECTED</span> <span class="token operator">=</span> <span class="token string">'GET_DATA_REJECTED'</span><span class="token punctuation">;</span>
    
<span class="token comment">//action creator</span>
<span class="token keyword">const</span> <span class="token function-variable function">getData</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token constant">GET_DATA</span><span class="token punctuation">,</span>
        <span class="token literal-property property">payload</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">promise</span><span class="token operator">:</span> api<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token literal-property property">data</span><span class="token operator">:</span> id
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//reducer</span>
<span class="token keyword">const</span> <span class="token function-variable function">reducer</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">oldState<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token constant">GET_DATA_PENDING</span> <span class="token operator">:</span>
        <span class="token keyword">return</span> oldState<span class="token punctuation">;</span> <span class="token comment">// 可通过action.payload.data获取id</span>
    <span class="token keyword">case</span> <span class="token constant">GET_DATA_FULFILLED</span> <span class="token operator">:</span> 
        <span class="token keyword">return</span> successState<span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">GET_DATA_REJECTED</span> <span class="token operator">:</span> 
        <span class="token keyword">return</span> errorState<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="5"><li>redux异步操作代码演示</li></ol>
<ul><li>根据官网的async例子分析 https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async</li></ul>
<p><strong>action/index.js</strong></p>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> fetch <span class="token keyword">from</span> <span class="token string">'isomorphic-fetch'</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">RECEIVE_POSTS</span> <span class="token operator">=</span> <span class="token string">'RECEIVE_POSTS'</span>

<span class="token comment">//获取新闻成功的action</span>
<span class="token keyword">function</span> <span class="token function">receivePosts</span><span class="token punctuation">(</span><span class="token parameter">reddit<span class="token punctuation">,</span> json</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token constant">RECEIVE_POSTS</span><span class="token punctuation">,</span>
    <span class="token literal-property property">reddit</span><span class="token operator">:</span> reddit<span class="token punctuation">,</span>
    <span class="token literal-property property">posts</span><span class="token operator">:</span> json<span class="token punctuation">.</span>data<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=&gt;</span>child<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">fetchPosts</span><span class="token punctuation">(</span><span class="token parameter">subreddit</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">dispatch</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">http://www.subreddit.com/r/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>subreddit<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.json</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">json</span> <span class="token operator">=&gt;</span>
        <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">receivePosts</span><span class="token punctuation">(</span>subreddit<span class="token punctuation">,</span> json<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//如果需要则开始获取文章</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">fetchPostsIfNeeded</span><span class="token punctuation">(</span><span class="token parameter">subreddit</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter">dispatch<span class="token punctuation">,</span> getState</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>

      <span class="token keyword">return</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">fetchPosts</span><span class="token punctuation">(</span>subreddit<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<blockquote><p><code>fetchPostsIfNeeded</code>这里就是一个中间件。<code>redux-thunk</code>会拦截<code>fetchPostsIfNeeded</code>这个<code>action</code>，会先发起数据请求，如果成功，就将数据传给<code>action</code>从而到达<code>reducer</code>那里</p></blockquote>
<p><strong>reducers/index.js</strong></p>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> combineReducers <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>
  <span class="token constant">RECEIVE_POSTS</span>
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../actions'</span>


<span class="token keyword">function</span> <span class="token function">posts</span><span class="token punctuation">(</span><span class="token parameter">state <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">items</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">case</span> <span class="token constant">RECEIVE_POSTS</span><span class="token operator">:</span>
      <span class="token comment">// Object.assign是ES6的一个语法。合并对象，将对象合并为一个，前后相同的话，后者覆盖强者。详情可以看这里</span>
      <span class="token comment">//  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</span>
      <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">items</span><span class="token operator">:</span> action<span class="token punctuation">.</span>posts <span class="token comment">//数据都存在了这里</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">return</span> state
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// 将所有的reducer结合为一个,传给store</span>
<span class="token keyword">const</span> rootReducer <span class="token operator">=</span> <span class="token function">combineReducers</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  postsByReddit
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> rootReducer
</code></pre></div>
<blockquote><p>这个跟正常的<code>reducer</code>差不多。判断<code>action</code>的类型，从而根据<code>action</code>的不同类型，返回不同的数据。这里将数据存储在了<code>items</code>这里。这里的<code>reducer</code>只有一个。最后结合成<code>rootReducer</code>,传给<code>store</code></p></blockquote>
<p><strong>store/configureStore.js</strong></p>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createStore<span class="token punctuation">,</span> applyMiddleware <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux'</span>
<span class="token keyword">import</span> thunkMiddleware <span class="token keyword">from</span> <span class="token string">'redux-thunk'</span>
<span class="token keyword">import</span> createLogger <span class="token keyword">from</span> <span class="token string">'redux-logger'</span>
<span class="token keyword">import</span> rootReducer <span class="token keyword">from</span> <span class="token string">'../reducers'</span>

<span class="token keyword">const</span> createStoreWithMiddleware <span class="token operator">=</span> <span class="token function">applyMiddleware</span><span class="token punctuation">(</span>
  thunkMiddleware<span class="token punctuation">,</span>  
  <span class="token function">createLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token punctuation">)</span><span class="token punctuation">(</span>createStore<span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">configureStore</span><span class="token punctuation">(</span><span class="token parameter">initialState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStoreWithMiddleware</span><span class="token punctuation">(</span>rootReducer<span class="token punctuation">,</span> initialState<span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>module<span class="token punctuation">.</span>hot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Enable Webpack hot module replacement for reducers</span>
    module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">'../reducers'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> nextRootReducer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../reducers'</span><span class="token punctuation">)</span>
      store<span class="token punctuation">.</span><span class="token function">replaceReducer</span><span class="token punctuation">(</span>nextRootReducer<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> store
<span class="token punctuation">}</span>
</code></pre></div>
<ul><li>我们是如何在 <code>dispatch</code> 机制中引入 <code>Redux Thunk middleware</code> 的呢？
我们使用了<code>applyMiddleware()</code></li> <li>通过使用指定的 <code>middleware</code>，<code>action creator</code> 除了返回 <code>action</code> 对象外还可以返回函数</li> <li>这时，这个 <code>action creator</code> 就成为了 <code>thunk</code></li></ul>
<p><strong>界面上的调用：在containers/App.js</strong></p>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//初始化渲染后触发</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> dispatch<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props
    <span class="token comment">// 这里可以传两个值，一个是 reactjs 一个是 frontend</span>
    <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">fetchPostsIfNeeded</span><span class="token punctuation">(</span><span class="token string">'frontend'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div>
<blockquote><p>改变状态的时候也是需要通过<code>dispatch</code>来传递的</p></blockquote>
<ul><li>数据的获取是通过<code>provider</code>,将<code>store</code>里面的数据注入给组件。让顶级组件提供给他们的子孙组件调用。代码如下：</li></ul>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token string">'babel-core/polyfill'</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-dom'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Provider <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-redux'</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./containers/App'</span>
<span class="token keyword">import</span> configureStore <span class="token keyword">from</span> <span class="token string">'./store/configureStore'</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">configureStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">render</span><span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>Provider store<span class="token operator">=</span><span class="token punctuation">{</span>store<span class="token punctuation">}</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>Provider<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre></div>
<blockquote><p>这样就完成了<code>redux</code>的异步操作。其实最主要的区别还是<code>action</code>里面还有中间件的调用，其他的地方基本跟同步的<code>redux</code>差不多的。搞懂了中间件，就基本搞懂了<code>redux</code>的异步操作</p></blockquote>
<p><img alt="" src="https://s.poetries.top/images/20210427115322.png"></p>
<h3 id="_18-谈谈你对状态管理的理解"><a href="#_18-谈谈你对状态管理的理解" class="header-anchor">#</a> 18 谈谈你对状态管理的理解</h3>
<ul><li>首先介绍 Flux，Flux 是一种使用单向数据流的形式来组合 React 组件的应用架构。</li> <li>Flux 包含了 4 个部分，分别是 <code>Dispatcher</code>、 <code>Store</code>、<code>View</code>、<code>Action</code>。<code>Store</code> 存储了视图层所有的数据，当 <code>Store</code> 变化后会引起 View 层的更新。如果在视图层触发一个 <code>Action</code>，就会使当前的页面数据值发生变化。Action 会被 Dispatcher 进行统一的收发处理，传递给 Store 层，Store 层已经注册过相关 Action 的处理逻辑，处理对应的内部状态变化后，触发 View 层更新。</li> <li><code>Flux 的优点是单向数据流，解决了 MVC 中数据流向不清的问题</code>，使开发者可以快速了解应用行为。从项目结构上简化了视图层设计，明确了分工，数据与业务逻辑也统一存放管理，使在大型架构的项目中更容易管理、维护代码。</li> <li><code>其次是 Redux</code>，Redux 本身是一个 JavaScript 状态容器，提供可预测化状态的管理。社区通常认为 Redux 是 Flux 的一个简化设计版本，它提供的状态管理，简化了一些高级特性的实现成本，比如撤销、重做、实时编辑、时间旅行、服务端同构等。</li> <li>Redux 的核心设计包含了三大原则：<code>单一数据源、纯函数 Reducer、State 是只读的</code>。</li> <li>Redux&nbsp;中整个数据流的方案与 Flux 大同小异</li> <li>Redux 中的另一大核心点是处理“副作用”，AJAX 请求等异步工作，或不是纯函数产生的第三方的交互都被认为是 “副作用”。这就造成在纯函数设计的 Redux 中，处理副作用变成了一件至关重要的事情。社区通常有两种解决方案：
<ul><li>第一类是在 <code>Dispatch</code> 的时候会有一个 <code>middleware 中间件层</code>，拦截分发的 <code>Action 并添加额外的复杂行为</code>，还可以添加副作用。第一类方案的流行框架有 <code>Redux-thunk、Redux-Promise、Redux-Observable、Redux-Saga</code> 等。</li> <li>第二类是允许 <code>Reducer</code> 层中直接处理副作用，采取该方案的有 <code>React Loop</code>，<code>React Loop</code> 在实现中采用了 Elm 中分形的思想，使代码具备更强的组合能力。</li> <li>除此以外，社区还提供了更为工程化的方案，比如 <code>rematch 或 dva</code>，提供了更详细的模块架构能力，提供了拓展插件以支持更多功能。</li></ul></li> <li>Redux 的优点很多：
<ul><li>结果可预测；</li> <li>代码结构严格易维护；</li> <li>模块分离清晰且小函数结构容易编写单元测试；</li> <li><code>Action</code> 触发的方式，可以在调试器中使用时间回溯，定位问题更简单快捷；</li> <li>单一数据源使服务端同构变得更为容易；社区方案多，生态也更为繁荣。</li></ul></li> <li><code>最后是 Mobx</code>，Mobx 通过监听数据的属性变化，可以直接在数据上更改触发UI 的渲染。在使用上更接近 Vue，比起 <code>Flux 与 Redux</code> 的手动挡的体验，更像开自动挡的汽车。<code>Mobx 的响应式实现原理与 Vue 相同</code>，以 <code>Mobx 5</code> 为分界点，5 以前采用 <code>Object.defineProperty</code> 的方案，5 及以后使用 <code>Proxy</code> 的方案。<code>它的优点是样板代码少、简单粗暴、用户学习快、响应式自动更新数据</code>让开发者的心智负担更低。</li> <li>Mobx 在开发项目时简单快速，但应用 Mobx 的场景 ，其实完全可以用 Vue 取代。如果纯用 Vue，体积还会更小巧</li></ul>
<p><img alt="" src="https://s.poetries.top/images/20210425201200.png"></p>
<h3 id="_19-connect组件原理分析"><a href="#_19-connect组件原理分析" class="header-anchor">#</a> 19 connect组件原理分析</h3>
<p><strong>1. connect用法</strong></p>
<blockquote><p>作用：连接<code>React</code>组件与 <code>Redux store</code></p></blockquote>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">[</span>mapStateToProps<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>mapDispatchToProps<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>mergeProps<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// 这个函数允许我们将 store 中的数据作为 props 绑定到组件上</span>
<span class="token keyword">const</span> <span class="token function-variable function">mapStateToProps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> state<span class="token punctuation">.</span>count
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ul><li>这个函数的第一个参数就是 <code>Redux</code> 的 <code>store</code>，我们从中摘取了 <code>count</code> 属性。你不必将 <code>state</code> 中的数据原封不动地传入组件，可以根据 <code>state</code> 中的数据，动态地输出组件需要的（最小）属性</li> <li>函数的第二个参数 <code>ownProps</code>，是组件自己的 <code>props</code></li></ul>
<blockquote><p>当 <code>state</code> 变化，或者 <code>ownProps</code> 变化的时候，<code>mapStateToProps</code> 都会被调用，计算出一个新的 <code>stateProps</code>，（在与 <code>ownProps merge</code> 后）更新给组件</p></blockquote>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token function">mapDispatchToProps</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span><span class="token operator">:</span> dispatchProps
</code></pre></div>
<blockquote><p><code>connect</code> 的第二个参数是 <code>mapDispatchToProps</code>，它的功能是，将 <code>action</code> 作为 <code>props</code>绑定到组件上，也会成为 <code>MyComp</code> 的 `props</p></blockquote>
<p><strong>2. 原理解析</strong></p>
<blockquote><p>首先<code>connect</code>之所以会成功，是因为<code>Provider</code>组件</p></blockquote>
<ul><li>在原应用组件上包裹一层，使原来整个应用成为<code>Provider</code>的子组件</li> <li>接收<code>Redux</code>的<code>store</code>作为<code>props</code>，通过<code>context</code>对象传递给子孙组件上的<code>connect</code></li></ul>
<p><strong>connect做了些什么</strong></p>
<blockquote><p>它真正连接 <code>Redux</code> 和 <code>React</code>，它包在我们的容器组件的外一层，它接收上面 <code>Provider</code>提供的 <code>store</code> 里面的 <code>state</code>和 <code>dispatch</code>，传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件</p></blockquote>
<p><strong>3. 源码</strong></p>
<blockquote><p><code>connect</code>是一个高阶函数，首先传入<code>mapStateToProps</code>、<code>mapDispatchToProps</code>，然后返回一个生产<code>Component</code>的函数(<code>wrapWithConnect</code>)，然后再将真正的<code>Component</code>作为参数传入<code>wrapWithConnect</code>，这样就生产出一个经过包裹的<code>Connect</code>组件，该组件具有如下特点</p></blockquote>
<ul><li>通过<code>props.store</code>获取祖先<code>Component</code>的<code>store props</code>包括<code>stateProps</code>、<code>dispatchProps</code>、<code>parentProps</code>,合并在一起得到<code>nextState</code>，作为<code>props</code>传给真正的<code>Component</code></li> <li><code>componentDidMount</code>时，添加事件<code>this.store.subscribe(this.handleChange)</code>，实现页面交互</li> <li><code>shouldComponentUpdate</code>时判断是否有避免进行渲染，提升页面性能，并得到<code>nextState</code></li> <li><code>componentWillUnmount</code>时移除注册的事件<code>this.handleChange</code></li></ul>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 主要逻辑</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token parameter">mapStateToProps<span class="token punctuation">,</span> mapDispatchToProps<span class="token punctuation">,</span> mergeProps<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">wrapWithConnect</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">Connect</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 从祖先Component处获得store</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>store <span class="token operator">=</span> props<span class="token punctuation">.</span>store <span class="token operator">||</span> context<span class="token punctuation">.</span>store
        <span class="token keyword">this</span><span class="token punctuation">.</span>stateProps <span class="token operator">=</span> <span class="token function">computeStateProps</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>store<span class="token punctuation">,</span> props<span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>dispatchProps <span class="token operator">=</span> <span class="token function">computeDispatchProps</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>store<span class="token punctuation">,</span> props<span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">storeState</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token punctuation">}</span>
        <span class="token comment">// 对stateProps、dispatchProps、parentProps进行合并</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 进行判断，当数据发生改变时，Component重新渲染</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>propsChanged <span class="token operator">||</span> mapStateProducedChange <span class="token operator">||</span> dispatchPropsChanged<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateState</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 改变Component的state</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>store<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
              <span class="token literal-property property">storeState</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>store<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 生成包裹组件Connect</span>
          <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>nextState<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
          <span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      Connect<span class="token punctuation">.</span>contextTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">store</span><span class="token operator">:</span> storeShape
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> Connect<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h3 id="_20-react-hooks"><a href="#_20-react-hooks" class="header-anchor">#</a> 20 React Hooks</h3>
<ul><li>代码逻辑聚合，逻辑复用</li> <li>HOC嵌套地狱</li> <li>代替class</li></ul>
<blockquote><p>React 中通常使用 类定义 或者 函数定义 创建组件:</p></blockquote>
<p>在类定义中，我们可以使用到许多 React 特性，例如 state、 各种组件生命周期钩子等，但是在函数定义中，我们却无能为力，因此 React 16.8 版本推出了一个新功能 (React Hooks)，通过它，可以更好的在函数定义组件中使用 React 特性。</p>
<p><strong>函数组件与类组件的对比：无关“优劣”，只谈“不同”</strong></p>
<ul><li>类组件需要继承 class，函数组件不需要；</li> <li>类组件可以访问生命周期方法，函数组件不能；</li> <li>类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；</li> <li>类组件中可以定义并维护 state（状态），而函数组件不可以；</li></ul>
<blockquote><p>但是类组件它太重了，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的</p></blockquote>
<p><strong>react hooks的好处:</strong></p>
<ol><li>跨组件复用: 其实 render props / HOC 也是为了复用，相比于它们，Hooks 作为官方的底层 API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的嵌套地狱；</li> <li>类定义更为复杂</li></ol>
<ul><li>不同的生命周期会使逻辑变得分散且混乱，不易维护和管理；</li> <li>时刻需要关注this的指向问题；</li> <li>代码复用代价高，高阶组件的使用经常会使整个组件树变得臃肿；</li></ul>
<ol start="3"><li>状态与UI隔离: 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个自定义 Hooks，组件中的状态和 UI 变得更为清晰和隔离。</li></ol>
<p><strong>注意:</strong></p>
<ul><li>避免在 循环/条件判断/嵌套函数 中调用 hooks，保证调用顺序的稳定；</li> <li>只有 函数定义组件 和 hooks 可以调用 hooks，避免在 类组件 或者 普通函数 中调用；</li> <li>不能在useEffect中使用useState，React 会报错提示；</li> <li>类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存；</li></ul>
<p><strong>重要钩子</strong></p>
<ol><li>状态钩子 (useState): 用于定义组件的 State，其到类定义中this.state的功能；</li></ol>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// useState 只接受一个参数: 初始状态</span>
<span class="token comment">// 返回的是组件名和更改该组件对应的函数</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>flag<span class="token punctuation">,</span> setFlag<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 修改状态</span>
<span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
	
<span class="token comment">// 上面的代码映射到类定义中:</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">flag</span><span class="token operator">:</span> <span class="token boolean">true</span>	
<span class="token punctuation">}</span>
<span class="token keyword">const</span> flag <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>flag
<span class="token keyword">const</span> <span class="token function-variable function">setFlag</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">bool</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">flag</span><span class="token operator">:</span> bool<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="2"><li>生命周期钩子 (useEffect):</li></ol>
<blockquote><p>类定义中有许多生命周期函数，而在 React Hooks 中也提供了一个相应的函数 (useEffect)，这里可以看做componentDidMount、componentDidUpdate和componentWillUnmount的结合。</p></blockquote>
<p><strong>useEffect(callback, [source])接受两个参数</strong></p>
<ul><li>callback: 钩子回调函数；</li> <li>source: 设置触发条件，仅当 source 发生改变时才会触发；</li> <li>useEffect钩子在没有传入[source]参数时，默认在每次 render 时都会优先调用上次保存的回调中返回的函数，后再重新调用回调；</li></ul>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	<span class="token comment">// 组件挂载后执行事件绑定</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'on'</span><span class="token punctuation">)</span>
	<span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	
	<span class="token comment">// 组件 update 时会执行事件解绑</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'off'</span><span class="token punctuation">)</span>
		<span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>source<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// 每次 source 发生改变时，执行结果(以类定义的生命周期，便于大家理解):</span>
<span class="token comment">// --- DidMount ---</span>
<span class="token comment">// 'on'</span>
<span class="token comment">// --- DidUpdate ---</span>
<span class="token comment">// 'off'</span>
<span class="token comment">// 'on'</span>
<span class="token comment">// --- DidUpdate ---</span>
<span class="token comment">// 'off'</span>
<span class="token comment">// 'on'</span>
<span class="token comment">// --- WillUnmount --- </span>
<span class="token comment">// 'off'</span>
</code></pre></div>
<p><strong>通过第二个参数，我们便可模拟出几个常用的生命周期:</strong></p>
<ul><li>componentDidMount: 传入[]时，就只会在初始化时调用一次</li></ul>
<div class="language- extra-class"><pre class="language-text"><code>const useMount = (fn) =&gt; useEffect(fn, [])
</code></pre></div>
<ul><li>componentWillUnmount: 传入[]，回调中的返回的函数也只会被最终执行一次</li></ul>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">useUnmount</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> fn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div>
<ul><li>mounted: 可以使用 useState 封装成一个高度可复用的 mounted 状态；</li></ul>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">useMounted</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>mounted<span class="token punctuation">,</span> setMounted<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token operator">!</span>mounted <span class="token operator">&amp;&amp;</span> <span class="token function">setMounted</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setMounted</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> mounted<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ul><li>componentDidUpdate: useEffect每次均会执行，其实就是排除了 DidMount 后即可；</li></ul>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> mounted <span class="token operator">=</span> <span class="token function">useMounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    mounted <span class="token operator">&amp;&amp;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div>
<ol start="3"><li>其它内置钩子:</li></ol>
<ul><li><code>useContext</code>: 获取 context 对象</li> <li><code>useReducer</code>: 类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux:
<ul><li>并不是持久化存储，会随着组件被销毁而销毁；</li> <li>属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据；</li> <li>配合useContext`的全局性，可以完成一个轻量级的 Redux；(easy-peasy)</li></ul></li> <li><code>useCallback</code>: 缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果；</li> <li><code>useMemo</code>: 用于缓存传入的 props，避免依赖的组件每次都重新渲染；</li> <li><code>useRef</code>: 获取组件的真实节点；</li> <li><code>useLayoutEffect</code> <ul><li>DOM更新同步钩子。用法与useEffect类似，只是区别于执行时间点的不同</li> <li>useEffect属于异步执行，并不会等待 DOM 真正渲染后执行，而useLayoutEffect则会真正渲染后才触发；</li> <li>可以获取更新后的 state；</li></ul></li></ul>
<ol start="4"><li>自定义钩子(useXxxxx): 基于 Hooks 可以引用其它 Hooks 这个特性，我们可以编写自定义钩子，如上面的useMounted。又例如，我们需要每个页面自定义标题:</li></ol>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">useTitle</span><span class="token punctuation">(</span><span class="token parameter">title</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      document<span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用:</span>
<span class="token keyword">function</span> <span class="token function">Home</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> title <span class="token operator">=</span> <span class="token string">'我是首页'</span>
	<span class="token function">useTitle</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span>
	
	<span class="token keyword">return</span> <span class="token punctuation">(</span>
		<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
	<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p><strong>React Hooks 的限制</strong></p>
<p><img alt="" src="https://s.poetries.top/images/20210425213051.png"></p>
<ul><li>不要在<code>循环、条件</code>或<code>嵌套函数中调用 Hook</code>；</li> <li>在 React 的函数组件中调用 <code>Hook</code></li></ul>
<blockquote><p>那为什么会有这样的限制呢？就得从 Hooks 的设计说起。Hooks 的设计初衷是为了改进 React 组件的开发模式。在旧有的开发模式下遇到了三个问题。</p></blockquote>
<ul><li>组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、<code>render props</code> 及状态管理框架。</li> <li>复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。</li> <li>常见的有 this 的问题，但在 React 团队中还有类难以优化的问题，他们希望在编译优化层面做出一些改进。</li></ul>
<blockquote><p>这三个问题在一定程度上阻碍了 React 的后续发展，所以为了解决这三个问题，Hooks 基于函数组件开始设计。然而第三个问题决定了 Hooks 只支持函数组件。</p></blockquote>
<p>那为什么不要在循环、条件或嵌套函数中调用 Hook 呢？<code>因为 Hooks 的设计是基于数组实现</code>。在<code>调用时按顺序加入数组中</code>，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，<code>实质上 React 的源码里不是数组，是链表</code>。</p>
<p>这些限制会在编码上造成一定程度的心智负担，新手可能会写错，为了避免这样的情况，可以引入 ESLint 的 Hooks 检查插件进行预防。</p>
<p><strong>useEffect 与 useLayoutEffect 区别在哪里</strong></p>
<p><img alt="" src="https://s.poetries.top/images/20210425213302.png"></p>
<ul><li>它们的共同点很简单，底层的函数签名是完全一致的，都是调用的 <code>mountEffectImpl</code>，在使用上也没什么差异，基本可以直接替换，也都是用于处理副作用。</li> <li>那不同点就很大了，<code>useEffect</code> 在 React 的渲染过程中是被异步调用的，用于绝大多数场景，而 <code>LayoutEffect</code> 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 <code>LayoutEffect</code> 做计算量较大的耗时任务从而造成阻塞。</li> <li>在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 <code>useEffect</code>，一般问题不大；如果页面有异常，再直接替换为 <code>useLayoutEffect</code> 即可。</li></ul>
<h3 id="_21-受控组件和非受控组件"><a href="#_21-受控组件和非受控组件" class="header-anchor">#</a> 21 受控组件和非受控组件</h3>
<div class="language- extra-class"><pre class="language-text"><code>&lt;FInput value = {x} onChange = {fn} /&gt; 
// 上面的是受控组件 下面的是非受控组件
&lt;FInput defaultValue = {x} /&gt;
</code></pre></div>
<ul><li>当你一个组件同时传递一个value以及onChange事件时，它就是一个受控组件，收入输出都是我来控制的。</li> <li>第二个只是传递了默认的初时值，并没有传onchange事件，</li> <li>非受控组件是一种反模式，它的值不受组件自身的state或props控制</li></ul>
<h3 id="_22-如何避免ajax数据请求重新获取"><a href="#_22-如何避免ajax数据请求重新获取" class="header-anchor">#</a> 22 如何避免ajax数据请求重新获取</h3>
<blockquote><p>一般而言，ajax请求的数据都放在redux中存取。</p></blockquote>
<h3 id="_23-组件之间通信"><a href="#_23-组件之间通信" class="header-anchor">#</a> 23 组件之间通信</h3>
<ul><li>父子组件通信</li> <li>自定义事件</li> <li>redux和context</li></ul>
<p><strong>context如何运用</strong></p>
<ul><li>父组件向其下所有子孙组件传递信息</li> <li>如一些简单的信息：主题、语言</li> <li>复杂的公共信息用redux</li></ul>
<blockquote><p>在跨层级通信中，主要分为一层或多层的情况</p></blockquote>
<ul><li>如果只有一层，那么按照 React 的树形结构进行分类的话，主要有以下三种情况：<code>父组件向子组件通信</code>，<code>子组件向父组件通信</code>以及<code>平级的兄弟组件间互相通信</code>。</li> <li><strong>在父与子的情况下</strong>，因为 React 的设计实际上就是传递 <code>Props</code> 即可。那么场景体现在容器组件与展示组件之间，通过 <code>Props</code> 传递 <code>state</code>，让展示组件受控。</li> <li><strong>在子与父的情况下</strong>，有两种方式，分别是回调函数与实例函数。回调函数，比如输入框向父级组件返回输入内容，按钮向父级组件传递点击事件等。实例函数的情况有些特别，主要是在父组件中<code>通过 React 的 ref API 获取子组件的实例</code>，然后是<code>通过实例调用子组件的实例函数</code>。这种方式在过去常见于 Modal 框的显示与隐藏</li> <li><strong>多层级间的数据通信，有两种情况</strong>。第一种是一个容器中包含了多层子组件，需要最底部的子组件与顶部组件进行通信。在这种情况下，如果不断透传 Props 或回调函数，不仅代码层级太深，后续也很不好维护。第二种是两个组件不相关，在整个 React 的组件树的两侧，完全不相交。那么基于多层级间的通信一般有三个方案。
<ul><li>第一个是使用 React 的 <code>Context API</code>，最常见的用途是做语言包国际化</li> <li>第二个是使用全局变量与事件。</li> <li>第三个是使用状态管理框架，比如 Flux、Redux 及 Mobx。优点是由于引入了状态管理，使得项目的开发模式与代码结构得以约束，缺点是学习成本相对较高</li></ul></li></ul>
<p><img alt="" src="https://s.poetries.top/images/20210425145857.png"></p>
<h3 id="_24-类组件与函数组件有什么区别呢"><a href="#_24-类组件与函数组件有什么区别呢" class="header-anchor">#</a> 24 类组件与函数组件有什么区别呢？</h3>
<ul><li>作为组件而言，类组件与函数组件在使用与呈现上没有任何不同，性能上在现代浏览器中也不会有明显差异</li> <li>它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。</li> <li>之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。</li> <li>但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。</li> <li>其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。</li> <li>性能优化上，类组件主要依靠 <code>shouldComponentUpdate</code>&nbsp;阻断渲染来提升性能，而函数组件依靠 <code>React.memo</code> 缓存渲染结果来提升性能。</li> <li>从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。</li> <li>类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。</li></ul>
<p><img alt="" src="https://s.poetries.top/images/20210425134417.png"></p>
<h3 id="_25-如何设计react组件"><a href="#_25-如何设计react组件" class="header-anchor">#</a> 25 如何设计React组件</h3>
<p>React 组件应从<code>设计与工程实践</code>两个方向进行探讨</p>
<blockquote><p>从设计上而言，社区主流分类的方案是展示组件与灵巧组件</p></blockquote>
<ul><li><code>展示组件内部没有状态管理，仅仅用于最简单的展示表达</code>。展示组件中最基础的一类组件称作代理组件。代理组件常用于封装常用属性、减少重复代码。很经典的场景就是引入 Antd 的 Button 时，你再自己封一层。如果未来需要替换掉 Antd 或者需要在所有的 Button 上添加一个属性，都会非常方便。基于代理组件的思想还可以继续分类，分为样式组件与布局组件两种，分别是将样式与布局内聚在自己组件内部。</li> <li>从工程实践而言，通过文件夹划分的方式切分代码。我初步常用的分割方式是将页面单独建立一个目录，将复用性略高的 components 建立一个目录，在下面分别建立 basic、container 和 hoc 三类。这样可以保证无法复用的业务逻辑代码尽量留在 Page 中，而可以抽象复用的部分放入 components 中。其中 basic 文件夹放展示组件，由于展示组件本身与业务关联性较低，所以可以使用 Storybook 进行组件的开发管理，提升项目的工程化管理能力</li></ul>
<p><img alt="" src="https://s.poetries.top/images/20210425134939.png"></p>
<h3 id="_26-组件的协同及-不-可控组件"><a href="#_26-组件的协同及-不-可控组件" class="header-anchor">#</a> 26 组件的协同及（不）可控组件</h3>
<p><strong>为什么要进行组件的协同</strong></p>
<ul><li>我们在实际的开发项目的时候，不会只用几个组件，有时候遇到大型的项目，可能会有成千上百的组件，难免会遇到有功能重复的组件。要进行修改，就会修改大部分的文件。所以我们需要进行组件的协同开发。</li></ul>
<p><img alt="" src="https://s.poetries.top/images/20210427114453.png"></p>
<p><strong>什么是组件的协同使用？</strong></p>
<ul><li>组件的协同本质上是对组件的一种组织、管理的方式。</li> <li>目的：
<ul><li>逻辑清晰：这是组件与组件之间的逻辑</li> <li>代码模块化</li> <li>封装细节：像面向对象一样将常用的方法以及数据封装起来</li> <li>提高代码的复用性：因为是组件，相当于一个封装好的东西，用的时候直接调用</li></ul></li></ul>
<p><strong>如何实现组件的协同使用</strong></p>
<ul><li>第一种：增加一个父组件，将其他的组件进行嵌套，更多的是实现代码的封装</li> <li>第二种：通过一些操作从后台获取数据，<code>React</code>中的<code>Mixin</code>，更多的是实现代码的复用</li></ul>
<p><strong>组件嵌套的含义</strong></p>
<ul><li>组件嵌套的本质是父子关系</li></ul>
<p><img alt="" src="https://s.poetries.top/images/20210427114544.png"></p>
<p><strong>组件嵌套的优缺点</strong></p>
<ul><li>优点：
<ul><li>逻辑清晰：父子关系类似于人类中的父子关系</li> <li>模块化开发：每个模块对应一个功能，不同的模块可以同步开发</li> <li>封装细节：开发者必须要关注组件的功能，不需要了解细节</li></ul></li> <li>缺点：
<ul><li>编写难度高：父子组件的关系需要经过深思熟虑，贸然编写可能导致关系混乱，代码难以维护</li> <li>无法掌握所有细节：使用者只知道组件的用法，不知道实现细节，遇到问题难以修复</li></ul></li></ul>
<p><strong>Mixin</strong></p>
<p><strong>Mixin的含义</strong></p>
<ul><li><code>Mixin=一组方法</code>。</li> <li>他的目的是横向抽离出组件的相似代码，把组件的共同作用以及效果的代码提出来</li></ul>
<p><img alt="" src="https://s.poetries.top/images/20210427114655.png"></p>
<p><strong>Mixin的优缺点</strong></p>
<ul><li>优点
<ul><li>代码复用：抽离出通用的代码，减少开发成本，提高开发效率</li> <li>即插即用：可以使用许多现有的<code>Mixin</code>来开发自己的代码</li> <li>适应性强：改动一次代码，影响多个组件</li></ul></li> <li>缺点
<ul><li>编写难度高：<code>Mixin</code>可能被用在各种环境中，想要兼容多种环境就需要更多的  - 码与逻辑，通用的代价是提高复杂度</li> <li>降低代码的可读性：组件的优势在于将逻辑与是界面直接结合在一起，<code>Mixin</code>本质上会分散逻辑，理解起来难度大</li></ul></li></ul>
<p><strong>不可控组件</strong></p>
<p><img alt="" src="https://s.poetries.top/images/20210427114820.png"></p>
<ul><li>上图：<code>defaultValue</code>的值是固定的，这就是一个不可控组件</li> <li>如果要获取<code>input</code>的<code>value</code>值，只有使用<code>ref</code>获取节点来获取值</li></ul>
<p><strong>可控组件</strong></p>
<p><img alt="" src="https://s.poetries.top/images/20210427114833.png"></p>
<ul><li><code>defaultValue</code>的值是根据状态确定了，只需要拿到<code>this.state.value</code>的值就可以了</li> <li>这里需要注意一下：使用<code>value</code>的值是不可修改的，<code>defaultValue</code>的值是可以修改的</li></ul>
<p><strong>可控组件的优点</strong></p>
<ul><li>符合<code>React</code>的数据流</li> <li>数据存储在<code>state</code>中，便于获取</li> <li>便于处理数据</li></ul>
<h3 id="_27-react-router-的实现原理及工作方式分别是什么"><a href="#_27-react-router-的实现原理及工作方式分别是什么" class="header-anchor">#</a> 27 React-Router 的实现原理及工作方式分别是什么</h3>
<ul><li><code>React Router</code> 路由的基础实现原理分为两种，如果是<code>切换 Hash</code> 的方式，那么依靠浏览器 <code>Hash</code> 变化即可；如果是切换网址中的 <code>Path</code>，就要用到 <code>HTML5 History API</code> 中的 <code>pushState</code>、<code>replaceState</code> 等。在使用这个方式时，还需要在服务端完成 <code>historyApiFallback</code> 配置</li> <li>在 <code>React Router</code> 内部主要依靠 <code>history</code> 库完成，这是由 <code>React Router</code> 自己封装的库，为了实现跨平台运行的特性，内部提供两套基础 <code>history</code>，一套是直接使用浏览器的 <code>History API</code>，用于支持 <code>react-router-dom</code>；另一套是基于内存实现的版本，这是自己做的一个数组，用于支持 <code>react-router-native</code>。</li> <li><code>React Router</code> 的工作方式可以分为设计模式与关键模块两个部分。从设计模式的角度出发，在架构上通过 <code>Monorepo</code>进行库的管理。<code>Monorepo</code> 具有团队间透明、迭代便利的优点。其次在整体的数据通信上使用了 Context API 完成上下文传递。</li> <li>在关键模块上，主要分为三类组件：<code>第一类是&nbsp;Context 容器</code>，比如 Router 与 MemoryRouter；<code>第二类是消费者组件，用以匹配路由</code>，主要有 Route、Redirect、Switch 等；<code>第三类是与平台关联的功能组件</code>，比如 <code>Link、NavLink、DeepLinking</code> 等。</li></ul>
<p><img alt="" src="https://s.poetries.top/images/20210425214114.png"></p>
<p><img alt="" src="https://s.poetries.top/images/20210409164620.png"></p>
<p><a href="http://interview.poetries.top/principle-docs/react/01-React-router%E5%8E%9F%E7%90%86.html" target="_blank" rel="noopener noreferrer">React router原理分析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p>
<h3 id="_28-react-17-带来了哪些改变"><a href="#_28-react-17-带来了哪些改变" class="header-anchor">#</a> 28 React 17 带来了哪些改变</h3>
<blockquote><p>最重要的是以下三点：</p></blockquote>
<ul><li>新的 <code>JSX</code> 转换逻辑</li> <li>事件系统重构</li> <li><code>Lane 模型</code>的引入</li></ul>
<p><strong>1. 重构 JSX 转换逻辑</strong></p>
<p>在过去，如果我们在 React 项目中写入下面这样的代码：</p>
<div class="language- extra-class"><pre class="language-text"><code>function MyComponent() {
  return &lt;p&gt;这是我的组件&lt;/p&gt;
}
</code></pre></div>
<p>React 是会报错的，原因是 React 中对 JSX 代码的转换依赖的是 <code>React.createElement</code> 这个函数。因此但凡我们在代码中包含了 JSX，那么就必须在文件中引入 React，像下面这样：</p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>这是我的组件<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>而 <code>React 17 则允许我们在不引入 React 的情况下直接使用 JSX</code>。这是因为在 React 17 中，编译器会自动帮我们引入 JSX 的解析器，也就是说像下面这样一段逻辑：</p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>这是我的组件<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>会被编译器转换成这个样子：</p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>jsx <span class="token keyword">as</span> _jsx<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react/jsx-runtime'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">_jsx</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">'这是我的组件'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p><code>react/jsx-runtime</code> 中的 JSX 解析器将取代 <code>React.createElement</code> 完成 <code>JSX</code> 的编译工作，这个过程对开发者而言是自动化、无感知的。因此，新的 JSX 转换逻辑带来的最显著的改变就是降低了开发者的学习成本。</p>
<p><code>react/jsx-runtime</code> 中的 JSX 解析器看上去似乎在调用姿势上和 <code>React.createElement</code> 区别不大，那么它是否只是 <code>React.createElement</code> 换了个马甲呢？当然不是，它在内部实现了 <code>React.createElement</code> 无法做到的性能优化和简化。在一定情况下，它可能会略微改善编译输出内容的大小</p>
<p><strong>2. 事件系统重构</strong></p>
<p>事件系统在 React 17 中的重构要从以下两个方面来看：</p>
<ul><li>卸掉历史包袱</li> <li>拥抱新的潮流</li></ul>
<p><strong>2.1 卸掉历史包袱：放弃利用 document 来做事件的中心化管控</strong></p>
<blockquote><p>React 16.13.x 版本中的事件系统会通过将所有事件冒泡到 document 来实现对事件的中心化管控</p></blockquote>
<p>这样的做法虽然看上去已经足够巧妙，但仍然有它不聪明的地方——document 是整个文档树的根节点，操作 document 带来的影响范围实在是太大了，这将会使事情变得更加不可控</p>
<blockquote><p>在 React 17 中，React 团队终于正面解决了这个问题：事件的中心化管控不会再全部依赖 <code>document</code>，管控相关的逻辑被转移到了每个 React 组件自己的容器 DOM 节点中。比如说我们在 ID 为 root 的 DOM 节点下挂载了一个 React 组件，像下面代码这样：</p></blockquote>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> rootElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> rootElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<p>那么事件管控相关的逻辑就会被安装到 <code>root 节点</code>上去。这样一来， React 组件就能够自己玩自己的，再也无法对全局的事件流构成威胁了</p>
<p><strong>2.2 拥抱新的潮流：放弃事件池</strong></p>
<p>在 React 17 之前，合成事件对象会被放进一个叫作“事件池”的地方统一管理。这样做的目的是能够实现事件对象的复用，进而提高性能：每当事件处理函数执行完毕后，其对应的合成事件对象内部的所有属性都会被置空，意在为下一次被复用做准备。这也就意味着事件逻辑一旦执行完毕，我们就拿不到事件对象了，React 官方给出的这个例子就很能说明问题，请看下面这个代码</p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// This won't work because the event object gets reused.</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Too late!</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<blockquote><p>异步执行的 <code>setTimeout</code> 回调会在 <code>handleChange</code> 这个事件处理函数执行完毕后执行，因此它拿不到想要的那个事件对象 <code>e</code>。</p></blockquote>
<p>要想拿到目标事件对象，必须显式地告诉 React——我永远需要它，也就是调用 <code>e.persist()</code> 函数，像下面这样：</p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Prevents React from resetting its properties:</span>
  e<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Works</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>在 React 17 中，我们不需要 <code>e.persist()</code>，也可以随时随地访问我们想要的事件对象。</p>
<p><strong>3. Lane 模型的引入</strong></p>
<p>初学 React 源码的同学由此可能会很自然地认为：<code>优先级就应该是用 Lane 来处理的</code>。但事实上，<code>React 16 中处理优先级采用的是 expirationTime 模型</code>。</p>
<blockquote><p><code>expirationTime</code> 模型使用 <code>expirationTime</code>（一个时间长度） 来描述任务的优先级；而 <code>Lane 模型</code>则使用<code>二进制数来表示任务的优先级</code>：</p></blockquote>
<p><code>lane 模型</code>通过将不同优先级赋值给一个位，通过 <code>31 位的位运算</code>来操作优先级。</p>
<p><code>Lane 模型</code>提供了一个新的优先级排序的思路，相对于 <code>expirationTime</code> 来说，它对优先级的处理会更细腻，能够覆盖更多的边界条件。</p>
</div>