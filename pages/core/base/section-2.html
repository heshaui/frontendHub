<!-- Section: # 二、CSS相关 -->
<div class="section-content" data-section-id="二、css相关">
<h2 id="二、css相关"><a href="#二、css相关" class="header-anchor">#</a> 二、CSS相关</h2>
<h3 id="_1-css-sprite是什么-有什么优缺点"><a href="#_1-css-sprite是什么-有什么优缺点" class="header-anchor">#</a> 1 css sprite是什么,有什么优缺点</h3>
<blockquote><p><code>CSS Sprite</code>（CSS精灵）是一种将多个小图片合并到一张大图中的技术。通过在页面中引用这张大图，并设置合适的<code>background-position</code>和尺寸，可以显示出所需的小图标或背景图案。</p></blockquote>
<p><strong>优点：</strong></p>
<ul><li>减少<code>HTTP</code>请求数：将多个小图片合并成一张大图，减少了浏览器与服务器之间的请求次数，提高了页面加载速度。</li> <li>提高性能：由于减少了请求数，减少了网络传输时间和延迟，加快了页面加载速度，提升了用户体验。</li> <li>减小图片大小：合并后的大图可以使用更高效的压缩算法进行压缩，减小了图片的文件大小。</li> <li>方便更换风格：只需要替换或修改一张大图中的小图标或背景图案，就可以改变整个页面的样式，维护和更换风格更加方便。</li></ul>
<p><strong>缺点：</strong></p>
<ul><li>图片合并麻烦：合并图片需要手动调整和拼接小图标或背景图案，需要一定的工作量。</li> <li>维护麻烦：如果需要修改其中一个小图标或背景图案，可能需要重新布局整个大图，并且需要更新相应的CSS样式。</li></ul>
<blockquote><p>总结：<code>CSS Sprite</code>通过将多个小图片合并成一张大图，减少了<code>HTTP</code>请求，提高了页面加载速度和性能。它的优点包括减少请求数、提高性能、减小图片大小和方便更换风格。然而，它的缺点在于图片合并和维护的麻烦。</p></blockquote>
<h3 id="_2-display-none-与visibility-hidden-的区别"><a href="#_2-display-none-与visibility-hidden-的区别" class="header-anchor">#</a> 2 <code>display: none;</code>与<code>visibility: hidden;</code>的区别</h3>
<blockquote><p><code>display: none;</code>和<code>visibility: hidden;</code>都可以使元素不可见，但它们在实现上有一些区别。</p></blockquote>
<p><strong>区别：</strong></p>
<ul><li><code>display: none;</code>会使元素完全从渲染树中消失，不占据任何空间，而<code>visibility: hidden;</code>不会使元素从渲染树中消失，仍然占据空间，只是内容不可见。</li> <li><code>display: none;</code>是非继承属性，子孙节点消失是因为元素本身从渲染树中消失，修改子孙节点的属性无法使其显示。而<code>visibility: hidden;</code>是继承属性，子孙节点消失是因为继承了<code>hidden</code>属性，通过设置<code>visibility: visible;</code>可以使子孙节点显示。</li> <li>修改具有常规流的元素的<code>display</code>属性通常会导致文档重排（重新计算元素的位置和大小）。而修改<code>visibility</code>属性只会导致本元素的重绘（重新绘制元素的可见部分）。</li> <li>读屏器（屏幕阅读软件）不会读取<code>display: none;</code>元素的内容，但会读取<code>visibility: hidden;</code>元素的内容。</li></ul>
<blockquote><p>综上所述，<code>display: none;</code>和<code>visibility: hidden;</code>虽然都可以使元素不可见，但在元素在渲染树中的位置、对子孙节点的影响、性能方面有所不同。选择使用哪种方式取决于具体的需求和场景。</p></blockquote>
<h3 id="_3-link与-import的区别"><a href="#_3-link与-import的区别" class="header-anchor">#</a> 3 <code>link</code>与<code>@import</code>的区别</h3>
<ol><li><code>&lt;link&gt;</code>是HTML方式，<code>@import</code>是CSS方式。<code>&lt;link&gt;</code>标签在HTML文档的<code>&lt;head&gt;</code>部分中使用，用于引入外部CSS文件；<code>@import</code>是在CSS文件中使用，用于引入其他CSS文件。</li> <li><code>&lt;link&gt;</code>标签最大限度地支持并行下载，浏览器会同时下载多个外部CSS文件；而<code>@import</code>引入的CSS文件会导致串行下载，浏览器会按照顺序逐个下载CSS文件，这可能导致页面加载速度变慢，出现FOUC（Flash of Unstyled Content）问题。</li> <li><code>&lt;link&gt;</code>标签可以通过<code>rel="alternate stylesheet"</code>指定候选样式表，用户可以在浏览器中切换样式；而<code>@import</code>不支持<code>rel</code>属性，无法提供候选样式表功能。</li> <li>浏览器对<code>&lt;link&gt;</code>标签的支持早于<code>@import</code>，一些古老的浏览器可能不支持<code>@import</code>方式引入CSS文件，而可以正确解析<code>&lt;link&gt;</code>标签。</li> <li><code>@import</code>必须出现在样式规则之前，而且只能在CSS文件的顶部引用其他文件；而<code>&lt;link&gt;</code>标签可以放置在文档的任何位置。</li> <li>总体来说，<code>&lt;link&gt;</code>标签在性能、兼容性和灵活性方面优于<code>@import</code>。</li></ol>
<blockquote><p>因此，在实际使用中，推荐使用<code>&lt;link&gt;</code>标签来引入外部CSS文件。</p></blockquote>
<h3 id="_4-什么是fouc-如何避免"><a href="#_4-什么是fouc-如何避免" class="header-anchor">#</a> 4 什么是FOUC?如何避免</h3>
<blockquote><p>FOUC（Flash Of Unstyled Content）指的是在页面加载过程中，由于外部样式表（CSS）加载较慢或延迟，导致页面先以无样式的方式显示，然后突然闪烁出样式的现象。</p></blockquote>
<p><strong>为了避免FOUC，可以采取以下方法：</strong></p>
<ol><li>将样式表放置在文档的<code>&lt;head&gt;</code>标签中：通过将样式表放在文档头部，确保浏览器在渲染页面内容之前先加载和解析样式表，从而避免了页面一开始的无样式状态。</li> <li>使用内联样式：将关键的样式直接写在HTML标签的<code>style</code>属性中，这样即使外部样式表加载延迟，页面仍然可以有基本的样式展示，避免出现完全无样式的情况。</li> <li>使用样式预加载：在HTML的<code>&lt;head&gt;</code>中使用<code>&lt;link rel="preload"&gt;</code>标签，将样式表提前预加载，以确保在页面渲染之前样式表已经下载完毕。</li> <li>避免过多的样式表和样式文件：减少页面中使用的样式表数量和样式文件大小，优化样式表的结构和规则，从而加快样式表的加载速度。</li> <li>使用媒体查询避免不必要的样式加载：通过媒体查询（<code>@media</code>）在适当的条件下加载特定的样式，避免在不需要的情况下加载不必要的样式。</li></ol>
<p>综上所述，通过优化样式加载顺序、使用内联样式、样式预加载和合理使用媒体查询等方法，可以有效避免FOUC的出现，提供更好的用户体验。</p>
<h3 id="_5-如何创建块级格式化上下文-block-formatting-context-bfc有什么用"><a href="#_5-如何创建块级格式化上下文-block-formatting-context-bfc有什么用" class="header-anchor">#</a> 5 如何创建块级格式化上下文(block formatting context),BFC有什么用</h3>
<blockquote><p>BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响</p></blockquote>
<p>要创建一个块级格式化上下文（BFC），可以应用以下方法：</p>
<ol><li>使用<code>float</code>属性：将元素的<code>float</code>属性设置为除<code>none</code>以外的值，可以创建一个BFC。</li> <li>使用<code>overflow</code>属性：将元素的<code>overflow</code>属性设置为除<code>visible</code>以外的值，例如<code>auto</code>或<code>hidden</code>，可以创建一个BFC。</li> <li>使用<code>display</code>属性：将元素的<code>display</code>属性设置为<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>等特定的值，可以创建一个BFC。</li> <li>使用<code>position</code>属性：将元素的<code>position</code>属性设置为<code>absolute</code>、<code>fixed</code>、<code>relative</code>或<code>sticky</code>，可以创建一个BFC。</li> <li>使用<code>contain</code>属性：将元素的<code>contain</code>属性设置为<code>layout</code>，可以创建一个BFC（仅适用于部分浏览器）。</li></ol>
<blockquote><p>在<code>IE</code>下, <code>Layout</code>,可通过<code>zoom:1</code> 触发</p></blockquote>
<p><strong>BFC布局与普通文档流布局区别 普通文档流布局:</strong></p>
<ul><li>浮动的元素是不会被父级计算高度</li> <li>非浮动元素会覆盖浮动元素的位置</li> <li><code>margin</code>会传递给父级元素</li> <li>两个相邻元素上下的<code>margin</code>会重叠</li></ul>
<p><strong>BFC布局规则:</strong></p>
<ul><li>浮动的元素会被父级计算高度(父级元素触发了<code>BFC</code>)</li> <li>非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了<code>BFC</code>)</li> <li><code>margin</code>不会传递给父级(父级触发<code>BFC</code>)</li> <li>属于同一个<code>BFC</code>的两个相邻元素上下<code>margin</code>会重叠</li></ul>
<p><strong>开发中的应用</strong></p>
<ul><li>阻止<code>margin</code>重叠</li> <li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 <code>div</code>都位于同一个 <code>BFC</code> 区域之中)</li> <li>自适应两栏布局</li> <li>可以阻止元素被浮动元素覆盖</li></ul>
<h3 id="_6-display、float、position的关系"><a href="#_6-display、float、position的关系" class="header-anchor">#</a> 6 display、float、position的关系</h3>
<ul><li>如果<code>display</code>取值为<code>none</code>，那么<code>position</code>和<code>float</code>都不起作用，这种情况下元素不产生框</li> <li>否则，如果<code>position</code>取值为<code>absolute</code>或者<code>fixed</code>，框就是绝对定位的，<code>float</code>的计算值为<code>none</code>，<code>display</code>根据下面的表格进行调整。</li> <li>否则，如果<code>float</code>不是<code>none</code>，框是浮动的，<code>display</code>根据下表进行调整</li> <li>否则，如果元素是根元素，<code>display</code>根据下表进行调整</li> <li>其他情况下<code>display</code>的值为指定值</li> <li>总结起来：<strong>绝对定位、浮动、根元素都需要调整<code>display</code></strong></li></ul>
<p><img alt="" src="https://s.poetries.top/images/202202231030963.png"></p>
<p>综上所述，display、float和position之间存在一定的关系，它们的取值会相互影响元素的布局和显示方式。根据不同的取值组合，元素的display值可能会被调整。</p>
<h3 id="_7-清除浮动的几种方式-各自的优缺点"><a href="#_7-清除浮动的几种方式-各自的优缺点" class="header-anchor">#</a> 7 清除浮动的几种方式，各自的优缺点</h3>
<p>以下是清除浮动的几种常见方式以及它们的优缺点：</p>
<ol><li><strong>父级 <code>div</code> 定义 <code>height</code>：</strong> 将父级容器的高度设置为已浮动元素的高度。优点是简单易实现，缺点是需要提前知道浮动元素的高度，如果高度发生变化，需要手动调整。</li> <li><strong>结尾处加空 <code>div</code> 标签 <code>clear:both</code>：</strong> 在浮动元素后面添加一个空的 <code>div</code> 标签，并设置 <code>clear:both</code>。优点是简单易实现，缺点是需要添加多余的空标签，不符合语义化。</li> <li><strong>父级 <code>div</code> 定义伪类 <code>:after</code> 和 <code>zoom</code>：</strong> 父级容器使用伪元素 <code>:after</code> 清除浮动，并设置 <code>zoom:1</code> 触发 <code>hasLayout</code>。优点是不需要额外添加多余的标签，清除浮动效果好，缺点是对老版本浏览器的兼容性需要考虑。</li> <li><strong>父级 <code>div</code> 定义 <code>overflow:hidden</code>：</strong> 将父级容器的 <code>overflow</code> 属性设置为 <code>hidden</code>。优点是简单易实现，不需要添加额外的标签，缺点是可能会造成内容溢出隐藏。</li> <li><strong>父级 <code>div</code> 也浮动，需要定义宽度：</strong> 将父级容器也设置为浮动，并定义宽度。优点是清除浮动效果好，缺点是需要定义宽度，不够灵活。</li> <li><strong>结尾处加 <code>br</code> 标签 <code>clear:both</code>：</strong> 在浮动元素后面添加 <code>br</code> 标签，并设置 <code>clear:both</code>。和第2种方式类似，优缺点也相似。</li> <li><strong>使用 clearfix 类：</strong> 在父级容器上应用 clearfix 类，该类包含伪元素清除浮动。优点是代码简洁易懂，不需要额外添加标签，缺点是需要定义并引用 <code>clearfix</code> 类。</li></ol>
<blockquote><p>总体而言，使用伪类 <code>:after</code> 和 <code>zoom</code> 的方式是较为常见和推荐的清除浮动的方法，它可以避免添加多余的标签，并具有较好的兼容性。然而，不同场景下适合使用不同的清除浮动方式，需要根据实际情况选择合适的方法。</p></blockquote>
<h3 id="_8-为什么要初始化css样式"><a href="#_8-为什么要初始化css样式" class="header-anchor">#</a> 8 为什么要初始化CSS样式?</h3>
<p>初始化 CSS 样式的目的主要有以下几点：</p>
<ol><li><strong>浏览器兼容性：</strong> 不同浏览器对于 HTML 元素的默认样式存在差异，通过初始化 CSS 样式，可以尽量消除不同浏览器之间的显示差异，使页面在各个浏览器中更加一致。</li> <li><strong>统一样式：</strong> 通过初始化 CSS 样式，可以为各个元素提供一个统一的基础样式，避免默认样式的影响。这有助于开发者在项目中构建一致的界面风格，提高开发效率。</li> <li><strong>提高可维护性：</strong> 初始化 CSS 样式可以避免在编写具体样式时受到浏览器默认样式的干扰，减少不必要的样式覆盖和调整，从而提高代码的可维护性和可读性。</li> <li><strong>优化性能：</strong> 通过初始化 CSS 样式，可以避免不必要的样式计算和渲染，减少浏览器的工作量，提升页面加载和渲染性能。</li></ol>
<p>需要注意的是，在进行 CSS 样式初始化时，应该注意选择合适的方式和范围，避免过度初始化造成不必要的代码冗余和性能损耗。同时，针对具体项目和需求，可以选择使用已有的 CSS 初始化库或者自定义初始化样式。</p>
<h3 id="_9-css3有哪些新特性"><a href="#_9-css3有哪些新特性" class="header-anchor">#</a> 9 css3有哪些新特性</h3>
<p>CSS3引入了许多新特性，以下是其中一些常见的新特性：</p>
<ol><li><strong>新增选择器</strong>：例如<code>:nth-child()</code>、<code>:first-of-type</code>、<code>:last-of-type</code>等，可以根据元素在父元素中的位置进行选择。</li> <li><strong>弹性盒模型</strong>：通过<code>display: flex;</code>可以创建弹性布局，简化了元素的排列和对齐方式。</li> <li><strong>多列布局</strong>：使用<code>column-count</code>和<code>column-width</code>等属性可以实现将内容分为多列显示。</li> <li><strong>媒体查询</strong>：通过<code>@media</code>可以根据设备的特性和屏幕大小应用不同的样式规则。</li> <li><strong>个性化字体</strong>：使用<code>@font-face</code>可以引入自定义字体，并在网页中使用。</li> <li><strong>颜色透明度</strong>：通过<code>rgba()</code>可以设置颜色的透明度。</li> <li><strong>圆角</strong>：使用<code>border-radius</code>可以给元素添加圆角效果。</li> <li><strong>渐变</strong>：使用<code>linear-gradient()</code>可以创建线性渐变背景效果。</li> <li><strong>阴影</strong>：使用<code>box-shadow</code>可以为元素添加阴影效果。</li> <li><strong>倒影</strong>：使用<code>box-reflect</code>可以为元素添加倒影效果。</li> <li><strong>文字装饰</strong>：使用<code>text-stroke-color</code>可以设置文字描边的颜色。</li> <li><strong>文字溢出</strong>：使用<code>text-overflow</code>可以处理文字溢出的情况。</li> <li><strong>背景效果</strong>：使用<code>background-size</code>可以控制背景图片的大小。</li> <li><strong>边框效果</strong>：使用<code>border-image</code>可以为边框使用图片来创建特殊效果。</li> <li><strong>转换</strong>：使用<code>transform</code>可以实现元素的旋转、倾斜、位移和缩放等变换效果。</li> <li><strong>平滑过渡</strong>：使用<code>transition</code>可以为元素的属性变化添加过渡效果。</li> <li><strong>动画</strong>：通过<code>@keyframes</code>和<code>animation</code>可以创建元素的动画效果。</li></ol>
<p><strong>CSS3引入了许多新的伪类，以下是一些常见的新增伪类：</strong></p>
<ol><li><code>:nth-child(n)</code>：选择父元素下的第n个子元素。</li> <li><code>:first-child</code>：选择父元素下的第一个子元素。</li> <li><code>:last-child</code>：选择父元素下的最后一个子元素。</li> <li><code>:nth-of-type(n)</code>：选择父元素下特定类型的第n个子元素。</li> <li><code>:first-of-type</code>：选择父元素下特定类型的第一个子元素。</li> <li><code>:last-of-type</code>：选择父元素下特定类型的最后一个子元素。</li> <li><code>:only-child</code>：选择父元素下仅有的一个子元素。</li> <li><code>:only-of-type</code>：选择父元素下特定类型的唯一一个子元素。</li> <li><code>:empty</code>：选择没有任何子元素或者文本内容的元素。</li> <li><code>:target</code>：选择当前活动的目标元素。</li> <li><code>:enabled</code>：选择可用的表单元素。</li> <li><code>:disabled</code>：选择禁用的表单元素。</li> <li><code>:checked</code>：选择被选中的单选框或复选框。</li> <li><code>:focus</code>：选择当前获取焦点的元素。</li> <li><code>:hover</code>：选择鼠标悬停在上方的元素。</li> <li><code>:visited</code>：选择已访问过的链接。</li> <li><code>:not(selector)</code>：选择不符合给定选择器的元素。</li></ol>
<p>这些新增的伪类为选择元素提供了更多的灵活性和精确性，使得开发者能够更好地控制和样式化文档中的元素。</p>
<h3 id="_10-display有哪些值-说明他们的作用"><a href="#_10-display有哪些值-说明他们的作用" class="header-anchor">#</a> 10 display有哪些值？说明他们的作用</h3>
<p><code>display</code>属性用于定义元素应该生成的框类型。以下是常见的<code>display</code>属性值及其作用：</p>
<ol><li><code>block</code>：将元素转换为块状元素，独占一行，可设置宽度、高度、边距等属性。</li> <li><code>inline</code>：将元素转换为行内元素，不独占一行，只占据内容所需的空间，无法设置宽度、高度等块级属性。</li> <li><code>none</code>：设置元素不可见，在渲染时将其完全隐藏，不占据任何空间。</li> <li><code>inline-block</code>：使元素既具有行内元素的特性（不独占一行），又具有块级元素的特性（可设置宽度、高度等属性），可以看作是行内块状元素。</li> <li><code>list-item</code>：将元素作为列表项显示，常用于有序列表（<code>&lt;ol&gt;</code>）和无序列表（<code>&lt;ul&gt;</code>）中，会添加列表标记。</li> <li><code>table</code>：将元素作为块级表格显示，常用于构建表格布局，类似于<code>&lt;table&gt;</code>元素。</li> <li><code>inherit</code>：规定应从父元素继承<code>display</code>属性的值，使元素继承父元素的框类型。</li></ol>
<p>这些<code>display</code>属性值用于控制元素的外观和布局，通过选择适当的值可以实现不同的布局效果。</p>
<h3 id="_11-介绍一下标准的css的盒子模型-低版本ie的盒子模型有什么不同的"><a href="#_11-介绍一下标准的css的盒子模型-低版本ie的盒子模型有什么不同的" class="header-anchor">#</a> 11 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h3>
<blockquote><ul><li>有两种，<code>IE</code>盒子模型、<code>W3C</code>盒子模型；</li> <li>盒模型：内容(content)、填充(<code>padding</code>)、边界(<code>margin</code>)、 边框(<code>border</code>)；</li> <li>区 别： IE<code>的c</code>ontent<code>部分把</code>border<code>和</code>padding`计算了进去;</li></ul></blockquote>
<ul><li>盒子模型构成：内容(<code>content</code>)、内填充(<code>padding</code>)、 边框(<code>border</code>)、外边距(<code>margin</code>)</li> <li><code>IE8</code>及其以下版本浏览器，未声明 <code>DOCTYPE</code>，内容宽高会包含内填充和边框，称为怪异盒模型(<code>IE</code>盒模型)</li> <li>标准(<code>W3C</code>)盒模型：元素宽度 = <code>width + padding + border + margin</code></li> <li>怪异(<code>IE</code>)盒模型：元素宽度 = <code>width + margin</code></li> <li>标准浏览器通过设置 css3 的 <code>box-sizing: border-box</code> 属性，触发“怪异模式”解析计算宽高</li></ul>
<p><strong>box-sizing 常用的属性有哪些？分别有什么作用</strong></p>
<p><code>box-sizing</code>属性用于控制元素的盒模型类型，常用的属性值有：</p>
<ol><li><code>content-box</code>：默认值，使用标准的<code>W3C</code>盒模型，元素的宽度和高度仅包括内容区域（<code>content</code>），不包括填充、边框和外边距。</li> <li><code>border-box</code>：使用怪异的<code>IE</code>盒模型，元素的宽度和高度包括内容区域（<code>content</code>）、填充（<code>padding</code>）和边框（<code>border</code>），但不包括外边距（<code>margin</code>）。即元素的宽度和高度指定的是内容区域加上填充和边框的总宽度和高度。</li> <li><code>inherit</code>：继承父元素的<code>box-sizing</code>属性值。</li></ol>
<p>通过设置不同的<code>box-sizing</code>属性值，可以控制元素的盒模型类型，进而影响元素的布局和尺寸计算。使用<code>border-box</code>可以更方便地处理元素的宽度和高度，特别适合响应式布局和网格系统的设计。</p>
<h3 id="_12-css优先级算法如何计算"><a href="#_12-css优先级算法如何计算" class="header-anchor">#</a> 12 CSS优先级算法如何计算？</h3>
<p>CSS优先级是用于确定当多个样式规则应用到同一个元素时，哪个样式规则会被应用的一种规则。优先级的计算基于选择器的权重。</p>
<p>以下是CSS优先级计算的一般规则：</p>
<ol><li><code>!important</code>：样式规则使用了<code>!important</code>标记，具有最高优先级，无论其位置在哪里。</li> <li>内联样式：直接应用在元素上的<code>style</code>属性具有较高的优先级。</li> <li>ID选择器：使用ID选择器的样式规则具有较高的优先级。例如，<code>#myElement</code>。</li> <li>类选择器、属性选择器和伪类选择器：使用类选择器（例如<code>.myClass</code>）、属性选择器（例如<code>[type="text"]</code>）和伪类选择器（例如<code>:hover</code>）的样式规则的优先级较低于ID选择器。</li> <li>元素选择器和伪元素选择器：使用元素选择器（例如<code>div</code>）和伪元素选择器（例如<code>::before</code>）的样式规则的优先级较低于类选择器、属性选择器和伪类选择器。</li></ol>
<p><strong>当存在多个样式规则具有相同的优先级时，会根据以下规则进行决定：</strong></p>
<ul><li>就近原则：当同一元素上存在多个具有相同优先级的样式规则时，最后出现的样式规则将被应用。</li> <li>继承：某些样式属性可以被子元素继承，如果父元素具有样式规则，子元素将继承该样式。</li></ul>
<p>需要注意的是，以上规则仅适用于一般情况，有些情况下可能存在更复杂的优先级计算。同时，使用<code>!important</code>应该谨慎，过度使用<code>!important</code>可能导致样式管理困难和维护问题。</p>
<h3 id="_13-对bfc规范的理解"><a href="#_13-对bfc规范的理解" class="header-anchor">#</a> 13 对BFC规范的理解？</h3>
<blockquote><ul><li>一个页面是由很多个 <code>Box</code> 组成的,元素的类型和 <code>display</code> 属性,决定了这个 <code>Box</code> 的类型</li> <li>不同类型的 <code>Box</code>,会参与不同的 <code>Formatting Context</code>（决定如何渲染文档的容器）,因此<code>Box</code>内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响</li></ul></blockquote>
<p>BFC（Block Formatting Context）是CSS中的一种渲染规范，用于决定和控制元素在文档中的布局和渲染方式。BFC定义了一个独立的渲染区域，使得处于不同BFC内部的元素相互隔离，互不影响。</p>
<p>以下是对BFC规范的一些理解：</p>
<ol><li>BFC的创建条件：触发BFC的条件包括元素的<code>float</code>属性不为<code>none</code>、<code>position</code>属性为<code>absolute</code>或<code>fixed</code>、<code>display</code>属性为<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>等，以及通过特定的CSS属性（如<code>overflow</code>）进行触发。</li> <li>BFC的特性：
<ul><li>内部的块级盒子会在垂直方向上一个接一个地放置。</li> <li>相邻的两个块级盒子的垂直外边距会发生合并。</li> <li>BFC的区域不会与浮动元素重叠。</li> <li>BFC在页面布局时会考虑浮动元素。</li> <li>BFC可以包含浮动元素，并计算其高度。</li> <li>BFC的边界会阻止边距重叠。</li></ul></li> <li>BFC的应用：
<ul><li>清除浮动：创建一个父级元素成为BFC，可以清除其内部浮动的影响，避免父元素塌陷。</li> <li>创建自适应的两栏布局：通过将两个列容器设置为BFC，可以避免它们相互影响。</li> <li>阻止边距重叠：当两个相邻元素的边距发生重叠时，将其中一个元素设置为BFC，可以解决边距重叠问题。</li></ul></li></ol>
<p>总的来说，BFC规范通过创建独立的渲染上下文，使得元素的布局和渲染更加可控，避免了一些常见的布局问题和冲突。它在清除浮动、解决边距重叠等方面具有重要的应用价值。</p>
<h3 id="_14-谈谈浮动和清除浮动"><a href="#_14-谈谈浮动和清除浮动" class="header-anchor">#</a> 14 谈谈浮动和清除浮动</h3>
<p>浮动（float）是CSS中的一种布局方式，它允许元素向左或向右浮动并脱离文档的正常流，其他元素会围绕浮动元素进行布局。</p>
<p><strong>浮动的特点和应用：</strong></p>
<ol><li>元素浮动后，其原位置会被其他元素填充，不再占据文档流中的空间。</li> <li>浮动元素会尽可能地靠近其包含块的左侧或右侧，直到遇到另一个浮动元素或包含块的边界。</li> <li>浮动元素可以通过设置<code>float</code>属性为<code>left</code>或<code>right</code>进行左浮动或右浮动。</li> <li>常见应用包括实现多列布局、文字环绕图片等。</li></ol>
<p>清除浮动（clear float）是为了解决浮动元素带来的影响和布局问题而采取的措施。</p>
<blockquote><p>浮动元素会导致其父元素的高度塌陷（父元素无法检测到浮动元素的高度），以及其他元素可能与浮动元素重叠。为了解决这些问题，可以使用清除浮动的方法：</p></blockquote>
<ol><li>空元素清除浮动：在浮动元素后面添加一个空的块级元素，并设置其<code>clear</code>属性为<code>both</code>，使其在浮动元素下方换行，达到清除浮动的效果。</li> <li>父级元素使用<code>overflow</code>属性：给包含浮动元素的父元素设置<code>overflow</code>属性为<code>auto</code>或<code>hidden</code>，可以触发BFC（块格式化上下文），从而包含浮动元素。</li> <li>使用伪元素清除浮动：使用<code>::after</code>伪元素给包含浮动元素的父元素添加一个清除浮动的样式，例如设置<code>content</code>为空字符串、<code>display</code>为<code>table</code>等。</li> <li>使用clearfix类：给包含浮动元素的父元素添加一个clearfix类，该类定义了清除浮动的样式，例如设置<code>clearfix</code>类的<code>::after</code>伪元素清除浮动。</li></ol>
<p>需要注意的是，清除浮动的方法应当适用于具体的布局需求和兼容性考虑。同时，清除浮动可能会影响到其他样式的布局，因此需要综合考虑和测试。</p>
<h3 id="_15-position的值-relative和absolute定位原点是"><a href="#_15-position的值-relative和absolute定位原点是" class="header-anchor">#</a> 15 position的值， relative和absolute定位原点是</h3>
<p><code>position</code> 属性用于控制元素的定位方式，常用的取值包括：</p>
<ul><li><code>static</code>：默认值，表示元素在文档流中正常定位，不会受到 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 属性的影响。</li> <li><code>relative</code>：生成相对定位的元素，相对于其正常位置进行定位，通过设置 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 属性来调整元素的位置，不会脱离文档流，周围的元素仍然会按照正常布局进行排列。</li> <li><code>absolute</code>：生成绝对定位的元素，相对于最近的非 <code>static</code> 定位的父元素进行定位，如果没有非 <code>static</code> 定位的父元素，则相对于文档根元素（即浏览器窗口）进行定位。绝对定位的元素会脱离文档流，不占据空间，可以通过设置 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 属性来精确控制元素的位置。</li> <li><code>fixed</code>：生成绝对定位的元素，相对于浏览器窗口进行定位，不会随着页面的滚动而改变位置。可以通过设置 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 属性来指定元素的位置。</li> <li><code>inherit</code>：规定从父元素继承 <code>position</code> 属性的值。</li></ul>
<blockquote><p>对于 <code>relative</code> 和 <code>absolute</code> 定位，其原点（坐标基准点）是元素在正常文档流中的位置。通过调整 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 属性，可以相对于原点在水平和垂直方向上进行偏移，实现元素的精确定位。</p></blockquote>
<h3 id="_16-display-inline-block-什么时候不会显示间隙"><a href="#_16-display-inline-block-什么时候不会显示间隙" class="header-anchor">#</a> 16 display:inline-block 什么时候不会显示间隙？</h3>
<blockquote><p><code>display: inline-block</code> 元素在默认情况下会产生间隙，这是因为它们被视为行内元素，会保留默认的行框高度和基线对齐。然而，可以采取一些方法来消除这些间隙，使元素紧密排列，例如在携程网站中的布局。</p></blockquote>
<p>以下是一些消除间隙的常见方法：</p>
<ol><li>移除空格：在 HTML 代码中，将 <code>inline-block</code> 元素之间的空格删除，以消除间隙。</li> <li>使用负值 <code>margin</code>：通过设置负值的左右外边距（<code>margin</code>）来抵消间隙。例如，可以使用 <code>margin-right: -4px;</code> 来消除间隙。</li> <li>使用 <code>font-size: 0;</code>：将 <code>inline-block</code> 元素的父元素的字体大小设置为 0，然后在 <code>inline-block</code> 元素上重新设置所需的字体大小。这样可以消除间隙，因为元素内部没有文字导致的间隙。</li> <li>使用 <code>letter-spacing</code>：在 <code>inline-block</code> 元素的父元素上设置负值的 <code>letter-spacing</code>，例如 <code>letter-spacing: -4px;</code>，可以消除间隙。</li> <li>使用 <code>word-spacing</code>：在 <code>inline-block</code> 元素的父元素上设置负值的 <code>word-spacing</code>，例如 <code>word-spacing: -4px;</code>，可以消除间隙。</li></ol>
<p>这些方法都是通过调整元素的布局或字体属性来实现消除间隙的效果。具体的方法选择取决于实际需求和布局要求。</p>
<h3 id="_17-png-gif-jpg的区别及如何选"><a href="#_17-png-gif-jpg的区别及如何选" class="header-anchor">#</a> 17 PNG\GIF\JPG的区别及如何选</h3>
<blockquote><p><code>PNG</code>, <code>GIF</code>, 和 <code>JPG</code> 是常见的图像文件格式，它们在以下方面有所区别：</p></blockquote>
<ol><li><p><strong>GIF (Graphics Interchange Format)</strong></p> <ul><li>使用 <code>8</code> 位像素，最多支持 <code>256</code> 种颜色。</li> <li>采用无损压缩算法，不会损失图像质量。</li> <li>支持简单的动画功能，可以创建循环播放的图像。</li> <li>支持二进制透明和索引透明，可以实现简单的透明效果。</li> <li>适用于图标、简单的动画和带有透明背景的图像。</li></ul></li> <li><p><strong>JPEG (Joint Photographic Experts Group)</strong></p> <ul><li>支持高达 <code>16.7</code> 百万种颜色，适合存储照片和复杂图像。</li> <li>使用有损压缩算法，可以调整压缩质量以平衡图像质量和文件大小。</li> <li>不支持透明效果，背景会被默认填充为白色。</li> <li>适合摄影、艺术作品等需要保留高质量细节的图像。</li></ul></li> <li><p><strong>PNG (Portable Network Graphics)</strong></p> <ul><li>有两种类型：<code>PNG-8</code> 和真彩色 <code>PNG</code>。</li> <li><code>PNG-8</code> 类似于 <code>GIF</code>，支持最多 <code>256</code> 种颜色，文件较小，可以实现透明效果。</li> <li>真彩色 <code>PNG</code> 支持高分辨率的真彩色图像，文件较大，支持完全的 <code>alpha</code> 透明度。</li> <li>不支持动画功能。</li> <li>适合图标、背景、按钮等需要透明度的图像。</li></ul></li></ol>
<p><strong>选择使用哪种图像格式取决于图像的特点和用途：</strong></p>
<ul><li>如果需要动画效果，可以选择<code>GIF</code>格式。</li> <li>如果是照片或复杂图像，需要高质量和丰富的颜色，可以选择 <code>JPG</code> 格式。</li> <li>如果需要透明背景或简单的透明效果，可以选择 <code>PNG</code> 格式，根据图像的复杂性选择 <code>PNG-8</code> 或真彩色 <code>PNG</code>。</li></ul>
<h3 id="_18-行内元素float-left后是否变为块级元素"><a href="#_18-行内元素float-left后是否变为块级元素" class="header-anchor">#</a> 18 行内元素float:left后是否变为块级元素？</h3>
<p>当行内元素设置了 <code>float: left;</code> 后，并非直接变为块级元素，而是表现出类似行内块级元素 (<code>inline-block</code>) 的特性。</p>
<p><strong>行内元素设置了 <code>float: left;</code> 后会产生以下效果：</strong></p>
<ul><li>行内元素会脱离文档流，并根据设置的浮动方向向左浮动。</li> <li>其宽度不再受到文本内容的限制，而是根据内容的宽度来确定。</li> <li>可以设置 <code>padding-top</code>、<code>padding-bottom</code>、<code>width</code>、<code>height</code> 等属性，并产生相应的效果。</li> <li>相邻的行内元素会环绕在其周围，形成类似于文本环绕的效果。</li></ul>
<p>需要注意的是，设置了浮动的行内元素不会自动填充父元素的宽度，而是根据内容的宽度进行布局。如果希望行内元素具有块级元素的宽度特性，可以设置 <code>width: 100%;</code></p>
<p>总结：行内元素设置了 <code>float: left;</code> 后，它的表现类似于行内块级元素，但仍然属于行内元素的性质，只是在布局和尺寸上有所改变。</p>
<h3 id="_19-在网页中的应该使用奇数还是偶数的字体-为什么呢"><a href="#_19-在网页中的应该使用奇数还是偶数的字体-为什么呢" class="header-anchor">#</a> 19 在网页中的应该使用奇数还是偶数的字体？为什么呢？</h3>
<p>在网页中，通常建议使用偶数字号的字体，即字号为偶数（如 <code>12px</code>、<code>14px</code>、<code>16px</code> 等）。这是因为偶数字号相对更容易与网页设计的其他部分构成比例关系，具有更好的视觉平衡和一致性。</p>
<p>以下是一些原因和考虑因素：</p>
<ol><li><strong>整数像素对齐：</strong> 偶数字号的字体大小通常是整数像素，而在网页渲染中，整数像素对齐可以提供更锐利和清晰的显示效果。当字号为奇数时，可能需要进行半像素渲染，这可能会导致字体显示模糊或模糊。</li> <li><strong>比例和对称：</strong> 使用偶数字号的字体可以更容易与其他设计元素形成比例和对称。网页设计通常依赖于一致的比例和对称性，而使用偶数字号的字体可以更好地与网页中的其他元素（如标题、段落、间距等）形成和谐的视觉关系。</li> <li><strong>浏览器兼容性：</strong> 一些浏览器对于奇数字号字体的渲染效果可能与偶数字号字体略有不同，可能会导致细微的差异。使用偶数字号字体可以减少在不同浏览器上的显示差异。</li></ol>
<p>需要注意的是，这只是一些建议，并不意味着绝对规定。在实际设计中，根据具体情况和个人审美偏好，也可以使用奇数字号字体。最重要的是确保字体大小与整体设计风格和一致性相匹配。</p>
<h3 id="_20-before-和-after中双冒号和单冒号-有什么区别-解释一下这2个伪元素的作用"><a href="#_20-before-和-after中双冒号和单冒号-有什么区别-解释一下这2个伪元素的作用" class="header-anchor">#</a> 20 ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用</h3>
<p>在 CSS 中，单冒号(<code>:</code>)和双冒号(<code>::</code>)有不同的含义和用途。</p>
<ol><li><strong>单冒号(<code>:</code>)：</strong> 单冒号用于表示伪类。伪类是用于选择元素的特定状态或动作的关键字，例如 <code>:hover</code>、<code>:active</code>、<code>:focus</code> 等。伪类表示元素的某种状态或行为，它们通常用于选择元素的特定状态并应用相应的样式。</li> <li><strong>双冒号(<code>::</code>)：</strong> 双冒号用于表示伪元素。伪元素是用于在文档中生成或插入特定内容的关键字，例如 <code>::before</code>、<code>::after</code>、<code>::first-line</code>、<code>::first-letter</code> 等。伪元素可以创建或修改元素的一部分内容，它们允许开发人员在元素的特定位置添加样式或内容，而无需在文档中实际插入额外的 HTML 元素。</li></ol>
<p><strong>关于 <code>::before</code> 和 <code>::after</code> 伪元素的作用：</strong></p>
<ul><li><strong><code>::before</code>：</strong> <code>::before</code> 伪元素用于在选中元素的内容前插入生成的内容。通过设置 <code>content</code> 属性和应用样式，可以在元素的开始位置插入额外的内容，这样就可以实现一些装饰性效果或添加额外的元素内容。</li> <li><strong><code>::after</code>：</strong> <code>::after</code> 伪元素用于在选中元素的内容后插入生成的内容。与 <code>::before</code> 类似，通过设置 <code>content</code> 属性和应用样式，可以在元素的结束位置插入额外的内容，从而实现装饰性效果或添加其他元素内容。</li></ul>
<p>这两个伪元素可以通过 CSS 属性进行定位、设置样式、添加内容等，使开发人员可以在不修改实际 HTML 结构的情况下，实现一些额外的视觉效果或功能。</p>
<h3 id="_21-如果需要手动写动画-你认为最小时间间隔是多久-为什么-阿里"><a href="#_21-如果需要手动写动画-你认为最小时间间隔是多久-为什么-阿里" class="header-anchor">#</a> 21 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</h3>
<ul><li>多数显示器默认频率是<code>60Hz</code>，即<code>1</code>秒刷新<code>60</code>次，所以理论上最小间隔为<code>1/60*1000ms ＝ 16.7ms</code></li> <li>如果需要手动编写动画，建议将最小时间间隔设置为 <code>16.7ms</code>，即每帧动画的时间间隔。这是因为大多数显示器的默认刷新频率是 <code>60Hz</code>，也就是每秒刷新 <code>60</code> 次。在这种情况下，将动画的时间间隔设置为 <code>16.7ms</code> 可以确保每帧动画都能够在显示器刷新之前完成。</li> <li>如果时间间隔小于 <code>16.7ms</code>，则会导致某些帧在显示器刷新之后才能呈现，造成不连续的动画效果，也称为"跳帧"现象。因此，将时间间隔设置为 <code>16.7ms</code> 是一个相对较小的值，可以保证较平滑的动画效果，并且适应大多数显示器的刷新频率。</li></ul>
<p>需要注意的是，由于设备和浏览器的差异，实际的刷新频率和性能可能会有所不同。因此，在编写动画时，还应该进行实际测试和优化，确保动画在各种设备和浏览器上都能够获得良好的表现。</p>
<h3 id="_22-css合并方法"><a href="#_22-css合并方法" class="header-anchor">#</a> 22 CSS合并方法</h3>
<p>正确合并 CSS 的方法可以包括以下几点：</p>
<ol><li><strong>内联 CSS</strong>: 将 CSS 直接写在 HTML 文件的 <code>&lt;style&gt;</code> 标签中或者通过 <code>style</code> 属性添加到具体元素中。这样可以减少 HTTP 请求并提高页面加载速度，但可维护性较差。</li> <li><strong>CSS 预处理器</strong>: 使用 CSS 预处理器如 Sass、Less 或 Stylus，它们提供了更灵活和可维护的方式来编写 CSS，并且可以将多个 CSS 文件合并为一个。</li> <li><strong>合并工具</strong>: 使用构建工具如 Grunt、Gulp 或 Webpack，通过配置任务来合并 CSS 文件。这些工具提供了任务运行、文件合并、压缩等功能，可以自动化合并 CSS，并在开发过程中或上线前进行处理。</li> <li><strong>HTTP 请求合并</strong>: 如果使用多个 CSS 文件，可以通过服务器端配置将它们合并成一个文件，并通过单个 HTTP 请求加载。这样可以减少请求的数量，提高页面加载速度。</li> <li><strong>压缩</strong>: 对合并后的 CSS 文件进行压缩，去除空格、注释等无关字符，以减小文件大小，提高加载速度。</li></ol>
<p>需要根据具体的项目和需求选择适合的合并方法，以提高页面性能和开发效率。</p>
<h3 id="_23-css不同选择器的权重-css层叠的规则"><a href="#_23-css不同选择器的权重-css层叠的规则" class="header-anchor">#</a> 23 CSS不同选择器的权重(CSS层叠的规则)</h3>
<p>CSS选择器的权重规则可以总结如下：</p>
<ol><li><code>!important</code>规则：具有最高的优先级，优先级为最大。</li> <li>行内样式：通过 <code>style</code> 属性直接定义的样式具有较高的权重，优先级为 <code>1000</code>。</li> <li>ID 选择器：每个 ID 选择器的权重为 <code>100</code>。</li> <li>类选择器、属性选择器和伪类选择器：每个类选择器、属性选择器或伪类选择器的权重为 <code>10</code>。</li> <li>元素选择器：每个元素选择器的权重为 <code>1</code>。</li></ol>
<p>当应用多个选择器到同一个元素时，根据上述规则计算各个选择器的权重，具有较高权重的样式将被应用。如果存在权重相同的情况，则根据样式规则的先后顺序来决定哪个样式生效，后声明的样式会覆盖先声明的样式。</p>
<p>下面是一个权重计算的示例：</p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token comment">/* 权重为 1 */</span>
<span class="token selector">div</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 权重为 10 */</span>
<span class="token selector">.class1</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 权重为 100 */</span>
<span class="token selector">#id1</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 权重为 101 (100 + 1) */</span>
<span class="token selector">#id1 div</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 权重为 11 (10 + 1) */</span>
<span class="token selector">.class1 div</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 权重为 21 (10 + 10 + 1) */</span>
<span class="token selector">.class1 .class2 div</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>根据权重的计算规则，选择器的权重越高，其样式优先级越高，将更有可能应用到对应的元素上。</p>
<h3 id="_24-列出你所知道可以改变页面布局的属性"><a href="#_24-列出你所知道可以改变页面布局的属性" class="header-anchor">#</a> 24 列出你所知道可以改变页面布局的属性</h3>
<p>以下是一些可以改变页面布局的常用属性：</p>
<ol><li><code>position</code>：控制元素的定位方式，如<code>static</code>、<code>relative</code>、<code>absolute</code>、<code>fixed</code>等。</li> <li><code>display</code>：指定元素的显示方式，如<code>block</code>、<code>inline</code>、<code>inline-block</code>、<code>flex</code>、<code>grid</code>等。</li> <li><code>float</code>：使元素浮动到指定的位置，常用于创建多列布局。</li> <li><code>width</code>和<code>height</code>：控制元素的宽度和高度。</li> <li><code>margin</code>和<code>padding</code>：调整元素的外边距和内边距。</li> <li><code>top</code>、<code>left</code>、<code>right</code>和<code>bottom</code>：设置元素相对于其定位父元素的偏移位置。</li> <li><code>z-index</code>：控制元素的层叠顺序。</li> <li><code>overflow</code>：控制元素内容溢出时的处理方式。</li> <li><code>box-sizing</code>：指定元素的盒模型类型，如<code>content-box</code>和<code>border-box</code>。</li> <li><code>flexbox</code>和<code>grid</code>：强大的布局模型，用于创建复杂的网格布局和灵活的盒模型布局。</li></ol>
<p>这些属性可以结合使用，通过调整它们的值和组合，可以实现各种不同的页面布局和排列方式。</p>
<h3 id="_25-css在性能优化方面的实践"><a href="#_25-css在性能优化方面的实践" class="header-anchor">#</a> 25 CSS在性能优化方面的实践</h3>
<p>在性能优化方面，以下是一些CSS的实践方法：</p>
<ol><li>压缩和合并CSS：使用CSS压缩工具将CSS文件压缩，并将多个<code>CSS</code>文件合并为一个文件，减少网络请求次数和文件大小。</li> <li>使用<code>Gzip</code>压缩：配置服务器开启<code>Gzip</code>压缩，可以减小<code>CSS</code>文件的大小，加快文件传输速度。</li> <li>将CSS文件放在<code>&lt;head&gt;</code>标签中：将CSS文件的引用放在HTML文档的<code>&lt;head&gt;</code>标签中，以便在页面渲染前加载CSS样式。</li> <li>避免使用<code>@import</code>：避免在<code>CSS</code>中使用@import导入其他CSS文件，因为<code>@import</code>会增加额外的请求延迟，推荐使用<code>&lt;link&gt;</code>标签引入CSS文件。</li> <li>使用缩写属性：尽量使用<code>CSS</code>的缩写属性，如<code>margin</code>、<code>padding</code>、<code>font</code>等，可以减少<code>CSS</code>文件的大小。</li> <li>避免使用滤镜：某些<code>CSS</code>滤镜效果会导致性能下降，特别是在大型页面中使用，尽量避免滤镜的使用。</li> <li>合理使用选择器：选择器的复杂性会影响CSS选择器的匹配速度，尽量避免使用过于复杂的选择器，减少选择器的层级和嵌套。</li> <li>避免使用<code>CSS</code>表达式：<code>CSS</code>表达式会在每次页面重绘时重新计算，影响性能，尽量避免使用。</li> <li>使用缓存：通过设置适当的<code>HTTP</code>响应头，将<code>CSS</code>文件缓存到浏览器中，减少重复请求。</li> <li>使用媒体查询：针对不同设备和屏幕尺寸，使用媒体查询来加载不同的<code>CSS</code>样式，提高响应性能。</li></ol>
<p>这些实践方法可以帮助优化CSS在网页加载和渲染过程中的性能，减少加载时间，提升用户体验。</p>
<h3 id="_26-css3动画-简单动画的实现-如旋转等"><a href="#_26-css3动画-简单动画的实现-如旋转等" class="header-anchor">#</a> 26 CSS3动画（简单动画的实现，如旋转等）</h3>
<ul><li>依靠<code>CSS3</code>中提出的三个属性：<code>transition</code>、<code>transform</code>、<code>animation</code></li> <li><code>transition</code>：定义了元素在变化过程中是怎么样的，包含<code>transition-property</code>、<code>transition-duration</code>、<code>transition-timing-function</code>、<code>transition-delay</code>。</li> <li><code>transform</code>：定义元素的变化结果，包含<code>rotate</code>、<code>scale</code>、<code>skew</code>、<code>translate</code>。</li> <li><code>animation</code>：动画定义了动作的每一帧（<code>@keyframes</code>）有什么效果，包括<code>animation-name</code>，<code>animation-duration</code>、<code>animation-timing-function</code>、<code>animation-delay</code>、<code>animation-iteration-count</code>、<code>animation-direction</code></li></ul>
<p>以下是一个使用CSS3动画实现旋转的示例：</p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token comment">/* 定义动画关键帧 */</span>
<span class="token atrule"><span class="token rule">@keyframes</span> rotate</span> <span class="token punctuation">{</span>
  <span class="token selector">0%</span> <span class="token punctuation">{</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>0deg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token selector">100%</span> <span class="token punctuation">{</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>360deg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 应用动画到元素 */</span>
<span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">animation-name</span><span class="token punctuation">:</span> rotate<span class="token punctuation">;</span> <span class="token comment">/* 指定动画名称 */</span>
  <span class="token property">animation-duration</span><span class="token punctuation">:</span> 3s<span class="token punctuation">;</span> <span class="token comment">/* 动画持续时间 */</span>
  <span class="token property">animation-timing-function</span><span class="token punctuation">:</span> linear<span class="token punctuation">;</span> <span class="token comment">/* 动画速度曲线 */</span>
  <span class="token property">animation-delay</span><span class="token punctuation">:</span> 0s<span class="token punctuation">;</span> <span class="token comment">/* 动画延迟时间 */</span>
  <span class="token property">animation-iteration-count</span><span class="token punctuation">:</span> infinite<span class="token punctuation">;</span> <span class="token comment">/* 动画重复次数，这里设置为无限循环 */</span>
  <span class="token property">animation-direction</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span> <span class="token comment">/* 动画播放方向 */</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h3 id="_27-base64的原理及优缺点"><a href="#_27-base64的原理及优缺点" class="header-anchor">#</a> 27 base64的原理及优缺点</h3>
<p>Base64是一种将二进制数据编码为ASCII字符的方法，通过将二进制数据转换为由64个字符组成的可打印字符序列，实现二进制数据的传输和存储。</p>
<p><strong>Base64编码的原理如下：</strong></p>
<ol><li>将待编码的数据按照每3个字节一组进行分组。</li> <li>将每组3个字节转换为4个6位的Base64字符。</li> <li>如果最后一组不足3个字节，根据需要进行填充。</li> <li>将转换后的Base64字符拼接在一起，形成最终的Base64编码结果。</li></ol>
<p><strong>优点：</strong></p>
<ul><li>可以将二进制数据转换为文本数据，方便在文本环境中传输和存储。</li> <li>减少了HTTP请求，可以将小的图片或其他资源直接嵌入到HTML、CSS或JavaScript代码中，减少了对服务器的请求次数。</li></ul>
<p><strong>缺点：</strong></p>
<ul><li>Base64编码会使数据的大小增加，因为每3个字节的原始数据会转换为4个字节的Base64编码数据。</li> <li>Base64编码是一种可逆的编码方法，虽然可以加密数据，但并不提供真正的安全性。</li> <li>编码和解码过程涉及到字符转换和处理，消耗了一定的CPU资源。</li></ul>
<p>总的来说，Base64编码适用于在文本环境中传输和存储二进制数据，并且可以减少HTTP请求。但在需要考虑数据大小和性能的情况下，需要权衡使用Base64编码的优缺点。</p>
<h3 id="_28-几种常见的css布局"><a href="#_28-几种常见的css布局" class="header-anchor">#</a> 28 几种常见的CSS布局</h3>
<h4 id="流体布局"><a href="#流体布局" class="header-anchor">#</a> 流体布局</h4>
<div class="language-css extra-class"><pre class="language-css"><code>	<span class="token selector">.left</span> <span class="token punctuation">{</span>
		<span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
		<span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
		<span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
		<span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">.right</span> <span class="token punctuation">{</span>
		<span class="token property">float</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span>
		<span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
		<span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
		<span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token selector">.main</span> <span class="token punctuation">{</span>
		<span class="token property">margin-left</span><span class="token punctuation">:</span> 120px<span class="token punctuation">;</span>
		<span class="token property">margin-right</span><span class="token punctuation">:</span> 220px<span class="token punctuation">;</span>
		<span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
		<span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<p>上述代码实现了一个基本的流体布局，其中左侧(<code>.left</code>)和右侧(<code>.right</code>)是固定宽度和高度的浮动元素，中间部分(<code>.main</code>)是流动的内容区域。</p>
<ul><li><code>.left</code>和<code>.right</code>都使用了浮动(<code>float</code>)属性，分别向左和向右浮动，使它们脱离正常的文档流并排在一起。</li> <li><code>.left</code>的宽度为<code>100px</code>，高度为<code>200px</code>，背景颜色为红色。</li> <li><code>.right</code>的宽度为<code>200px</code>，高度为<code>200px</code>，背景颜色为蓝色。</li> <li><code>.main</code>使用了左右的外边距(<code>margin-left</code>和<code>margin-right</code>)，使其在左右两侧留出空白区域，与左侧和右侧元素不重叠。</li> <li><code>.main</code>的高度为<code>200px</code>，背景颜色为绿色。</li></ul>
<p>这样设置后，左侧和右侧的浮动元素会占据固定的宽度和高度，并排在一起。中间的内容区域会流动到浮动元素的下方，填充剩余的空间。这样就实现了一个基本的流体布局，可以根据容器的大小自动适应屏幕或容器的宽度。</p>
<p>需要注意的是，浮动元素可能会导致父容器的高度塌陷，可以通过在父容器上添加清除浮动的样式来解决这个问题，例如在容器上添加<code>clearfix</code>类：</p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.container::after</span> <span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>
  <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>以上是一个简单的流体布局的示例，实际应用中可能会结合其他CSS属性和技巧来实现更复杂的布局效果。</p>
<h4 id="圣杯布局"><a href="#圣杯布局" class="header-anchor">#</a> 圣杯布局</h4>
<ul><li>要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽</li> <li>好处：重要的内容放在文档流前面可以优先渲染</li> <li>原理：利用相对定位、浮动、负边距布局，而不添加额外标签</li></ul>
<div class="language-css extra-class"><pre class="language-css"><code>  <span class="token selector">.container</span> <span class="token punctuation">{</span>
      <span class="token property">padding-left</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span>
      <span class="token property">padding-right</span><span class="token punctuation">:</span> 190px<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token selector">.main</span> <span class="token punctuation">{</span>
      <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
      <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token selector">.left</span> <span class="token punctuation">{</span>
      <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
      <span class="token property">width</span><span class="token punctuation">:</span> 190px<span class="token punctuation">;</span>
      <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>
      <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
      <span class="token property">left</span><span class="token punctuation">:</span> -150px<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token selector">.right</span> <span class="token punctuation">{</span>
      <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
      <span class="token property">width</span><span class="token punctuation">:</span> 190px<span class="token punctuation">;</span>
      <span class="token property">margin-left</span><span class="token punctuation">:</span> -190px<span class="token punctuation">;</span>
      <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
      <span class="token property">right</span><span class="token punctuation">:</span> -190px<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<p>上述代码实现了一个圣杯布局，具有三列布局，其中中间的主体内容前置且宽度自适应，两侧内容具有固定宽度。</p>
<ul><li><code>.container</code>是包含整个布局的容器，通过设置左右内边距来给中间主体内容留出空间。</li> <li><code>.main</code>是中间的主体内容区域，使用浮动(<code>float: left;</code>)和宽度为100%(<code>width: 100%;</code>)来使其占据剩余的宽度，并自适应容器的宽度。</li> <li><code>.left</code>是左侧内容区域，使用相对定位(<code>position: relative;</code>)和负边距(<code>margin-left: -100%;</code>)来将其向左偏移，并利用相对定位的<code>left</code>属性(<code>left: -150px;</code>)将其定位到容器的左侧。</li> <li><code>.right</code>是右侧内容区域，同样使用相对定位和负边距来将其向左偏移，并利用相对定位的<code>right</code>属性(<code>right: -190px;</code>)将其定位到容器的右侧。</li></ul>
<p>这样设置后，左侧和右侧的内容区域会以负偏移的方式覆盖在主体内容区域上方，而主体内容区域则会自适应剩余的宽度。这样就实现了一个圣杯布局，能够将重要的内容放在文档流的前面，优先渲染。</p>
<p>需要注意的是，由于使用了负边距和相对定位，可能会导致布局上的一些特殊情况和问题，需要在具体应用中进行测试和调整。</p>
<p>以上是一个简单的圣杯布局的示例，通过相对定位、浮动和负边距等CSS属性和技巧，实现了一个具有三列布局、自适应宽度和前置主体内容的布局效果。</p>
<h4 id="双飞翼布局"><a href="#双飞翼布局" class="header-anchor">#</a> 双飞翼布局</h4>
<ul><li>双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局</li> <li>原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。</li></ul>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>
    <span class="token comment">/*padding-left:150px;*/</span>
    <span class="token comment">/*padding-right:190px;*/</span>
<span class="token punctuation">}</span>
<span class="token selector">.main-wrap</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.main</span> <span class="token punctuation">{</span>
    <span class="token property">margin-left</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span>
    <span class="token property">margin-right</span><span class="token punctuation">:</span> 190px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.left</span> <span class="token punctuation">{</span>
    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span>
    <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>
    <span class="token comment">/*position: relative;*/</span>
    <span class="token comment">/*left:-150px;*/</span>
<span class="token punctuation">}</span>
<span class="token selector">.right</span> <span class="token punctuation">{</span>
    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 190px<span class="token punctuation">;</span>
    <span class="token property">margin-left</span><span class="token punctuation">:</span> -190px<span class="token punctuation">;</span>
    <span class="token comment">/*position:relative;*/</span>
    <span class="token comment">/*right:-190px;*/</span>
<span class="token punctuation">}</span>
</code></pre></div>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<p>上述代码实现了一个双飞翼布局，与圣杯布局相比，双飞翼布局消除了相对定位，使布局更加简洁。</p>
<ul><li><code>.container</code>是包含整个布局的容器，可以设置其左右内边距来给中间主体内容留出空间。在双飞翼布局中，我们可以选择是否为容器设置内边距，取决于具体的设计需求。</li> <li><code>.main-wrap</code>是一个包裹着主体内容的容器，设置宽度为100%和浮动，使其占据一行并自适应宽度。</li> <li><code>.main</code>是中间的主体内容区域，设置左右外边距来预留出左右两翼的位置，使其不会被左右两边的内容覆盖。</li> <li><code>.left</code>是左侧内容区域，使用浮动和负边距(<code>margin-left: -100%;</code>)将其向左偏移，使其脱离文档流并覆盖在主体内容的左侧。</li> <li><code>.right</code>是右侧内容区域，同样使用浮动和负边距(<code>margin-left: -190px;</code>)将其向左偏移，使其脱离文档流并覆盖在主体内容的右侧。</li></ul>
<p>这样设置后，左侧和右侧的内容区域会以浮动和负偏移的方式覆盖在主体内容区域的两侧，而主体内容区域则会自适应剩余的宽度。双飞翼布局相较于圣杯布局，去除了相对定位，使布局结构更加简洁。</p>
<p>需要注意的是，双飞翼布局同样可能出现一些特殊情况和问题，如内容溢出、高度不平等等，需要在具体应用中进行测试和调整。</p>
<h3 id="_29-stylus-sass-less区别"><a href="#_29-stylus-sass-less区别" class="header-anchor">#</a> 29 stylus/sass/less区别</h3>
<p>Sass, Less, 和 Stylus 是三种常用的 CSS 预处理器，它们在功能和语法上有一些区别：</p>
<ul><li><strong>语法差异</strong>：Sass 使用类似 Ruby 的缩进语法，而 Less 和 Stylus 使用类似 CSS 的语法。Sass 使用严格的缩进表示层次与嵌套关系，而 Less 和 Stylus 可以使用大括号 <code>{}</code> 表示层次和嵌套关系。</li> <li><strong>变量</strong>：Sass、Less 和 Stylus 都支持变量，用于存储和复用值。在 Sass 和 Less 中，变量以 <code>$</code> 符号开头，而在 Stylus 中，变量以 <code>$</code> 或者 <code>@</code> 符号开头。</li> <li><strong>混合</strong>：混合（Mixins）允许将一组 CSS 规则集合存储为一个可重用的样式块。Sass 和 Less 使用 <code>@mixin</code> 定义混合，而 Stylus 使用 <code>mixin</code> 关键字定义混合。</li> <li><strong>嵌套</strong>：Sass、Less 和 Stylus 都支持嵌套规则，可以在父级规则内部定义子级规则。Sass 使用缩进表示嵌套关系，Less 和 Stylus 使用大括号 <code>{}</code> 表示嵌套关系。</li> <li><strong>继承</strong>：继承（Inheritance）允许一个选择器继承另一个选择器的样式。在 Sass 中，使用 <code>@extend</code> 实现继承，而在 Less 和 Stylus 中，使用 <code>&amp;</code> 符号实现继承。</li> <li><strong>颜色混合</strong>：颜色混合（Color blending）允许将两个颜色混合生成一个新的颜色。Sass 使用 <code>mix()</code> 函数实现颜色混合，Less 使用 <code>blend()</code> 函数，而 Stylus 使用 <code>mix()</code> 函数。</li> <li><strong>环境和工具支持</strong>：Sass 是基于 Ruby 的，需要安装 <code>Ruby</code> 环境来编译，而 Less 和 <code>Stylus</code> 可以通过 Node.js 的 NPM 安装相应的库来编译。</li></ul>
<p>总的来说，<code>Sass</code>、<code>Less</code> 和 <code>Stylus</code> 在功能上大致相似，它们都提供了类似的特性，如变量、混合、嵌套、继承等，但在语法和一些细节上有一些差异。选择哪种预处理器取决于个人偏好、团队需求和项目要求。</p>
<h3 id="_30-postcss的作用"><a href="#_30-postcss的作用" class="header-anchor">#</a> 30 postcss的作用</h3>
<blockquote><ul><li>可以直观的理解为：它就是一个平台。为什么说它是一个平台呢？因为我们直接用它，感觉不能干什么事情，但是如果让一些插件在它上面跑，那么将会很强大</li> <li><code>PostCSS</code> 提供了一个解析器，它能够将 <code>CSS</code> 解析成抽象语法树</li> <li>通过在 <code>PostCSS</code> 这个平台上，我们能够开发一些插件，来处理我们的<code>CSS</code>，比如热门的：<code>autoprefixer</code></li> <li><code>postcss</code>可以对sass处理过后的<code>css</code>再处理 最常见的就是<code>autoprefixer</code></li></ul></blockquote>
<p><code>PostCSS</code> 是一个用于转换 <code>CSS</code> 的工具，它提供了一个插件化的架构，可以通过加载各种插件来处理 <code>CSS</code>。主要作用包括：</p>
<ol><li><strong>转换 CSS</strong>：<code>PostCSS</code> 可以将 <code>CSS</code> 解析成抽象语法树（AST），并允许开发者编写插件来修改和转换 <code>CSS</code>。这使得开发者可以自定义和扩展 <code>CSS</code> 的功能，从而提供更灵活的编写样式的能力。</li> <li><strong>自动添加浏览器前缀</strong>：<code>PostCSS</code> 的插件生态系统中最常用的插件之一是 <code>autoprefixer</code>。它可以根据配置和浏览器兼容性自动为样式属性添加浏览器前缀，以确保在不同浏览器中正确显示样式。</li> <li><strong>代码优化和压缩</strong>：<code>PostCSS</code> 的插件可以用于优化和压缩 <code>CSS</code> 代码，删除不必要的空格、注释、重复规则等，以减小文件大小并提高加载速度。</li> <li><strong>使用未来的 CSS 语法</strong>：<code>PostCSS</code> 可以支持使用未来的 <code>CSS</code> 语法和功能，例如使用 <code>CSS Variables</code>、<code>CSS Modules</code>、<code>CSS Grid</code> 等。通过一些插件，可以在现有浏览器中使用这些新特性，而无需等待浏览器的更新。</li></ol>
<blockquote><p>总之，<code>PostCSS</code> 提供了一个灵活的平台和插件生态系统，可以对 <code>CSS</code> 进行各种转换和优化，使开发者能够更好地编写和管理样式代码，并兼容不同的浏览器和未来的 <code>CSS</code> 标准。</p></blockquote>
<h3 id="_31-css样式-选择器-的优先级"><a href="#_31-css样式-选择器-的优先级" class="header-anchor">#</a> 31 css样式（选择器）的优先级</h3>
<p>CSS 样式的优先级可以根据以下规则进行计算：</p>
<ol><li><strong>内联样式</strong>（Inline Styles）具有最高的优先级。通过在 HTML 元素的 <code>style</code> 属性中直接定义的样式将覆盖其他样式规则。</li> <li><strong>权重</strong>（Specificity）是确定样式优先级的重要因素。每个选择器都有一个权重，权重由选择器的组成部分决定，通常根据选择器的类型、类、ID 和内联样式等进行计算。选择器的权重值越高，其样式优先级越高。</li> <li><strong>重要性</strong>（Importance）可以通过 <code>!important</code> 关键字来设置。使用 <code>!important</code> 的样式具有最高的优先级，将覆盖任何其他样式规则。然而，滥用 <code>!important</code> 可能导致样式管理的困难，应该慎用。</li> <li><strong>层叠顺序</strong>（Cascade Order）也会影响样式的优先级。当存在多个具有相同权重和重要性的样式规则时，后写的样式规则将覆盖先写的样式规则。</li></ol>
<p>综上所述，通过计算选择器的权重、考虑重要性以及根据样式规则的层叠顺序，可以确定 CSS 样式的优先级，并最终确定应用在元素上的样式。</p>
<p><strong>小结</strong></p>
<ul><li>计算权重确定</li> <li><code>!important</code></li> <li>内联样式</li> <li>后写的优先级高</li></ul>
<h3 id="_32-自定义字体的使用场景"><a href="#_32-自定义字体的使用场景" class="header-anchor">#</a> 32 自定义字体的使用场景</h3>
<p>自定义字体可以在以下场景中使用：</p>
<ol><li><strong>宣传和品牌</strong>：使用自定义字体可以增加品牌的独特性和识别度。品牌标语、宣传资料、广告等场合可以使用自定义字体来传达品牌的风格和形象。</li> <li><strong>Banner 设计</strong>：在网站或移动应用的横幅广告（Banner）设计中，自定义字体可以使文字内容更加吸引人，与整体设计风格相匹配，并帮助吸引用户的注意力。</li> <li><strong>固定文案</strong>：如果有一些特定的文案需要在网站或应用中固定展示，如标题、标语、特殊提示等，使用自定义字体可以使这些文案与其他普通文本区分开来，突出其重要性或特殊性。</li> <li><strong>字体图标</strong>：自定义字体可以用于创建字体图标集合，如使用字体图标库（如Font Awesome）来代替传统的图标文件。这样可以提供灵活性和可扩展性，通过CSS样式来控制图标的颜色、大小和样式，而无需使用单独的图像文件。</li></ol>
<p>总之，自定义字体在需要强调品牌形象、设计吸引人的文案或创建字体图标集合等场景中非常有用。它们为设计师和开发人员提供了更多的创意和自定义选项，以满足特定的设计需求。</p>
<h3 id="_33-如何美化checkbox"><a href="#_33-如何美化checkbox" class="header-anchor">#</a> 33 如何美化CheckBox</h3>
<ul><li><code>&lt;label&gt;</code> 属性 <code>for</code> 和 <code>id</code></li> <li>隐藏原生的 <code>&lt;input&gt;</code></li> <li><code>:checked + &lt;label&gt;</code></li></ul>
<p><strong>要美化复选框（CheckBox），可以按照以下步骤进行操作：</strong></p>
<ol><li>使用 <code>&lt;label&gt;</code> 标签和关联的 <code>&lt;input&gt;</code> 元素：将复选框包裹在 <code>&lt;label&gt;</code> 标签中，并使用 <code>for</code> 属性与对应的 <code>&lt;input&gt;</code> 元素的 <code>id</code> 进行关联，确保点击标签时也可以触发复选框的选择状态。</li></ol>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myCheckbox<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Checkbox Label<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myCheckbox<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<ol start="2"><li>隐藏原生的 <code>&lt;input&gt;</code> 元素：使用 CSS 样式将原生的 <code>&lt;input&gt;</code> 元素隐藏起来，使其不可见。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">input[type="checkbox"]</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="3"><li>使用 CSS 样式美化复选框：利用 CSS 样式为复选框创建自定义的外观效果。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">input[type="checkbox"] + label</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 定义复选框的样式 */</span>
<span class="token punctuation">}</span>

<span class="token selector">input[type="checkbox"]:checked + label</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 定义选中时复选框的样式 */</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>在上述样式中，<code>:checked</code> 选择器用于选中状态下的样式，<code>+</code> 选择器用于选择紧接在 <code>&lt;input&gt;</code> 元素后的兄弟 <code>&lt;label&gt;</code> 元素。</p>
<p>通过调整这些样式，您可以改变复选框的外观，如更改背景颜色、添加边框、改变图标等。可以使用 CSS 属性如 <code>background-color</code>、<code>border</code>、<code>color</code>、<code>content</code> 等来设置样式。</p>
<p>例如，以下示例将复选框的背景颜色设置为蓝色，并在选中时添加一个打勾的图标：</p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">input[type="checkbox"] + label</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>
  <span class="token property">padding-left</span><span class="token punctuation">:</span> 25px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token property">cursor</span><span class="token punctuation">:</span> pointer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">input[type="checkbox"] + label:before</span> <span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 2px solid #999<span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> 3px<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 2px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">input[type="checkbox"]:checked + label:before</span> <span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token property">border-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">"\2713"</span><span class="token punctuation">;</span>
  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token property">font-size</span><span class="token punctuation">:</span> 14px<span class="token punctuation">;</span>
  <span class="token property">line-height</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span>
  <span class="token property">color</span><span class="token punctuation">:</span> #fff<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>通过使用类似上述的 CSS 样式，您可以根据需要定制复选框的外观和样式，以实现美化效果。</p>
<h3 id="_34-伪类和伪元素的区别"><a href="#_34-伪类和伪元素的区别" class="header-anchor">#</a> 34 伪类和伪元素的区别</h3>
<ul><li>伪类表状态</li> <li>伪元素是真的有元素</li> <li>前者单冒号，后者双冒号</li></ul>
<p><strong>以下是对伪类和伪元素的更详细解释：</strong></p>
<ul><li>伪类（Pseudo-classes）是用于选择元素的特定状态或条件的关键词。它们以单冒号（<code>:</code>）作为前缀，并应用于选择器的末尾。伪类选择器可以选择处于特定状态的元素，例如鼠标悬停、被点击、被选中等。常见的伪类包括 <code>:hover</code>、<code>:active</code>、<code>:visited</code>、<code>:nth-child</code> 等。</li> <li>伪元素（Pseudo-elements）则是用于在文档中创建虚拟的元素，这些元素可以在选中的元素中添加额外的样式和内容。伪元素以双冒号（<code>::</code>）作为前缀，并应用于选择器的末尾。伪元素可以在选中的元素中插入新的内容或样式，如在元素前、后插入内容或改变选中元素的某个部分的样式。常见的伪元素包括 <code>::before</code>、<code>::after</code>、<code>::first-line</code>、<code>::first-letter</code> 等。</li></ul>
<p>总结来说，伪类用于选择特定状态的元素，而伪元素则用于在选中的元素中创建虚拟的元素。伪类以单冒号（<code>:</code>）作为前缀，伪元素以双冒号（<code>::</code>）作为前缀。在实际使用中，由于历史原因，有些伪元素也可以使用单冒号（<code>:</code>）来表示，但为了遵循最新的规范，推荐使用双冒号（<code>::</code>）表示伪元素。</p>
<h3 id="_35-base64的使用"><a href="#_35-base64的使用" class="header-anchor">#</a> 35 <code>base64</code>的使用</h3>
<ul><li>用于减少 <code>HTTP</code> 请求</li> <li>适用于小图片</li> <li><code>base64</code>的体积约为原图的<code>3/4</code></li></ul>
<p><code>base64</code> 是一种将二进制数据编码为 ASCII 字符串的方法，它常被用于将小文件（如图片、字体文件等）嵌入到 HTML、CSS 或 JavaScript 中，从而减少对服务器的请求次数。</p>
<p>使用 <code>base64</code> 编码可以将二进制文件转换为文本字符串，这样可以直接将字符串嵌入到代码中，而无需单独请求文件。这样做的好处是可以减少 HTTP 请求的数量，提升页面加载速度，尤其适用于小图片或者一些图标字体等。</p>
<p>然而，使用 <code>base64</code> 编码也有一些注意事项。由于 <code>base64</code> 编码后的文本字符串比原始二进制数据体积大约增加了 <code>1/3</code>，因此对于大文件来说，使用 <code>base64</code> 会导致数据传输量增加，可能会影响网页的加载速度。此外，由于嵌入了文件内容，导致代码体积增大，也会对可维护性产生一定的影响。</p>
<p>因此，通常建议将 <code>base64</code> 使用在小文件上，如小图标、小图片等，而对于大文件，仍然应该以原始文件的形式进行请求和传输，以获得更好的性能和可维护性。</p>
<h3 id="_36-自适应布局"><a href="#_36-自适应布局" class="header-anchor">#</a> 36 自适应布局</h3>
<p><strong>思路：</strong></p>
<ul><li>左侧浮动或者绝对定位，然后右侧<code>margin</code>撑开</li> <li>使用<code>&lt;div&gt;</code>包含，然后靠负<code>margin</code>形成<code>bfc</code></li> <li>使用<code>flex</code></li></ul>
<blockquote><p>自适应布局是指能够根据不同设备或窗口尺寸自动调整布局的一种设计方式。下面是几种常见的自适应布局方法：</p></blockquote>
<ol><li>使用浮动或绝对定位：左侧元素使用浮动或绝对定位，右侧元素通过设置左侧元素的<code>margin</code>来撑开布局。这种方法需要手动计算和设置宽度和间距，适用于简单的布局需求。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.left</span> <span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.right</span> <span class="token punctuation">{</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> 220px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="2"><li>使用包含元素和负边距：将左右两个元素放在一个容器内，设置容器的<code>overflow</code>属性为<code>hidden</code>，然后通过负边距将左侧元素向左移动，右侧元素则会自动占据剩余空间。这种方法需要使用负边距，适用于复杂布局需求。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.left</span> <span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.right</span> <span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div>
<ol start="3"><li>使用 Flexbox 布局：使用 Flexbox 弹性布局可以轻松实现自适应布局。通过设置容器的<code>display</code>属性为<code>flex</code>，并使用<code>flex-grow</code>属性来控制元素的伸缩性，可以自动调整元素的宽度和布局。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.left</span> <span class="token punctuation">{</span>
  <span class="token property">flex-grow</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">flex-shrink</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.right</span> <span class="token punctuation">{</span>
  <span class="token property">flex-grow</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>以上是一些常见的自适应布局方法，根据具体的需求和场景，可以选择合适的方法来实现自适应布局。</p>
<h3 id="_37-请用css写一个简单的幻灯片效果页面"><a href="#_37-请用css写一个简单的幻灯片效果页面" class="header-anchor">#</a> 37 请用CSS写一个简单的幻灯片效果页面</h3>
<blockquote><p>知道是要用<code>CSS3</code>。使用<code>animation</code>动画实现一个简单的幻灯片效果</p></blockquote>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token comment">/**css**/</span>
<span class="token selector">.ani</span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span>480px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span>320px<span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span>50px auto<span class="token punctuation">;</span>
  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
  <span class="token property">box-shadow</span><span class="token punctuation">:</span>0 0 5px <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span>0<span class="token punctuation">,</span>0<span class="token punctuation">,</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">background-size</span><span class="token punctuation">:</span> cover<span class="token punctuation">;</span>
  <span class="token property">background-position</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token property">-webkit-animation-name</span><span class="token punctuation">:</span> <span class="token string">"loops"</span><span class="token punctuation">;</span>
  <span class="token property">-webkit-animation-duration</span><span class="token punctuation">:</span> 20s<span class="token punctuation">;</span>
  <span class="token property">-webkit-animation-iteration-count</span><span class="token punctuation">:</span> infinite<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token atrule"><span class="token rule">@-webkit-keyframes</span> <span class="token string">"loops"</span></span> <span class="token punctuation">{</span>
    <span class="token selector">0%</span> <span class="token punctuation">{</span>
        <span class="token property">background</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg<span class="token punctuation">)</span></span> no-repeat<span class="token punctuation">;</span>             
    <span class="token punctuation">}</span>
    <span class="token selector">25%</span> <span class="token punctuation">{</span>
        <span class="token property">background</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg<span class="token punctuation">)</span></span> no-repeat<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token selector">50%</span> <span class="token punctuation">{</span>
        <span class="token property">background</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg<span class="token punctuation">)</span></span> no-repeat<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token selector">75%</span> <span class="token punctuation">{</span>
        <span class="token property">background</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg<span class="token punctuation">)</span></span> no-repeat<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token selector">100%</span> <span class="token punctuation">{</span>
        <span class="token property">background</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg<span class="token punctuation">)</span></span> no-repeat<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h3 id="_38-什么是外边距重叠-重叠的结果是什么"><a href="#_38-什么是外边距重叠-重叠的结果是什么" class="header-anchor">#</a> 38 什么是外边距重叠？重叠的结果是什么？</h3>
<blockquote><p>外边距重叠就是margin-collapse</p></blockquote>
<ul><li>在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</li></ul>
<p><strong>折叠结果遵循下列计算规则</strong>：</p>
<ul><li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li> <li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li> <li>两个外边距一正一负时，折叠结果是两者的相加的和。</li></ul>
<p><strong>下面是详细分析</strong></p>
<p>外边距重叠（margin collapse）指的是在某些情况下，相邻的两个元素之间的外边距会发生合并，并且取两者之间的较大值作为最终的外边距值。外边距重叠主要发生在垂直方向上，而水平方向上的外边距不会发生重叠。</p>
<p>外边距重叠的结果是两个相邻元素的外边距被合并成一个单独的外边距，这可能会导致布局上的一些意外效果，比如元素之间的间距变得比预期的要大。</p>
<p>下面是一些常见情况下外边距重叠的例子：</p>
<ol><li>相邻的兄弟元素的外边距重叠：</li></ol>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>
  <span class="token property">margin-top</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>在这个例子中，两个相邻的兄弟元素之间的上下外边距会发生重叠，最终的外边距值为<code>30px</code>，而不是预期的<code>50px</code>。</p>
<ol><li>父元素与第一个/最后一个子元素的外边距重叠：</li></ol>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>child<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">margin-top</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>在这个例子中，父元素的下外边距和子元素的上外边距发生重叠，最终的外边距值为30px，而不是预期的50px。</p>
<p>了解外边距重叠的规则可以帮助我们更好地控制元素的布局，避免意外的外边距重叠效果。在需要避免外边距重叠的情况下，可以使用一些方法，如使用内边距（padding）或边框（border）来隔离外边距、使用浮动（float）或绝对定位（position）等。</p>
<h3 id="_39-rgba-和opacity的透明效果有什么不同"><a href="#_39-rgba-和opacity的透明效果有什么不同" class="header-anchor">#</a> 39 rgba()和opacity的透明效果有什么不同？</h3>
<ul><li><code>rgba()</code> 是一种CSS颜色值表示方法，可以在其中指定红、绿、蓝三个通道的颜色值以及透明度。通过调整透明度值来实现元素的透明效果，仅影响元素的颜色或背景色，不影响元素内的其他内容的透明度。</li></ul>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>255<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0.5<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 半透明红色背景 */</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ul><li><code>opacity</code> 是CSS属性，用于设置元素的整体透明度。它会影响元素以及元素内的所有内容的透明度，包括文本、图像等。设置元素的透明度会影响整个元素及其内容的可见性。</li></ul>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">opacity</span><span class="token punctuation">:</span> 0.5<span class="token punctuation">;</span> <span class="token comment">/* 元素及其内容半透明 */</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>需要注意的是，<code>opacity</code> 的值是一个0到1之间的数字，0表示完全透明，1表示完全不透明。而 <code>rgba()</code> 中的透明度值是一个介于0到1之间的数字，0表示完全透明，1表示完全不透明。</p>
<p>另外，需要注意的是，<code>opacity</code> 的透明度是继承的，子元素会继承父元素的透明度效果，而 <code>rgba()</code> 设置的透明度不会继承给子元素。</p>
<p>综上所述，<code>rgba()</code> 和 <code>opacity</code> 在实现透明效果上有一些不同，需要根据具体的需求和效果来选择使用哪种方式。</p>
<p><strong>小结</strong></p>
<ul><li><code>rgba()</code>和<code>opacity</code>都能实现透明效果，但最大的不同是<code>opacity</code>作用于元素，以及元素内的所有内容的透明度，</li> <li>而<code>rgba()</code>只作用于元素的颜色或其背景色。（设置<code>rgba</code>透明的元素的子元素不会继承透明效果！）</li></ul>
<h3 id="_40-css中可以让文字在垂直和水平方向上重叠的两个属性是什么"><a href="#_40-css中可以让文字在垂直和水平方向上重叠的两个属性是什么" class="header-anchor">#</a> 40 css中可以让文字在垂直和水平方向上重叠的两个属性是什么？</h3>
<ul><li>垂直方向：<code>line-height</code></li> <li>水平方向：<code>letter-spacing</code></li></ul>
<p>在CSS中，可以使用以下两个属性实现文字在垂直和水平方向上的重叠：</p>
<ul><li><p>垂直方向：<code>line-height</code></p> <ul><li>通过设置 <code>line-height</code> 属性，可以控制行高，从而实现文字在垂直方向上的重叠。将 <code>line-height</code> 的值设置为大于文字大小的值，可以使文字垂直居中或与其他文字重叠。</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.text</span> <span class="token punctuation">{</span>
  <span class="token property">line-height</span><span class="token punctuation">:</span> 1.5<span class="token punctuation">;</span> <span class="token comment">/* 行高为文字大小的1.5倍 */</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>水平方向：<code>letter-spacing</code></p> <ul><li>通过设置 <code>letter-spacing</code> 属性，可以控制字符之间的间距，从而实现文字在水平方向上的重叠。将 <code>letter-spacing</code> 的值设置为负数，可以让字符紧密排列，产生重叠效果。</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.text</span> <span class="token punctuation">{</span>
  <span class="token property">letter-spacing</span><span class="token punctuation">:</span> -2px<span class="token punctuation">;</span> <span class="token comment">/* 字符间距为负数，产生重叠效果 */</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul>
<p>这两个属性可以根据具体的需求来调整，实现文字的垂直和水平方向上的重叠效果。</p>
<h3 id="_41-如何垂直居中一个浮动元素"><a href="#_41-如何垂直居中一个浮动元素" class="header-anchor">#</a> 41 如何垂直居中一个浮动元素？</h3>
<p>垂直居中一个浮动元素可以使用以下两种方法：</p>
<p>方法一（已知元素的高宽）：</p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">#div1</span> <span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> #6699FF<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> <span class="token comment">/* 父元素需要相对定位 */</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">margin-top</span><span class="token punctuation">:</span> -100px<span class="token punctuation">;</span> <span class="token comment">/* 二分之一的height */</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -100px<span class="token punctuation">;</span> <span class="token comment">/* 二分之一的width */</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>方法二：</p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">#div1</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> #6699FF<span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> <span class="token comment">/* 父元素需要相对定位 */</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>对于垂直居中一个 <code>&lt;img&gt;</code>，可以使用更简便的方法：</p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">#container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>上述代码将 <code>&lt;img&gt;</code> 元素放置在一个容器中（<code>#container</code>），通过使用 Flex 布局的 <code>justify-content: center;</code> 和 <code>align-items: center;</code> 属性，实现了图片在容器中的垂直居中效果。</p>
<h3 id="_42-px和em的区别"><a href="#_42-px和em的区别" class="header-anchor">#</a> 42 px和em的区别</h3>
<p><code>px</code>和<code>em</code>是两种不同的长度单位，它们的区别如下：</p>
<ul><li><code>px</code>（像素）是一个绝对单位，表示固定的像素大小。无论父元素的字体大小如何，<code>px</code>的值都不会改变，它是一个固定的长度单位。</li> <li><code>em</code>（倍数）是一个相对单位，它相对于父元素的字体大小来确定自身的大小。如果没有设置字体大小，则<code>1em</code>等于浏览器默认的字体大小（通常是<code>16px</code>）。如果父元素的字体大小是<code>16px</code>，那么<code>1em</code>就等于<code>16px</code>，<code>2em</code>就等于<code>32px</code>，以此类推。</li></ul>
<p>由于<code>em</code>是相对单位，它具有一定的灵活性和可扩展性。当需要调整整个页面的字体大小时，只需更改根元素的字体大小，其他使用<code>em</code>作为单位的元素会自动按比例调整大小，从而实现页面的整体缩放效果。</p>
<p>相对于<code>px</code>来说，<code>em</code>更适用于实现弹性布局、响应式设计以及根据用户偏好进行字体大小调整等场景。</p>
<p><strong>小结</strong></p>
<ul><li><code>px</code>和<code>em</code>都是长度单位，区别是，<code>px</code>的值是固定的，指定是多少就是多少，计算比较容易。<code>em</code>得值不是固定的，并且<code>em</code>会继承父级元素的字体大小。</li> <li>浏览器的默认字体高都是<code>16px</code>。所以未经调整的浏览器都符合: <code>1em=16px</code>。那么<code>12px=0.75em</code>, <code>10px=0.625em</code>。</li></ul>
<blockquote><ul><li>px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能</li> <li>em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size</li></ul></blockquote>
<h3 id="_43-sass、less是什么-大家为什么要使用他们"><a href="#_43-sass、less是什么-大家为什么要使用他们" class="header-anchor">#</a> 43 Sass、LESS是什么？大家为什么要使用他们？</h3>
<ul><li>他们是<code>CSS</code>预处理器。他是<code>CSS</code>上的一种抽象层。他们是一种特殊的语法/语言编译成<code>CSS</code>。</li> <li>例如Less是一种动态样式语言. 将CSS赋予了动态语言的特性，如变量，继承，运算， 函数. <code>LESS</code> 既可以在客户端上运行 (支持<code>IE 6+</code>, <code>Webkit</code>, <code>Firefox</code>)，也可一在服务端运行 (借助 <code>Node.js</code>)</li></ul>
<p><strong>以下是为什么人们选择使用Sass和Less的一些原因：</strong></p>
<ol><li><strong>变量和计算</strong>：Sass和Less都支持变量，可以定义和重用各种值，如颜色、字体、边距等。它们还允许进行数学计算，简化了样式表的编写和维护。</li> <li><strong>嵌套规则</strong>：Sass和Less允许在样式规则中嵌套其他规则，提高了样式表的可读性和可维护性。通过嵌套，可以更清晰地表示元素的层次结构，减少了样式选择器的重复。</li> <li><strong>混合（Mixins）</strong>：混合是一种可以在多个选择器中重复使用的样式块。通过定义和调用混合，可以避免样式的重复编写，并且使样式表更加模块化和可复用。</li> <li><strong>继承</strong>：继承允许一个选择器继承另一个选择器的样式规则，减少了样式的冗余。当多个选择器具有相同的样式时，可以通过继承来避免重复编写样式。</li> <li><strong>模块化和导入</strong>：Sass和Less支持将样式表拆分为多个模块，并通过导入机制进行组合。这使得样式表的组织和管理更加灵活和可扩展。</li> <li><strong>自定义函数</strong>：Sass和Less都允许定义自定义函数，可以用于处理样式值，进行复杂的计算和操作。</li> <li><strong>强大的工具和生态系统</strong>：Sass和Less都有丰富的工具和插件生态系统，提供了许多辅助工具、编译器和构建工具，如预处理器编译器、自动刷新、自动前缀添加等，极大地提升了前端开发的效率。</li></ol>
<p>总而言之，Sass和Less使得CSS的编写更加简洁、模块化和可维护，提供了一些高级功能和工具，使前端开发更加高效和灵活。</p>
<h3 id="_44-知道css有个content属性吗-有什么作用-有什么应用"><a href="#_44-知道css有个content属性吗-有什么作用-有什么应用" class="header-anchor">#</a> 44 知道css有个content属性吗？有什么作用？有什么应用？</h3>
<blockquote><p>css的<code>content</code>属性专门应用在 <code>before/after</code>伪元素上，用于来插入生成内容。最常见的应用是利用伪类清除浮动。</p></blockquote>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token comment">/**一种常见利用伪类清除浮动的代码**/</span>
<span class="token selector">.clearfix:after</span> <span class="token punctuation">{</span>
    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"."</span><span class="token punctuation">;</span>       //这里利用到了content属性
    <span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>
    <span class="token property">visibility</span><span class="token punctuation">:</span>hidden<span class="token punctuation">;</span>
    <span class="token property">clear</span><span class="token punctuation">:</span>both<span class="token punctuation">;</span> 
 <span class="token punctuation">}</span>
<span class="token selector">.clearfix</span> <span class="token punctuation">{</span>
    *<span class="token property">zoom</span><span class="token punctuation">:</span>1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ul><li><code>content</code>属性主要用于在<code>::before</code>和<code>::after</code>伪元素中插入生成的内容。它通常与伪元素一起使用，以在文档中插入额外的内容或修饰样式。</li> <li><code>content</code>属性可以接受多种类型的值，包括文本字符串、URL、计数器、计数器符号和引用标签等。通过设置不同的<code>content</code>值，可以实现一些常见的效果，例如：</li></ul>
<ol><li><strong>插入文本内容</strong>：可以在伪元素中使用<code>content</code>属性插入自定义的文本内容，用于装饰样式或添加额外的标识。</li> <li><strong>插入图标和符号</strong>：通过设置<code>content</code>属性为某个图标字体或Unicode编码，可以在伪元素中插入图标和特殊符号。</li> <li><strong>计数器</strong>：结合使用<code>content</code>属性和<code>counter</code>函数，可以在伪元素中显示自动生成的计数器，用于标记序号或计数。</li> <li><strong>引用标签</strong>：通过设置<code>content</code>属性为<code>attr()</code>函数，可以在伪元素中引用元素的属性值，用于显示元素的属性内容。</li></ol>
<p>上述代码示例中，通过设置<code>content</code>属性为一个点字符<code>.</code>，在<code>::after</code>伪元素中插入一个看不见的点，配合其他样式属性实现了清除浮动的效果。这是一种常见的清除浮动的技巧之一。</p>
<p>需要注意的是，<code>content</code>属性只对<code>::before</code>和<code>::after</code>伪元素起作用，对于其他元素并没有效果。此外，<code>content</code>属性必须与<code>display</code>属性一起使用，通常为<code>block</code>或<code>inline-block</code>，以确保生成的内容具有正确的布局。</p>
<h3 id="_45-水平居中的方法"><a href="#_45-水平居中的方法" class="header-anchor">#</a> 45 水平居中的方法</h3>
<ul><li>元素为行内元素，设置父元素<code>text-align:center</code></li> <li>如果元素宽度固定，可以设置左右<code>margin</code>为<code>auto</code>;</li> <li>绝对定位和移动: <code>absolute + transform</code></li> <li>使用<code>flex-box</code>布局，指定<code>justify-content</code>属性为center</li> <li><code>display</code>设置为<code>tabel-cell</code></li></ul>
<p>下面进行详细说明：</p>
<ol><li><strong>文本居中</strong>：如果元素为行内元素，可以将父元素的<code>text-align</code>属性设置为<code>center</code>，这样子元素就会水平居中对齐。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="2"><li><strong>固定宽度的居中</strong>：如果元素宽度已知并固定，可以通过将左右<code>margin</code>设置为<code>auto</code>来实现水平居中。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="3"><li><strong>绝对定位和移动</strong>：可以使用绝对定位和<code>transform</code>来实现水平居中。首先将元素的左边距和右边距都设置为<code>auto</code>，然后使用<code>transform</code>属性将元素向左平移50%。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateX</span><span class="token punctuation">(</span>-50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="4"><li><strong>Flexbox布局</strong>：使用<code>display: flex</code>将父元素设置为弹性容器，然后使用<code>justify-content</code>属性将子元素水平居中。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="5"><li><strong>表格布局</strong>：将父元素的<code>display</code>属性设置为<code>table-cell</code>，并将<code>text-align</code>属性设置为<code>center</code>。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>这些方法可以根据具体的布局需求和浏览器兼容性进行选择和使用。</p>
<h3 id="_46-垂直居中的方法"><a href="#_46-垂直居中的方法" class="header-anchor">#</a> 46 垂直居中的方法</h3>
<ul><li>将显示方式设置为表格，<code>display:table-cell</code>,同时设置<code>vertial-align：middle</code></li> <li>使用<code>flex</code>布局，设置为<code>align-item：center</code></li> <li>绝对定位中设置<code>bottom:0,top:0</code>,并设置<code>margin:auto</code></li> <li>绝对定位中固定高度时设置<code>top:50%，margin-top</code>值为高度一半的负值</li> <li>文本垂直居中设置<code>line-height</code>为<code>height</code>值</li> <li><code>inline-block</code>兄弟元素：通过在父元素中插入一个<code>inline-block</code>元素，并设置其垂直对齐方式为<code>middle</code>来实现垂直居中</li></ul>
<ol><li>表格布局：将父元素的display属性设置为table，并将子元素的display属性设置为table-cell，然后使用vertical-align属性将子元素垂直居中</li></ol>
<ul><li>未知高度的块级父子元素居中，模拟表格布局</li> <li>缺点：IE67不兼容，父级 <code>overflow：hidden</code> 失效</li></ul>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol><li>Flexbox布局：将父元素的display属性设置为flex，并使用align-items属性将子元素垂直居中。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="3"><li>绝对定位和负边距：对于已知高度的子元素，将父元素设置为相对定位，子元素设置为绝对定位，并使用<code>top: 50%</code>将其垂直居中，然后通过负边距的方式将子元素向上移动一半的高度</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">margin-top</span><span class="token punctuation">:</span> -50px<span class="token punctuation">;</span> <span class="token comment">/* 假设子元素高度为100px的一半 */</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="4"><li>文本垂直居中：对于单行文本，可以设置父元素的line-height属性和高度相等，从而实现文本的垂直居中</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">line-height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="5"><li>CSS3位移：使用CSS3的transform属性的translateY函数将子元素向上位移一半的高度实现垂直居中</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateY</span><span class="token punctuation">(</span>-50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="6"><li>inline-block兄弟元素：通过在父元素中插入一个inline-block元素，并设置其垂直对齐方式为middle来实现垂直居中</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.extra</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h3 id="_47-如何使用css实现硬件加速"><a href="#_47-如何使用css实现硬件加速" class="header-anchor">#</a> 47 如何使用CSS实现硬件加速？</h3>
<blockquote><p>硬件加速是指通过创建独立的复合图层，让GPU来渲染这个图层，从而提高性能，</p></blockquote>
<p>一般触发硬件加速的<code>CSS</code>属性有<code>transform</code>、<code>opacity</code>、<code>filter</code>，为了避免2D动画在开始和结束的时候的<code>repaint</code>操作，一般使用<code>tranform:translateZ(0)</code></p>
<p><strong>使用CSS实现硬件加速可以通过以下方法：</strong></p>
<ol><li><strong>使用3D变换</strong>：通过应用3D变换，如<code>translateZ(0)</code>，来触发硬件加速。这会将元素视为3D空间中的一个对象，使浏览器使用GPU进行渲染。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateZ</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="2"><li><strong>使用CSS动画</strong>：使用CSS动画属性（如<code>transform</code>、<code>opacity</code>、<code>filter</code>）来触发硬件加速。这可以通过创建一个动画并将其应用于元素来实现。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">animation</span><span class="token punctuation">:</span> myAnimation 1s linear infinite<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token atrule"><span class="token rule">@keyframes</span> myAnimation</span> <span class="token punctuation">{</span>
  <span class="token selector">0%</span> <span class="token punctuation">{</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateZ</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token selector">100%</span> <span class="token punctuation">{</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateZ</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="3"><li><strong>使用CSS过渡</strong>：通过使用CSS过渡属性（如<code>transform</code>、<code>opacity</code>、<code>filter</code>）来触发硬件加速。这可以通过设置过渡效果来实现。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">transition</span><span class="token punctuation">:</span> transform 0.3s ease<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.element:hover</span> <span class="token punctuation">{</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateZ</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>请注意，硬件加速并不是适用于所有情况的解决方案，它对于涉及大量动画或复杂渲染的元素特别有效。但是，在某些情况下，过多地使用硬件加速可能会导致性能问题，因此需要在实际使用时进行评估和测试。</p>
<h3 id="_48-重绘和回流-重排-是什么-如何避免"><a href="#_48-重绘和回流-重排-是什么-如何避免" class="header-anchor">#</a> 48 重绘和回流（重排）是什么，如何避免？</h3>
<p>重绘（Repaint）和回流（Reflow）是浏览器在渲染页面时的两个关键过程。</p>
<ul><li><strong>重绘（Repaint）</strong> 是指当元素的外观属性（如颜色、背景等）发生改变，但不影响布局时的重新绘制过程。重绘不会影响元素的几何尺寸和位置。</li> <li><strong>回流（Reflow）</strong> 是指当元素的布局属性（如尺寸、位置、隐藏/显示等）发生改变，导致浏览器重新计算元素的几何属性，重新构建渲染树的过程。回流会导致其他相关元素的回流和重绘。</li> <li>回流必将引起重绘，而重绘不一定会引起回流</li></ul>
<p>避免重绘和回流对于提高页面性能和响应速度至关重要。以下是一些减少重绘和回流的方法：</p>
<ul><li><strong>使用 CSS3 动画</strong>：使用 CSS3 的 <code>transform</code> 和 <code>opacity</code> 等属性来创建动画效果，因为它们会触发硬件加速，减少重绘和回流的影响。</li> <li><strong>批量修改样式</strong>：避免频繁修改单个元素的样式，尽可能将修改合并为一次操作，可以使用 <code>class</code> 或修改 <code>style</code> 属性的方式。</li> <li><strong>使用文档片段</strong>：当需要添加多个 DOM 元素到文档中时，可以先创建一个文档片段（<code>DocumentFragment</code>），将元素添加到片段中，然后再将片段一次性添加到文档中，减少回流次数。</li> <li><strong>使用离线 DOM</strong>：将元素从文档中移除（<code>display: none</code>），进行复杂的操作（如修改样式、添加子元素等），完成后再将元素放回文档，以减少回流和重绘的影响。</li> <li><strong>缓存布局属性值</strong>：如果需要多次访问某个元素的布局属性（如位置、尺寸等），可以将其值缓存起来，避免多次触发回流计算。</li> <li><strong>避免强制同步布局</strong>：避免在 JavaScript 中获取布局属性（如使用 <code>offsetTop</code>、<code>clientWidth</code> 等），因为它会强制同步计算布局信息，触发回流。如果需要获取布局信息，最好将获取操作放在一起，或使用 <code>getBoundingClientRect()</code> 方法。</li></ul>
<p>通过合理的设计和优化，可以最小化重绘和回流的次数，提高页面性能和用户体验。</p>
<h3 id="_49-说一说css3的animation"><a href="#_49-说一说css3的animation" class="header-anchor">#</a> 49 说一说css3的animation</h3>
<p>CSS3的<code>animation</code>属性是用于创建动画效果的一种方式。它可以通过关键帧（<code>@keyframes</code>）来定义动画的每一帧，以实现元素的平滑过渡和动态效果。</p>
<p>使用<code>animation</code>属性时，需要设置以下几个关键的子属性：</p>
<ul><li><strong><code>animation-name</code></strong>：定义动画的名称，对应<code>@keyframes</code>中的动画名。</li> <li><strong><code>animation-duration</code></strong>：定义动画的持续时间，可以设置为具体的时间值，如<code>2s</code>表示2秒，或者使用关键词<code>infinite</code>表示无限循环。</li> <li><strong><code>animation-timing-function</code></strong>：定义动画的时间函数，控制动画在不同时间点的速度变化，常见的取值有<code>linear</code>（线性）、<code>ease</code>（缓入缓出）、<code>ease-in</code>（缓入）、<code>ease-out</code>（缓出）、<code>ease-in-out</code>（缓入缓出）等。</li> <li><strong><code>animation-delay</code></strong>：定义动画的延迟时间，即动画开始之前的等待时间。</li> <li><strong><code>animation-iteration-count</code></strong>：定义动画的循环次数，可以设置为具体的次数，或者使用关键词<code>infinite</code>表示无限循环。</li> <li><strong><code>animation-direction</code></strong>：定义动画的播放方向，包括正常播放（<code>normal</code>）、反向播放（<code>reverse</code>）、交替反向播放（<code>alternate</code>）等。</li> <li><strong><code>animation-fill-mode</code></strong>：定义动画播放之前和之后的样式状态，包括保持初始状态（<code>none</code>）、保持最后状态（<code>forwards</code>）、保持初始和最后状态（<code>both</code>）等。</li> <li><strong><code>animation-play-state</code></strong>：定义动画的播放状态，可以控制动画的暂停和继续播放，包括<code>paused</code>（暂停）和<code>running</code>（运行）。</li></ul>
<p>通过调整这些子属性的取值，可以创建各种不同的动画效果，使元素在页面上实现平滑的过渡和动态的效果。CSS3的<code>animation</code>提供了一种简洁、易用且高性能的方式来实现动画效果，减少了对JavaScript的依赖。</p>
<h3 id="_50-左边宽度固定-右边自适应"><a href="#_50-左边宽度固定-右边自适应" class="header-anchor">#</a> 50 左边宽度固定，右边自适应</h3>
<blockquote><p>左侧固定宽度，右侧自适应宽度的两列布局实现</p></blockquote>
<p>html结构</p>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>outer<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>固定宽度<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>自适应宽度<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<blockquote><p>在外层<code>div</code>（类名为<code>outer</code>）的<code>div</code>中，有两个子<code>div</code>，类名分别为<code>left</code>和<code>right</code>，其中<code>left</code>为固定宽度，而<code>right</code>为自适应宽度</p></blockquote>
<p><strong>方法1：左侧div设置成浮动：float: left，右侧div宽度会自动适应</strong></p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.outer</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.left</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.right</span> <span class="token punctuation">{</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p><strong>方法2：对右侧:div进行绝对定位，然后再设置right=0，即可以实现宽度自适应</strong></p>
<blockquote><p>绝对定位元素的第一个高级特性就是其具有自动伸缩的功能，当我们将 <code>width</code>设置为 <code>auto</code> 的时候（或者不设置，默认为 <code>auto</code> ），绝对定位元素会根据其 <code>left</code> 和 <code>right</code> 自动伸缩其大小</p></blockquote>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.outer</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.left</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.right</span> <span class="token punctuation">{</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>          
    <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p><strong>方法3：将左侧<code>div</code>进行绝对定位，然后右侧<code>div</code>设置<code>margin-left: 200px</code></strong></p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.outer</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.left</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.right</span> <span class="token punctuation">{</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
    <span class="token property">margin-left</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p><strong>方法4：使用flex布局</strong></p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.outer</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
    <span class="token property">flex-direction</span><span class="token punctuation">:</span> row<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.left</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.right</span> <span class="token punctuation">{</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
    <span class="token property">flex</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h3 id="_51-两种以上方式实现已知或者未知宽度的垂直水平居中"><a href="#_51-两种以上方式实现已知或者未知宽度的垂直水平居中" class="header-anchor">#</a> 51 两种以上方式实现已知或者未知宽度的垂直水平居中</h3>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token comment">/** 1 **/</span>
<span class="token selector">.wraper</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token selector">.box</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> -50px 0 0 -50px<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/** 2 **/</span>
<span class="token selector">.wraper</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token selector">.box</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/** 3 **/</span>
<span class="token selector">.wraper</span> <span class="token punctuation">{</span>
  <span class="token selector">.box</span> <span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
    <span class="token property">justify-content</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span>
    <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/** 4 **/</span>
<span class="token selector">.wraper</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>
  <span class="token selector">.box</span> <span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
    <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h3 id="_52-如何实现小于12px的字体效果"><a href="#_52-如何实现小于12px的字体效果" class="header-anchor">#</a> 52 如何实现小于12px的字体效果</h3>
<p>实现小于12px的字体效果可以使用CSS的<code>transform: scale()</code>属性。但需要注意的是，该属性只能应用于具有宽度和高度的元素，而行内元素默认是没有宽度和高度的。</p>
<p>为了在行内元素上应用缩放效果，可以将其转换为具有宽度和高度的块级元素，例如使用<code>display: inline-block</code>。</p>
<p>下面是一个示例代码：</p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.small-text</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>0.7<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">transform-origin</span><span class="token punctuation">:</span> left top<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>在上述代码中，我们将目标元素的<code>display</code>属性设置为<code>inline-block</code>，然后应用了<code>transform: scale(0.7)</code>来缩小元素的大小，并通过<code>transform-origin: left top</code>设置缩放的基准点为左上角。</p>
<p>使用以上代码，可以实现小于12px的字体效果，但需要注意，缩放可能会导致文本的清晰度下降，因此在使用此技术时需要谨慎权衡效果和可读性。</p>
<h3 id="_53-css-hack原理及常用hack"><a href="#_53-css-hack原理及常用hack" class="header-anchor">#</a> 53 css hack原理及常用hack</h3>
<ul><li>原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。</li> <li>常见的hack有
<ul><li>属性hack</li> <li>选择器hack</li> <li>IE条件注释</li></ul></li></ul>
<p>CSS hack是一种技术手段，用于在不同的浏览器或特定的浏览器版本上应用不同的样式规则。它通过利用浏览器对CSS解析的差异来实现。</p>
<p>以下是一些常见的CSS hack及其应用：</p>
<ol><li>属性hack：针对特定浏览器或浏览器版本设置不同的属性值。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token comment">/* 仅适用于IE10及以下版本 */</span>
<span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> red\9<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="2"><li>选择器hack：使用特定的选择器来针对特定浏览器或浏览器版本。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token comment">/* 仅适用于IE6 */</span>
<span class="token selector">* html .element</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="3"><li>IE条件注释：通过IE条件注释来针对不同的IE版本应用不同的样式。</li></ol>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!--[if IE 7]&gt;
&lt;link rel="stylesheet" type="text/css" href="ie7.css" /&gt;
&lt;![endif]--&gt;</span>
</code></pre></div>
<p>上述代码中，<code>&lt;!--[if IE 7]&gt;</code>和<code>&lt;![endif]--&gt;</code>之间的样式表链接只会在IE7浏览器中生效。</p>
<p>需要注意的是，<code>CSS hack</code>是一种针对特定浏览器或浏览器版本的解决方案，但它可能存在以下问题：</p>
<ul><li>可能会导致代码的可读性和维护性降低。</li> <li>在不同的浏览器更新版本或新的浏览器出现时，需要更新和调整hack。</li> <li>可能会导致一些意外的副作用或兼容性问题。</li></ul>
<p>因此，在使用CSS hack时，需要权衡利弊，并尽量考虑更加稳定和标准的解决方案，例如使用CSS前缀、特性检测和渐进增强等方法来实现跨浏览器兼容性。</p>
<h3 id="_54-css有哪些继承属性"><a href="#_54-css有哪些继承属性" class="header-anchor">#</a> 54 CSS有哪些继承属性</h3>
<p>CSS中有一些属性是可以继承的，这意味着父元素的某些样式属性会自动应用到子元素上。以下是一些常见的继承属性：</p>
<ul><li>字体相关属性：
<ul><li><code>font</code></li> <li><code>font-family</code></li> <li><code>font-size</code></li> <li><code>font-weight</code></li> <li><code>font-style</code></li></ul></li> <li>文本排版属性：
<ul><li><code>word-break</code></li> <li><code>letter-spacing</code></li> <li><code>text-align</code></li> <li><code>text-rendering</code></li> <li><code>word-spacing</code></li> <li><code>white-space</code></li> <li><code>text-indent</code></li> <li><code>text-transform</code></li> <li><code>text-shadow</code></li></ul></li> <li>行高属性：
<ul><li><code>line-height</code></li></ul></li> <li>颜色相关属性：
<ul><li><code>color</code></li></ul></li> <li>可见性属性：
<ul><li><code>visibility</code></li></ul></li> <li>光标属性：
<ul><li><code>cursor</code></li></ul></li></ul>
<p>这些属性在父元素上设置后，会自动应用到其子元素上，除非子元素有自己的特定样式覆盖了继承的属性。</p>
<p>需要注意的是，并非所有的CSS属性都是可继承的，有些属性是不会传递给子元素的。在使用CSS样式时，需要注意属性的继承特性，以便正确地应用样式到子元素。</p>
<h3 id="_55-外边距折叠-collapsing-margins"><a href="#_55-外边距折叠-collapsing-margins" class="header-anchor">#</a> 55 外边距折叠(collapsing margins)</h3>
<p>外边距折叠（collapsing margins）是 CSS 中一种特定的行为，它会导致一些相邻元素的外边距合并成一个更大的外边距。以下是关于外边距折叠的几个规则：</p>
<ol><li>相邻的普通流中的块级元素的垂直外边距会折叠。只有垂直方向上的外边距才会发生折叠，水平方向上的外边距不会折叠。</li> <li>浮动元素、绝对定位元素以及行内块元素的外边距不会和其他元素的外边距折叠。</li> <li>创建了块级格式化上下文（BFC）的元素的外边距不会和其子元素的外边距折叠。常见的创建 BFC 的方式包括设置<code>overflow</code>为除<code>visible</code>之外的值、使用<code>float</code>属性、使用<code>position: absolute</code>等。</li> <li>相邻元素自身的<code>margin-bottom</code>和<code>margin-top</code>会折叠。当一个元素的<code>margin-bottom</code>和下一个元素的<code>margin-top</code>相邻时，它们会合并成一个外边距。</li></ol>
<p>外边距折叠在布局中可能会导致一些意外的效果，因此在需要避免外边距折叠的情况下，可以采用以下方法：</p>
<ul><li>设置<code>padding</code>、<code>border</code>或者使用<code>inline-block</code>等方式来阻止外边距折叠。</li> <li>使用浮动（<code>float</code>）或绝对定位（<code>position: absolute</code>）等方式创建块级格式化上下文（BFC），从而阻止外边距折叠。</li></ul>
<p>了解和掌握外边距折叠的规则可以帮助我们更好地处理布局和样式相关的问题。</p>
<h3 id="_56-css选择符有哪些-哪些属性可以继承"><a href="#_56-css选择符有哪些-哪些属性可以继承" class="header-anchor">#</a> 56 CSS选择符有哪些？哪些属性可以继承</h3>
<p>你列举的CSS选择器是正确的，以下是它们的详细说明：</p>
<ol><li>id选择器（<code>#myid</code>）：通过元素的id属性选择元素，id应该是唯一的。</li> <li>类选择器（<code>.myclassname</code>）：通过元素的class属性选择元素，一个元素可以有多个类名。</li> <li>标签选择器（<code>div</code>、<code>h1</code>、<code>p</code>等）：通过元素的标签名选择元素。</li> <li>相邻选择器（<code>h1 + p</code>）：选择紧接在指定元素后面的兄弟元素。</li> <li>子选择器（<code>ul &gt; li</code>）：选择指定元素的直接子元素。</li> <li>后代选择器（<code>li a</code>）：选择指定元素的后代元素，可以是子元素、孙子元素等。</li> <li>通配符选择器（<code>*</code>）：匹配所有元素。</li> <li>属性选择器（<code>a[rel="external"]</code>）：通过元素的属性值选择元素。</li> <li>伪类选择器（<code>a:hover</code>、<code>li:nth-child</code>等）：选择特定状态或位置的元素。</li></ol>
<p>这些选择器可以单独使用，也可以组合使用，以选择特定的元素或元素组。通过选择器，可以实现对页面中的不同元素进行样式控制和操作。</p>
<p><strong>CSS哪些属性可以继承？哪些属性不可以继承</strong></p>
<p>实际上，继承性并不是根据某个属性是可继承属性还是不可继承属性来决定的。继承性是根据具体的属性规定来决定的。以下是一些常见的可继承属性和不可继承属性的示例：</p>
<p>可继承属性：</p>
<ul><li>文本相关属性：<code>font-family</code>、<code>font-size</code>、<code>font-weight</code>、<code>font-style</code>、<code>line-height</code>、<code>color</code></li> <li>链接相关属性：<code>text-decoration</code>、<code>cursor</code></li> <li>盒模型相关属性：<code>margin</code>、<code>padding</code></li> <li>列表相关属性：<code>list-style-type</code>、<code>list-style-image</code>、<code>list-style-position</code></li> <li>表格相关属性：<code>border-collapse</code>、<code>border-spacing</code></li></ul>
<p>不可继承属性：</p>
<ul><li>盒模型相关属性：<code>width</code>、<code>height</code>、<code>border</code>、<code>border-radius</code>、<code>padding</code>、<code>margin</code></li> <li>定位属性：<code>position</code>、<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>、<code>float</code></li> <li>背景相关属性：<code>background-color</code>、<code>background-image</code>、<code>background-repeat</code>、<code>background-position</code>、<code>background-size</code></li></ul>
<p>需要注意的是，即使某个属性是可继承属性，但也可以通过显式设置子元素的样式来覆盖继承的值。另外，有些属性可以通过使用<code>inherit</code>关键字来强制继承父元素的值，即使它本身不具备继承性。</p>
<p>需要注意的是，以上列举的可继承属性和不可继承属性并非全部，具体的属性是否具有继承性需要查阅相关文档进行确认。</p>
<h3 id="_57-css3新增伪类有那些"><a href="#_57-css3新增伪类有那些" class="header-anchor">#</a> 57 CSS3新增伪类有那些</h3>
<p>你列举的是CSS3新增的一些伪类，它们可以用于选择特定的元素状态或位置。以下是它们的详细说明：</p>
<ol><li><code>:root</code>：选择文档的根元素，等同于<code>html</code>元素。</li> <li><code>:empty</code>：选择没有子元素的元素。</li> <li><code>:target</code>：选取当前活动的目标元素。</li> <li><code>:not(selector)</code>：选择除<code>selector</code>元素以外的元素。</li> <li><code>:enabled</code>：选择可用的表单元素。</li> <li><code>:disabled</code>：选择禁用的表单元素。</li> <li><code>:checked</code>：选择被选中的表单元素。</li> <li><code>:after</code>：在元素内部最前添加内容。</li> <li><code>:before</code>：在元素内部最后添加内容。</li> <li><code>:nth-child(n)</code>：匹配父元素下指定子元素中排序第<code>n</code>个的元素。</li> <li><code>:nth-last-child(n)</code>：匹配父元素下指定子元素中从后向前数排序第<code>n</code>个的元素。</li> <li><code>:nth-child(odd)</code>：匹配父元素下指定子元素中奇数位置的元素。</li> <li><code>:nth-child(even)</code>：匹配父元素下指定子元素中偶数位置的元素。</li> <li><code>:nth-child(3n+1)</code>：匹配父元素下指定子元素中满足3n+1位置的元素。</li> <li><code>:first-child</code>：选择父元素下的第一个子元素。</li> <li><code>:last-child</code>：选择父元素下的最后一个子元素。</li> <li><code>:only-child</code>：选择父元素下唯一的子元素。</li> <li><code>:nth-of-type(n)</code>：匹配父元素下指定类型的子元素中排序第<code>n</code>个的元素。</li> <li><code>:nth-last-of-type(n)</code>：匹配父元素下指定类型的子元素中从后向前数排序第<code>n</code>个的元素。</li> <li><code>:nth-of-type(odd)</code>：匹配父元素下指定类型的子元素中奇数位置的元素。</li> <li><code>:nth-of-type(even)</code>：匹配父元素下指定类型的子元素中偶数位置的元素。</li> <li><code>:nth-of-type(3n+1)</code>：匹配父元素下指定类型的子元素中满足3n+1位置的元素。</li> <li><code>:first-of-type</code>：选择父元素下指定类型的第一个子元素。</li> <li><code>:last-of-type</code>：选择父元素下指定类型的最后一个子元素。</li> <li><code>:only-of-type</code>：选择父元素下指定类型的唯一子元素。</li> <li><code>::selection</code>：选择被用户选取的元素部分。</li> <li><code>:first-line</code>：选择元素中的第一行。</li> <li><code>:first-letter</code>：选择元素中的第一个字符</li></ol>
<h3 id="_58-如何居中div-如何居中一个浮动元素-如何让绝对定位的div居中"><a href="#_58-如何居中div-如何居中一个浮动元素-如何让绝对定位的div居中" class="header-anchor">#</a> 58 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中</h3>
<p>要居中一个<code>div</code>，可以使用以下方法：</p>
<ol><li>使用<code>margin: 0 auto;</code>将<code>div</code>水平居中。前提是给<code>div</code>设置一个固定的宽度。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">div</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="2"><li>对于浮动元素，可以使用相对定位和负边距的方式进行居中。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.float-element</span> <span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateX</span><span class="token punctuation">(</span>-50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="3"><li>对于绝对定位的<code>div</code>，可以通过设置<code>top</code>, <code>left</code>, <code>right</code>, <code>bottom</code> 属性为 <code>0</code>，并将<code>margin</code>设置为<code>auto</code>来实现居中。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.absolute-element</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>以上是一些常用的居中方法，具体选择哪种方法取决于你的布局需求和元素的类型。</p>
<h3 id="_59-用纯css创建一个三角形的原理是什么"><a href="#_59-用纯css创建一个三角形的原理是什么" class="header-anchor">#</a> 59 用纯CSS创建一个三角形的原理是什么</h3>
<p>使用纯CSS创建三角形的原理是利用元素的边框属性来实现。</p>
<p><strong>具体步骤如下：</strong></p>
<ol><li>创建一个具有宽度和高度为0的元素。</li> <li>设置元素的边框宽度为一个较大的值，例如 <code>20px</code>。</li> <li>设置元素的边框样式为 <code>solid</code>，表示实线边框。</li> <li>通过调整元素的边框颜色，使得三条边中的一条边有颜色，其余两条边颜色为透明，从而形成三角形的形状。</li></ol>
<p>在给定的示例中，<code>#demo</code>元素的宽度和高度为0，边框宽度为20px，边框颜色设置为透明、透明、红色和透明，从而形成一个红色的等腰三角形。</p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token comment">/* 把上、右、左、三条边隐藏掉（颜色设为 transparent） */</span>
<span class="token selector">#demo</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">border-width</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
  <span class="token property">border-style</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>
  <span class="token property">border-color</span><span class="token punctuation">:</span> transparent transparent red transparent<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h3 id="_60-一个满屏-品-字布局-如何设计"><a href="#_60-一个满屏-品-字布局-如何设计" class="header-anchor">#</a> 60 一个满屏 品 字布局 如何设计?</h3>
<p>要实现一个满屏的"品"字布局，可以采用以下方法：</p>
<p>HTML 结构：</p>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>middle<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bottom<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<p>CSS 样式：</p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100vh<span class="token punctuation">;</span> <span class="token comment">/* 或者使用 height: 100% */</span>
<span class="token punctuation">}</span>

<span class="token selector">.top, .middle, .bottom</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 50vh<span class="token punctuation">;</span> <span class="token comment">/* 或者使用 height: 50% */</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span> <span class="token comment">/* 或者使用 display: inline-block; */</span>
<span class="token punctuation">}</span>

<span class="token selector">.top</span> <span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span> <span class="token comment">/* 设置上方区域的背景色 */</span>
<span class="token punctuation">}</span>

<span class="token selector">.middle</span> <span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span> <span class="token comment">/* 设置中间区域的背景色 */</span>
<span class="token punctuation">}</span>

<span class="token selector">.bottom</span> <span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span> <span class="token comment">/* 设置下方区域的背景色 */</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>这样设置后，上方区域（红色）占据整个屏幕宽度的一半，中间区域（白色）和下方区域（蓝色）各占据屏幕宽度的一半。可以使用 <code>float: left;</code> 或者 <code>display: inline-block;</code> 来让它们在同一行显示，不换行。</p>
<h3 id="_61-li与li之间有看不见的空白间隔是什么原因引起的-有什么解决办法"><a href="#_61-li与li之间有看不见的空白间隔是什么原因引起的-有什么解决办法" class="header-anchor">#</a> 61 li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法</h3>
<p>li 与 li 之间的看不见的空白间隔是由于 HTML 中的换行符和空格字符造成的。这些空白字符会被解析为文本节点，而文本节点默认会应用一定的样式，导致 li 之间产生间隔。</p>
<p>解决这个问题的方法有多种，以下是一些常见的解决办法：</p>
<ol><li>使用负 margin：可以将 li 的 margin 设置为负值，例如 <code>margin-right: -4px;</code>。这样可以抵消掉 li 之间的间隔。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">ul</span> <span class="token punctuation">{</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">li</span> <span class="token punctuation">{</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> -4px<span class="token punctuation">;</span>
  <span class="token property">padding-right</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>
  <span class="token property">list-style</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="2"><li>使用浮动：给 li 添加 <code>float: left;</code> 属性，使其浮动在一行内，消除间隔。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">ul</span> <span class="token punctuation">{</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">li</span> <span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">list-style</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="3"><li>使用 Flexbox 布局：将 ul 设置为 Flex 容器，使 li 自动排列在一行内，间隔消失。</li></ol>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">ul</span> <span class="token punctuation">{</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">li</span> <span class="token punctuation">{</span>
  <span class="token property">list-style</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>这些方法可以根据具体情况选择使用，根据不同的布局需求选择最合适的解决办法。</p>
<h3 id="_62-请列举几种隐藏元素的方法"><a href="#_62-请列举几种隐藏元素的方法" class="header-anchor">#</a> 62 请列举几种隐藏元素的方法</h3>
<ol><li><code>visibility: hidden;</code>: 设置元素为隐藏状态，但仍然占据空间。</li> <li><code>opacity: 0;</code>: 将元素的透明度设置为0，使其完全透明。</li> <li><code>position: absolute;</code>或<code>left: -9999px;</code>: 将元素定位到屏幕可见区域之外，实现隐藏效果。</li> <li><code>display: none;</code>: 将元素设为不可见，并且不占据页面布局空间。</li> <li><code>transform: scale(0);</code>: 将元素的缩放比例设置为0，元素将不可见，但原始位置仍保留。</li> <li><code>&lt;div hidden="hidden"&gt;</code>: 使用<code>hidden</code>属性来隐藏元素，与<code>display: none;</code>效果相同，但用于记录元素的状态。</li> <li><code>height: 0;</code>: 将元素的高度设为0，消除边框，使其不可见。</li> <li><code>filter: blur(0);</code>: 使用<code>filter</code>属性将元素的模糊度设置为0，从视觉上使元素“消失”。</li></ol>
<p>这些方法可以根据实际需求选择适合的隐藏方式，以达到隐藏元素的效果。</p>
<h3 id="_63-rgba-和-opacity-的透明效果有什么不同"><a href="#_63-rgba-和-opacity-的透明效果有什么不同" class="header-anchor">#</a> 63 rgba() 和 opacity 的透明效果有什么不同</h3>
<ul><li><code>opacity</code> 作用于元素以及元素内的所有内容（包括文字）的透明度</li> <li><code>rgba()</code> 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果</li></ul>
<blockquote><p><code>opacity</code> 和 <code>rgba()</code> 在透明效果上有以下不同：</p></blockquote>
<ul><li><code>opacity</code>：设置元素及其内容的透明度。透明度值范围为 0（完全透明）到 1（完全不透明）。透明度会应用于元素及其内部所有内容，包括文本、图像等。这意味着如果将一个元素的透明度设置为 0.5，那么元素及其内容都会以半透明的形式显示。</li></ul>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">opacity</span><span class="token punctuation">:</span> 0.5<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ul><li><code>rgba()</code>：用于设置元素自身的颜色或背景色的透明度。这个函数接受四个参数，前三个参数表示颜色的红、绿、蓝通道的数值（取值范围 0-255），第四个参数表示透明度（取值范围 0-1）。透明度值为 0 表示完全透明，为 1 表示完全不透明。这意味着只有元素自身的颜色或背景色会受到透明度的影响，而元素内部的内容不会继承透明效果。</li></ul>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.element</span> <span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>255<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0.5<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 红色背景，透明度为 0.5 */</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>总结来说，<code>opacity</code> 会影响元素及其内部所有内容的透明度，而 <code>rgba()</code> 只会影响元素自身的颜色或背景色的透明度，不会影响元素内部的内容。</p>
<h3 id="_64-css-属性-content-有什么作用"><a href="#_64-css-属性-content-有什么作用" class="header-anchor">#</a> 64 css 属性 content 有什么作用</h3>
<p><code>content</code> 属性主要用于在 <code>::before</code> 和 <code>::after</code> 伪元素中插入额外的内容或样式。</p>
<p>通过设置 <code>content</code> 属性，可以在元素的前面或后面插入指定的内容，包括文本、图标、计数等。它可以接受各种值，如字符串、引用、计数器等。</p>
<p>例如，可以使用 <code>content</code> 属性在元素前面插入一个文本字符：</p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.element::before</span> <span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">"→"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>上述代码将在 <code>.element</code> 元素的前面插入一个箭头字符。</p>
<p>此外，<code>content</code> 属性还可以与其他 CSS 属性一起使用，例如结合 <code>attr()</code> 函数来获取元素的属性值并插入到内容中：</p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.element::before</span> <span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token function">attr</span><span class="token punctuation">(</span>data-text<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>上述代码会将元素的 <code>data-text</code> 属性值插入到 <code>.element</code> 元素的前面作为内容。</p>
<p>需要注意的是，<code>content</code> 属性只能用于 <code>::before</code> 和 <code>::after</code> 伪元素中，并且必须配合 <code>display</code> 属性设置为 <code>inline</code> 或 <code>inline-block</code> 才能生效。</p>
<h3 id="_65-请解释一下-css3-的-flexbox-弹性盒布局模型-以及适用场景"><a href="#_65-请解释一下-css3-的-flexbox-弹性盒布局模型-以及适用场景" class="header-anchor">#</a> 65 请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景</h3>
<p><code>Flexbox</code> 是 CSS3 中引入的一种弹性盒布局模型，用于在容器内创建灵活的、自适应的布局。它提供了一种强大的方式来对齐、分布和调整容器中的项目。</p>
<p><code>Flexbox</code> 的适用场景包括但不限于以下情况：</p>
<ol><li>等高布局：<code>Flexbox</code> 可以轻松实现容器内多个项目等高的布局，无论项目的内容多少。</li> <li>自适应布局：<code>Flexbox</code> 可以根据容器的可用空间自动调整项目的大小，以适应不同尺寸的屏幕或容器。</li> <li>项目排序：<code>Flexbox</code> 可以通过改变项目的顺序来实现在不同屏幕尺寸下的布局调整。</li> <li>对齐和分布：<code>Flexbox</code> 提供了多种对齐和分布项目的方式，如水平居中、垂直居中、平均分布等。</li> <li>响应式设计：<code>Flexbox</code> 可以与媒体查询结合使用，根据屏幕尺寸调整容器中项目的布局方式。</li></ol>
<p><code>Flexbox</code> 的特点包括：</p>
<ul><li>父容器具有弹性，可以自动调整项目的大小和顺序。</li> <li>子项目可以具有灵活的宽度、高度和顺序。</li> <li>可以轻松实现响应式设计，适应不同的屏幕尺寸和设备。</li> <li>提供了多种对齐和分布项目的属性和方法，使布局更加灵活和易于控制。</li></ul>
<p>总而言之，<code>Flexbox</code> 提供了一种简单、直观且强大的布局方式，适用于构建各种自适应和灵活的布局，特别适合用于构建响应式设计和移动端布局。</p>
<h3 id="_66-经常遇到的浏览器的js兼容性有哪些-解决方法是什么"><a href="#_66-经常遇到的浏览器的js兼容性有哪些-解决方法是什么" class="header-anchor">#</a> 66 经常遇到的浏览器的JS兼容性有哪些？解决方法是什么</h3>
<p>经常遇到的浏览器的 JavaScript 兼容性问题及解决方法如下：</p>
<ol><li>当前样式：获取元素的当前样式属性值</li></ol>
<ul><li>解决方法：使用 <code>getComputedStyle(el, null)</code> 方法获取当前样式属性值，或者使用 <code>el.currentStyle</code> 属性（仅适用于 IE 浏览器）。</li></ul>
<ol start="2"><li>事件对象：处理事件时获取事件对象</li></ol>
<ul><li>解决方法：使用 <code>e</code> 参数获取事件对象，或者使用 <code>window.event</code>（仅适用于 IE 浏览器）。</li></ul>
<ol start="3"><li>鼠标坐标：获取鼠标在页面上的坐标位置</li></ol>
<ul><li>解决方法：使用 <code>e.pageX</code> 和 <code>e.pageY</code> 获取鼠标坐标位置，或者使用 <code>window.event.x</code> 和 <code>window.event.y</code>（仅适用于 IE 浏览器）。</li></ul>
<ol start="4"><li>按键码：处理键盘事件时获取按下的键盘按键码</li></ol>
<ul><li>解决方法：使用 <code>e.which</code> 获取按键码，或者使用 <code>event.keyCode</code>（仅适用于 IE 浏览器）。</li></ul>
<ol start="5"><li>文本节点：获取元素中的文本内容</li></ol>
<ul><li>解决方法：使用 <code>el.textContent</code> 获取文本内容，或者使用 <code>el.innerText</code>（仅适用于 IE 浏览器）。</li></ul>
<p><strong>为了解决浏览器的兼容性问题，可以采取以下方法：</strong></p>
<ol><li>特性检测：通过检测浏览器是否支持某个特定的方法或属性，从而决定使用哪种方式来处理。</li> <li>浏览器嗅探：根据浏览器的用户代理字符串来识别浏览器类型，从而采取相应的处理方式。</li> <li>使用兼容性库：如 <code>Modernizr</code>、<code>jQuery</code> 等，它们封装了许多兼容性处理的方法，可以简化开发过程。</li> <li>编写跨浏览器的代码：使用一致的标准和通用的 JavaScript 方法，避免依赖特定浏览器的特性。</li></ol>
<p>综上所述，通过特性检测、浏览器嗅探、使用兼容性库以及编写跨浏览器的代码，可以解决常见的浏览器 JavaScript 兼容性问题。</p>
<p>以下是对每个兼容性问题的示例代码：</p>
<p><strong>1. 当前样式：</strong></p>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myElement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取当前样式属性值</span>
<span class="token keyword">var</span> currentStyle<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>getComputedStyle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  currentStyle <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">getComputedStyle</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPropertyValue</span><span class="token punctuation">(</span><span class="token string">'color'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">.</span>currentStyle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  currentStyle <span class="token operator">=</span> el<span class="token punctuation">.</span>currentStyle<span class="token punctuation">.</span>color<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>currentStyle<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<p><strong>2. 事件对象：</strong></p>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 处理点击事件</span>
<span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取事件对象</span>
  <span class="token keyword">var</span> event <span class="token operator">=</span> e <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 绑定点击事件</span>
<span class="token keyword">var</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myElement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> handleClick<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>attachEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  element<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">'onclick'</span><span class="token punctuation">,</span> handleClick<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p><strong>3. 鼠标坐标：</strong></p>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 处理鼠标移动事件</span>
<span class="token keyword">function</span> <span class="token function">handleMouseMove</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取鼠标坐标位置</span>
  <span class="token keyword">var</span> mouseX<span class="token punctuation">,</span> mouseY<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>pageX <span class="token operator">||</span> e<span class="token punctuation">.</span>pageY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mouseX <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX<span class="token punctuation">;</span>
    mouseY <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>clientX <span class="token operator">||</span> e<span class="token punctuation">.</span>clientY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mouseX <span class="token operator">=</span> e<span class="token punctuation">.</span>clientX <span class="token operator">+</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollLeft <span class="token operator">+</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollLeft<span class="token punctuation">;</span>
    mouseY <span class="token operator">=</span> e<span class="token punctuation">.</span>clientY <span class="token operator">+</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop <span class="token operator">+</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Mouse position: '</span> <span class="token operator">+</span> mouseX <span class="token operator">+</span> <span class="token string">', '</span> <span class="token operator">+</span> mouseY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 绑定鼠标移动事件</span>
<span class="token keyword">var</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myElement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> handleMouseMove<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>attachEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  element<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">'onmousemove'</span><span class="token punctuation">,</span> handleMouseMove<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p><strong>4. 按键码：</strong></p>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 处理键盘按下事件</span>
<span class="token keyword">function</span> <span class="token function">handleKeyDown</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取按键码</span>
  <span class="token keyword">var</span> keyCode <span class="token operator">=</span> e<span class="token punctuation">.</span>which <span class="token operator">||</span> e<span class="token punctuation">.</span>keyCode<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Key pressed: '</span> <span class="token operator">+</span> keyCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 绑定键盘按下事件</span>
<span class="token keyword">var</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myElement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'keydown'</span><span class="token punctuation">,</span> handleKeyDown<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>attachEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  element<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">'onkeydown'</span><span class="token punctuation">,</span> handleKeyDown<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p><strong>5. 文本节点：</strong></p>
<div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myElement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取元素中的文本内容</span>
<span class="token keyword">var</span> textContent<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'textContent'</span> <span class="token keyword">in</span> el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  textContent <span class="token operator">=</span> el<span class="token punctuation">.</span>textContent<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'innerText'</span> <span class="token keyword">in</span> el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  textContent <span class="token operator">=</span> el<span class="token punctuation">.</span>innerText<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>textContent<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<p>请根据实际情况修改示例代码，并结合特性检测、浏览器嗅探、使用兼容性库以及编写跨浏览器的代码的方法来解决兼容性问题。</p>
<h3 id="_67-请写出多种等高布局"><a href="#_67-请写出多种等高布局" class="header-anchor">#</a> 67 请写出多种等高布局</h3>
<ol><li>使用 JavaScript/jQuery：通过脚本计算元素高度，并将最大高度应用于其他元素。</li> <li>使用伪元素和绝对定位：在容器元素中添加一个伪元素，使用绝对定位将其拉伸到与最高元素相同的高度。</li> <li>使用表格布局：将容器元素设置为<code>display: table</code>，将子元素设置为<code>display: table-cell</code>，然后使用<code>vertical-align: top</code>或其他对齐方式来实现等高效果。</li> <li>使用网格布局（CSS Grid）：使用<code>grid-template-rows</code>属性将所有行设置为相同的高度。</li> <li>使用<code>flexbox</code>嵌套：将容器元素设置为<code>display: flex</code>，然后在每个子元素中再嵌套一个<code>flexbox</code>容器，将子元素的高度设置为<code>100%</code>，从而实现等高布局。</li> <li><code>css3 flexbox</code> 布局： <code>.container{display: flex; align-items: stretch;}</code></li></ol>
<p>需要根据具体情况选择适合的等高布局方法，考虑兼容性、布局需求和代码复杂度等因素。</p>
<h3 id="_68-浮动元素引起的问题"><a href="#_68-浮动元素引起的问题" class="header-anchor">#</a> 68 浮动元素引起的问题</h3>
<p>浮动元素可能引起以下问题：</p>
<ol><li>父元素高度塌陷：当父元素包含了浮动元素时，如果没有清除浮动，父元素的高度将无法被正确计算，导致父元素的高度塌陷，影响页面布局。</li></ol>
<p>解决方法：可以在父元素的末尾添加一个空的块级元素，并设置其清除浮动的属性。例如：</p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent::after</span> <span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>
  <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="2"><li>元素重叠：浮动元素脱离了正常的文档流，可能导致其他元素与其重叠。这通常发生在没有足够空间容纳浮动元素的情况下。</li></ol>
<p>解决方法：可以通过在需要避免重叠的元素上应用<code>clear</code>属性或使用适当的布局技术来解决重叠问题。</p>
<ol start="3"><li>文字环绕：浮动元素会导致周围的文本环绕在其周围，可能影响页面的可读性和布局。</li></ol>
<p>解决方法：可以使用<code>clear</code>属性或使用适当的布局技术来控制浮动元素周围的文本布局，确保页面的可读性和整体布局。</p>
<ol start="4"><li>父元素高度不准确：如果父元素包含浮动元素而没有设置清除浮动，父元素的高度可能不准确，可能会导致布局问题。</li></ol>
<p>解决方法：可以在父元素上应用清除浮动的样式，或使用其他布局技术来解决父元素高度不准确的问题。</p>
<p>总的来说，使用浮动元素时，应注意处理相关的布局问题，避免出现高度塌陷、重叠和布局混乱等问题。可以使用清除浮动、适当的布局技术或其他CSS属性来解决这些问题。</p>
<h3 id="_69-css优化、提高性能的方法有哪些"><a href="#_69-css优化、提高性能的方法有哪些" class="header-anchor">#</a> 69 CSS优化、提高性能的方法有哪些</h3>
<p>以下是一些优化和提高CSS性能的方法：</p>
<ol><li>合并CSS文件：将多个CSS文件合并为一个文件，减少HTTP请求次数。</li> <li>将CSS文件放在页面最上面：确保CSS文件在HTML文件中的头部，以便浏览器尽早加载和渲染样式。</li> <li>移除空的CSS规则：删除不需要的空的CSS规则，减少文件大小。</li> <li>避免使用CSS表达式：CSS表达式在每次页面重绘时都会执行，对性能有一定影响，应避免使用。</li> <li>优化选择器嵌套：避免过深的选择器嵌套，减少选择器的复杂度，以提高选择器匹配速度。</li> <li>最大限度地利用CSS继承：合理利用CSS属性的继承特性，减少重复的代码量。</li> <li>抽象和提取公共样式：将重复的样式抽象出来，提取为公共样式，减少重复的代码量。</li> <li>使用简写属性：合理使用CSS的简写属性，减少代码量，例如使用<code>margin</code>代替<code>margin-top</code>、<code>margin-right</code>等单独属性。</li> <li>避免不必要的浏览器重绘和重排：在进行DOM操作时，尽量减少对页面布局的影响，以避免不必要的浏览器重绘和重排。</li> <li>使用CSS雪碧图：将多个小的图标合并到一个图像文件中，通过CSS的背景定位来显示不同的图标，减少HTTP请求次数。</li> <li>使用压缩和缩小CSS文件：使用CSS压缩工具，将CSS文件进行压缩和缩小，减少文件大小，提高加载速度。</li></ol>
<p>这些方法可以帮助优化和提高CSS性能，减少文件大小和HTTP请求次数，加快页面加载速度，提升用户体验。</p>
<h3 id="_70-浏览器是怎样解析css选择器的"><a href="#_70-浏览器是怎样解析css选择器的" class="header-anchor">#</a> 70 浏览器是怎样解析CSS选择器的</h3>
<p>浏览器解析CSS选择器的过程是从右到左进行的。当浏览器遇到一个CSS规则时，它会从选择器的最右边开始解析，然后逐步向左匹配元素。</p>
<p><strong>具体的解析过程如下：</strong></p>
<ol><li>浏览器从右向左选择器的最右边开始解析，找到与该选择器匹配的元素。</li> <li>然后，浏览器向左继续解析选择器的下一个部分，检查该元素的父元素是否满足选择器的条件。</li> <li>如果满足选择器的条件，则继续向左解析选择器的下一个部分，继续检查父元素的父元素是否满足选择器的条件。</li> <li>浏览器重复这个过程，直到解析完整个选择器或者找不到与选择器匹配的元素。</li></ol>
<p>这种从右到左的解析方式可以提高选择器的性能，特别是在面对复杂的选择器和大量元素的情况下。因为从右到左的解析可以尽早过滤掉不匹配的元素，减少了需要遍历的元素数量，提高了选择器的匹配速度。</p>
<p>需要注意的是，并非所有的CSS选择器都适用于从右到左的解析方式，例如属性选择器、伪类选择器等可能需要从左到右进行解析。浏览器在解析CSS选择器时会根据具体的情况选择最优的解析方式。</p>
<h3 id="_71-在网页中的应该使用奇数还是偶数的字体"><a href="#_71-在网页中的应该使用奇数还是偶数的字体" class="header-anchor">#</a> 71 在网页中的应该使用奇数还是偶数的字体</h3>
<p>在网页中，一般推荐使用偶数号的字体大小。以下是一些原因：</p>
<ol><li><strong>比例关系</strong>：偶数字号相对更容易与网页设计的其他部分形成比例关系，使整个页面看起来更加协调和平衡。</li> <li><strong>对齐</strong>：使用偶数字号字体可以使文本段落对齐更加方便。如果使用奇数字号字体，文本段落的对齐可能会受到影响，因为奇数字号字体的基线位置可能会导致对齐不准确。</li> <li><strong>兼容性</strong>：在某些情况下，奇数字号字体可能在不同浏览器和操作系统中显示不一致。使用偶数字号字体可以减少这种显示差异的可能性。</li></ol>
<p>对于中文网页排版，常用的字体大小是<code>12</code>号和<code>14</code>号。这两个偶数字号字体大小在中文排版中使用较多，可以提供良好的可读性和视觉效果。</p>
<p>需要注意的是，具体选择何种字体大小还要根据设计需求、内容呈现和用户体验等因素进行综合考虑。</p>
<h3 id="_72-margin和padding分别适合什么场景使用"><a href="#_72-margin和padding分别适合什么场景使用" class="header-anchor">#</a> 72 margin和padding分别适合什么场景使用</h3>
<p><code>margin</code> 和 <code>padding</code> 在布局和样式设计中有不同的用途和适用场景。</p>
<p><strong>适合使用 margin 的场景</strong>：</p>
<ul><li>创建元素之间的空白间距，用于调整元素之间的间隔。</li> <li>添加外部空白，使元素与周围的元素或容器之间产生间距。</li> <li>用于调整元素的定位和对齐。</li> <li>用于调整元素的外边距折叠效果（当相邻元素的外边距相遇时）。</li></ul>
<p><strong>适合使用 padding 的场景</strong>：</p>
<ul><li>在元素的内部添加空白区域，用于调整元素内部内容与边框之间的距离。</li> <li>用于创建元素的背景色或背景图的填充区域。</li> <li>用于调整元素的内边距，影响元素内容与边框的距离。</li> <li>用于控制元素的尺寸和布局。</li></ul>
<p>需要根据具体的设计需求和布局目标来决定使用 <code>margin</code> 还是 <code>padding</code>。在一些情况下，它们可以互相替代使用，但在其他情况下，选择正确的属性可以更好地控制布局和样式效果。</p>
<h3 id="_73-抽离样式模块怎么写-说出思路"><a href="#_73-抽离样式模块怎么写-说出思路" class="header-anchor">#</a> 73 抽离样式模块怎么写，说出思路</h3>
<p>抽离样式模块的思路可以按照以下步骤进行：</p>
<ol><li><strong>识别公共样式</strong>：分析页面中多个模块或页面之间共享的样式，例如颜色、字体、按钮样式等，将其提取为公共样式。</li> <li><strong>创建公共样式表</strong>：将公共样式抽离到单独的样式表文件中，例如 <code>common.css</code>，以便在多个页面或模块中引用。</li> <li><strong>定义命名规范</strong>：为业务样式定义统一的命名规范，例如使用 BEM（Block-Element-Modifier）或其他命名约定，确保样式模块的可维护性和可扩展性。</li> <li><strong>拆分业务样式</strong>：根据页面或模块的功能和结构，将样式拆分为多个模块，并命名为相应的类名或选择器。每个模块应只关注自身的样式，并尽量避免与其他模块产生冲突。</li> <li><strong>创建样式模块文件</strong>：为每个样式模块创建单独的样式文件，例如 <code>header.css</code>、<code>sidebar.css</code> 等，并按需引入到页面中。</li> <li><strong>构建样式层级结构</strong>：根据页面或模块的结构和层级关系，合理组织样式文件的引入顺序，确保样式的层叠顺序和继承关系正确。</li> <li><strong>统一管理样式文件</strong>：根据项目需要，可以使用构建工具（如 webpack、gulp 等）进行样式文件的合并、压缩和打包，减少网络请求和提升页面加载速度。</li> <li><strong>维护和更新</strong>：在日常开发中，根据需求的变化和新功能的添加，及时更新和维护样式模块，保持样式的一致性和可复用性。</li></ol>
<p>通过以上步骤，可以将样式按照模块化的方式进行抽离和管理，提高代码的可读性、可维护性和重用性。同时，样式模块的拆分也有助于团队协作和并行开发。</p>
<h3 id="_74-元素竖向的百分比设定是相对于容器的高度吗"><a href="#_74-元素竖向的百分比设定是相对于容器的高度吗" class="header-anchor">#</a> 74 元素竖向的百分比设定是相对于容器的高度吗</h3>
<p>实际上，<code>元素竖向的百分比设定是相对于包含它的父元素的高度，而不是宽度</code>。当给一个元素设置竖向的百分比高度时，它会根据其父元素的高度进行计算。例如，如果一个元素的高度设置为50%，则表示该元素的高度将是其父元素高度的50%。</p>
<p>请注意，如果父元素没有明确设置高度，或者父元素的高度是由其内容决定的（如默认的<code>height: auto</code>），那么百分比高度可能无效，因为无法确定相对的基准高度。</p>
<p>需要注意的是，元素的宽度百分比设定是相对于包含它的父元素的宽度。因此，元素的百分比设定在竖向和横向方向上是不同的。</p>
<h3 id="_75-全屏滚动的原理是什么-用到了css的那些属性"><a href="#_75-全屏滚动的原理是什么-用到了css的那些属性" class="header-anchor">#</a> 75 全屏滚动的原理是什么？ 用到了CSS的那些属性</h3>
<blockquote><p>全屏滚动（Full Page Scroll）的原理是通过设置页面的高度为视口高度，并使用滚动事件来控制页面的滚动效果。通过监听滚动事件，当用户滚动页面时，根据滚动的距离来切换页面的显示内容，实现页面的切换效果。</p></blockquote>
<p>在实现全屏滚动时，可能会用到以下一些CSS属性：</p>
<ul><li><code>overflow: hidden;</code>：用于隐藏超出视口范围的内容，以实现滚动效果。</li> <li><code>transform: translate(100%, 100%);</code>：通过<code>translate</code>属性将页面移动到视口之外，从而隐藏页面的初始位置。</li> <li><code>display: none;</code>：可以将页面的初始状态设置为隐藏，待滚动到相应位置时再显示。</li></ul>
<p>这些属性可以结合使用，根据滚动事件的触发来控制页面的显示和隐藏，从而实现全屏滚动的效果。具体的实现方式可能因应用场景而有所差异。</p>
<h3 id="_76-什么是响应式设计-响应式设计的基本原理是什么-如何兼容低版本的ie"><a href="#_76-什么是响应式设计-响应式设计的基本原理是什么-如何兼容低版本的ie" class="header-anchor">#</a> 76 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE</h3>
<ul><li>响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本</li> <li>基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式</li> <li>对于低版本的IE，可采用JS获取屏幕宽度，然后通过<code>resize</code>方法来实现兼容：</li></ul>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">screenRespond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">screenRespond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">screenRespond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">var</span> screenWidth <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>screenWidth <span class="token operator">&lt;=</span> <span class="token number">1800</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span> <span class="token string">"w1800"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>screenWidth <span class="token operator">&lt;=</span> <span class="token number">1400</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span> <span class="token string">"w1400"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>screenWidth <span class="token operator">&gt;</span> <span class="token number">1800</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h3 id="_77-什么是视差滚动效果-如何给每页做不同的动画"><a href="#_77-什么是视差滚动效果-如何给每页做不同的动画" class="header-anchor">#</a> 77 什么是视差滚动效果，如何给每页做不同的动画</h3>
<p>视差滚动效果是一种在网页中使用的动画效果，通过在滚动页面时，不同层级的元素以不同的速度移动，形成立体的运动效果。这种效果可以给用户带来更加丰富、生动的视觉体验。</p>
<p>实现视差滚动效果时，可以将页面划分为背景层、内容层和悬浮层等不同的层级。通过设置不同层级的元素以不同的速度移动，可以形成层次感和立体效果。</p>
<p><strong>具体实现视差滚动效果的方法如下：</strong></p>
<ol><li>使用HTML和CSS创建页面的不同层级，如背景层、内容层和悬浮层。</li> <li>监听滚动事件（如鼠标滚轮事件或触摸滑动事件）。</li> <li>当滚动事件触发时，根据滚动的距离和速度，计算出不同层级元素的位移值。</li> <li>使用CSS的<code>transform</code>属性或JavaScript的动画库（如GSAP、ScrollMagic等）来实现元素的平移或缩放效果。</li> <li>根据需求，为每个页面或元素设置不同的动画效果，如淡入淡出、旋转、缩放等。</li> <li>根据滚动的进度和方向，控制元素的动画播放顺序和速度，以达到预期的视差滚动效果。</li></ol>
<p>需要注意的是，在实现视差滚动效果时，要考虑到性能和用户体验。过多或复杂的动画效果可能会影响页面加载和滚动的流畅性，因此需要谨慎选择和设计动画效果，并进行性能优化，如合理使用硬件加速、使用节流和防抖等技术手段。</p>
<p>另外，为每个页面或元素设置不同的动画效果可以根据具体的设计需求来确定。可以根据页面的主题、内容或目的来决定使用何种动画效果，如淡入淡出效果、元素的移动或旋转效果等，以增加页面的吸引力和交互性。可以通过CSS的<code>animation</code>属性或JavaScript的动画库来实现这些动画效果，并根据滚动进度或其他触发条件来控制动画的播放。</p>
<p><strong>总结</strong></p>
<ul><li>视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验</li> <li>一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的</li> <li>实现原理
<ul><li>以 “页面滚动条” 作为 “视差动画进度条”</li> <li>以 “滚轮刻度” 当作 “动画帧度” 去播放动画的</li> <li>监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果</li></ul></li></ul>
<h3 id="_78-a标签上四个伪类的执行顺序是怎么样的"><a href="#_78-a标签上四个伪类的执行顺序是怎么样的" class="header-anchor">#</a> 78 a标签上四个伪类的执行顺序是怎么样的</h3>
<p>伪类在<code>a</code>标签上的执行顺序是 <code>link</code>（未访问链接） -&gt; <code>visited</code>（已访问链接） -&gt; <code>hover</code>（鼠标悬停） -&gt; <code>active</code>（激活状态）。</p>
<p>执行顺序可以用记忆口诀 <code>"L-V-H-A"</code>（Love Hate）来记忆，表示喜欢和讨厌的顺序。首先应用 <code>link</code> 样式，然后是 <code>visited</code> 样式，接着是 <code>hover</code> 样式，最后是 <code>active</code> 样式。这个顺序也是 CSS 解析和应用伪类样式的规定顺序。</p>
<h3 id="_79-伪元素和伪类的区别和作用"><a href="#_79-伪元素和伪类的区别和作用" class="header-anchor">#</a> 79 伪元素和伪类的区别和作用</h3>
<ul><li>伪元素 -- 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。</li> <li>它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li></ul>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">p::before</span> <span class="token punctuation">{</span><span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"第一章："</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token selector">p::after</span> <span class="token punctuation">{</span><span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"Hot!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token selector">p::first-line</span> <span class="token punctuation">{</span><span class="token property">background</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token selector">p::first-letter</span> <span class="token punctuation">{</span><span class="token property">font-size</span><span class="token punctuation">:</span>30px<span class="token punctuation">;</span><span class="token punctuation">}</span>

</code></pre></div>
<ul><li>伪类 -- 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li></ul>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">a:hover</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span> #FF00FF<span class="token punctuation">}</span>
<span class="token selector">p:first-child</span> <span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">}</span>
</code></pre></div>
<h3 id="_80-before-和-after-中双冒号和单冒号有什么区别"><a href="#_80-before-和-after-中双冒号和单冒号有什么区别" class="header-anchor">#</a> 80 ::before 和 :after 中双冒号和单冒号有什么区别</h3>
<ul><li>在 CSS 中伪类一直用 <code>:</code> 表示，如 <code>:hover</code>, <code>:active</code> 等</li> <li>伪元素在CSS1中已存在，当时语法是用 <code>:</code> 表示，如 <code>:before</code> 和 <code>:after</code></li> <li>后来在CSS3中修订，伪元素用 <code>::</code> 表示，如 <code>::before</code> 和 <code>::after</code>，以此区分伪元素和伪类</li> <li>由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 <code>:after</code> 这种老语法表示伪元素</li> <li>总结起来，<code>::before</code> 是CSS3中写伪元素的新语法，而 <code>:after</code> 是早期版本CSS中存在的、兼容IE的旧语法，用于表示伪元素。在实际开发中，为了兼容性考虑，可以选择使用单冒号的写法。</li></ul>
<h3 id="_81-如何修改chrome记住密码后自动填充表单的黄色背景"><a href="#_81-如何修改chrome记住密码后自动填充表单的黄色背景" class="header-anchor">#</a> 81 如何修改Chrome记住密码后自动填充表单的黄色背景</h3>
<ul><li>产生原因：由于Chrome默认会给自动填充的<code>input</code>表单加上 <code>input:-webkit-autofill</code> 私有属性造成的</li> <li>解决方案1：在<code>form</code>标签上直接关闭了表单的自动填充：<code>autocomplete="off"</code></li> <li>解决方案2：<code>input:-webkit-autofill { background-color: transparent; }</code></li></ul>
<p><strong>input [type=search] 搜索框右侧小图标如何美化？</strong></p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">input[type="search"]::-webkit-search-cancel-button</span><span class="token punctuation">{</span>
  <span class="token property">-webkit-appearance</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 15px<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 15px<span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> 8px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">"images/searchicon.png"</span><span class="token punctuation">)</span></span> no-repeat 0 0<span class="token punctuation">;</span>
  <span class="token property">background-size</span><span class="token punctuation">:</span> 15px 15px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h3 id="_82-网站图片文件-如何点击下载-而非点击预览"><a href="#_82-网站图片文件-如何点击下载-而非点击预览" class="header-anchor">#</a> 82 网站图片文件，如何点击下载？而非点击预览</h3>
<p>可以通过在 <code>&lt;a&gt;</code> 标签中添加 <code>href</code> 属性来指定图片文件的路径，并使用 <code>download</code> 属性来指示浏览器下载该文件而非预览。</p>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>logo.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">download</span><span class="token punctuation">&gt;</span></span>下载<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<p>上述代码会在网页中显示一个链接，点击该链接会下载名为 <code>logo.jpg</code> 的图片文件。</p>
<p>您还可以通过添加 <code>download</code> 属性的值来指定下载文件的名称，如下所示：</p>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>logo.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">download</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>网站LOGO<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>下载<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<p>上述代码会下载名为 <code>网站LOGO.jpg</code> 的图片文件。</p>
<p>请注意，<code>download</code> 属性在某些浏览器中可能不被支持或具有限制。在不支持该属性的浏览器中，点击链接可能仍然会打开预览。此外，如果您在网站中使用了内容安全策略（Content Security Policy），可能需要额外配置才能允许下载文件。</p>
<p>确保文件路径正确，并根据需要设置适当的下载文件名称。</p>
<h3 id="_83-你对-line-height-是如何理解的"><a href="#_83-你对-line-height-是如何理解的" class="header-anchor">#</a> 83 你对 line-height 是如何理解的</h3>
<ul><li><code>line-height</code> 是一行字的高度，包括了字体的实际高度以及行间距（字间距）。</li> <li>当一个元素没有显式设置 <code>height</code> 属性时，它的高度会由 <code>line-height</code> 决定。</li> <li>如果一个容器没有设置高度，并且容器内部有文本内容，那么容器的高度会由 <code>line-height</code> 撑开。</li> <li>如果将 <code>line-height</code> 设置为与容器的 <code>height</code> 相同的值，可以实现单行文本的垂直居中。</li> <li>注意，<code>line-height</code> 和 <code>height</code> 都可以撑开元素的高度，但是设置 <code>height</code> 属性会触发元素的 <code>haslayout</code>（仅适用于部分浏览器），而 <code>line-height</code> 不会触发该特性。</li></ul>
<p>需要注意的是，<code>line-height</code> 还可以影响多行文本的行间距和垂直居中，它是一个很常用的属性用于调整文本的排版和布局。</p>
<h3 id="_84-line-height-三种赋值方式有何区别-带单位、纯数字、百分比"><a href="#_84-line-height-三种赋值方式有何区别-带单位、纯数字、百分比" class="header-anchor">#</a> 84 line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）</h3>
<p>对于 <code>line-height</code> 的三种赋值方式，如下所述：</p>
<ol><li><strong>带单位</strong>：使用像素 (<code>px</code>) 或其他单位 (如 <code>em</code>) 进行赋值。当使用固定值（如 <code>px</code>）时，<code>line-height</code> 会直接采用该固定值作为行高。而当使用相对单位（如 <code>em</code>）时，<code>line-height</code> 会根据元素的父元素的字体大小 (<code>font-size</code>) 来计算行高，即乘以相应的倍数。</li> <li><strong>纯数字</strong>：直接使用数字进行赋值。这种情况下，数字会被传递给后代元素，作为其行高的比例因子。例如，如果父元素的行高为 <code>1.5</code>，而子元素的字体大小为 <code>18px</code>，那么子元素的行高就会被计算为 <code>1.5 * 18 = 27px</code>。</li> <li><strong>百分比</strong>：使用百分比进行赋值。百分比值会相对于父元素的字体大小进行计算，并将计算后的值传递给后代元素作为其行高。</li></ol>
<p>总的来说，带单位的方式是直接指定具体的行高值，纯数字和百分比的方式会将计算后的行高值传递给后代元素。这些不同的赋值方式可以根据具体的需求和设计效果来选择使用。</p>
<h3 id="_85-设置元素浮动后-该元素的-display-值会如何变化"><a href="#_85-设置元素浮动后-该元素的-display-值会如何变化" class="header-anchor">#</a> 85 设置元素浮动后，该元素的 display 值会如何变化</h3>
<ul><li>设置元素浮动后，元素的 <code>display</code> 值并不会自动变成 <code>block</code>，而是保持原有的 <code>display</code> 值。浮动元素的 <code>display</code> 值仍然是根据元素的默认样式或通过 CSS 显式设置的值。</li> <li>然而，浮动元素会生成一个块级框，并且脱离了正常的文档流，会影响其他元素的布局。常见的浮动值为 <code>left</code> 或 <code>right</code>，使元素向左或向右浮动，并允许其他内容环绕在其周围。</li> <li>需要注意的是，对于一些内联元素，如 <code>span</code>、<code>a</code> 等，默认的 <code>display</code> 值是 <code>inline</code>，当设置这些内联元素为浮动时，会自动转换为 <code>block</code>，但这并不适用于所有元素。</li></ul>
<h3 id="_86-让页面里的字体变清晰-变细用css怎么做-ios手机浏览器字体齿轮设置"><a href="#_86-让页面里的字体变清晰-变细用css怎么做-ios手机浏览器字体齿轮设置" class="header-anchor">#</a> 86 让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）</h3>
<p>通过设置 <code>-webkit-font-smoothing</code> 属性为 <code>antialiased</code> 可以在 iOS 手机浏览器中使字体显示更清晰、更细腻。这个属性是针对 iOS Safari 浏览器的特定设置。</p>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">body</span> <span class="token punctuation">{</span>
  <span class="token property">-webkit-font-smoothing</span><span class="token punctuation">:</span> antialiased<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>将上述代码应用于你的 CSS 文件中，或者将其添加到你想要应用字体设置的元素的样式中，可以改善字体在 iOS 手机浏览器中的显示效果。注意，该属性只在 iOS Safari 浏览器中生效，在其他浏览器中可能没有效果。</p>
<h3 id="_87-font-style-属性-oblique-是什么意思"><a href="#_87-font-style-属性-oblique-是什么意思" class="header-anchor">#</a> 87 font-style 属性 oblique 是什么意思</h3>
<p><code>font-style: oblique;</code> 是用来设置字体样式为倾斜（oblique）的。当字体本身没有提供 <code>italic</code> 斜体样式时，可以使用 <code>oblique</code> 属性来模拟倾斜效果。</p>
<p>倾斜样式是一种字体样式，使字体呈现为向右倾斜的外观，类似于斜体（italic）样式。不同之处在于，斜体样式是由字体设计师提供的专门的斜体字形，而倾斜样式是通过将正常字形倾斜来模拟出来的。</p>
<p>使用 <code>font-style: oblique;</code> 可以在没有专门提供斜体字形的字体上实现倾斜效果，但需要注意的是，由于是通过倾斜正常字形来模拟，所以结果可能不如专门设计的斜体字形效果好。</p>
<h3 id="_88-display-inline-block-什么时候会显示间隙"><a href="#_88-display-inline-block-什么时候会显示间隙" class="header-anchor">#</a> 88 display:inline-block 什么时候会显示间隙</h3>
<p><code>display: inline-block;</code> 可能会在元素之间产生间隙的情况包括：</p>
<ol><li>相邻的 <code>inline-block</code> 元素之间有换行或空格分隔时，会产生间隙。</li> <li>非 <code>inline-block</code> 的水平元素设置为 <code>inline-block</code> 时，会有默认的水平间距。</li> <li>默认情况下，<code>inline-block</code> 元素的默认对齐方式是基线对齐，而不是顶部对齐，因此可能会产生垂直间隙。可以通过设置 <code>vertical-align: top;</code> 将元素顶部对齐来消除垂直间隙。</li> <li>父元素的字体大小会影响 <code>inline-block</code> 元素的间隙。如果父元素设置了字体大小，可以将其设置为 <code>font-size: 0;</code>，然后在 <code>inline-block</code> 元素内部设置所需的字体大小，以消除垂直间隙。</li> <li>将多个 <code>li</code> 标签写在同一行，可以消除垂直间隙，但这会导致代码可读性差。</li></ol>
<p>这些方法可以用来解决 <code>inline-block</code> 元素之间产生的间隙问题。</p>
<h3 id="_89-一个高度自适应的div-里面有两个div-一个高度100px-希望另一个填满剩下的高度"><a href="#_89-一个高度自适应的div-里面有两个div-一个高度100px-希望另一个填满剩下的高度" class="header-anchor">#</a> 89 一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</h3>
<ul><li>方案1：
<ul><li><code>.sub { height: calc(100%-100px); }</code></li></ul></li> <li>方案2：
<ul><li><code>.container { position:relative; }</code></li> <li><code>.sub { position: absolute; top: 100px; bottom: 0; }</code></li></ul></li> <li>方案3：
<ul><li><code>.container { display:flex; flex-direction:column; }</code></li> <li><code>.sub { flex:1; }</code></li></ul></li></ul>
<p>这三种方案都可以实现一个高度自适应的 <code>div</code>，其中一个子 <code>div</code> 高度为 <code>100px</code>，另一个子 <code>div</code> 填满剩下的高度。</p>
<ul><li>方案1使用了 <code>calc()</code> 函数来计算剩余高度，<code>.sub</code> 的高度设置为 <code>calc(100% - 100px)</code>，即剩余高度。</li> <li>方案2使用了相对定位和绝对定位，父容器 <code>.container</code> 设置为相对定位，子 <code>div</code> <code>.sub</code> 设置为绝对定位，设置 <code>top: 100px</code> 让其距离顶部 <code>100px</code>，设置 <code>bottom: 0</code> 让其底部与父容器底部对齐。</li> <li>方案3使用了弹性布局（Flexbox），父容器 <code>.container</code> 设置为 <code>display: flex</code>，并指定 <code>flex-direction: column</code> 使其垂直排列。子 <code>div</code> <code>.sub</code> 使用 <code>flex: 1</code> 来填充剩余的空间，自动调整高度。</li></ul>
<p>这些方案都可以实现相应的效果，具体选择哪种方案取决于实际需求和布局结构。</p>
<h3 id="_90-css-的渲染层合成是什么-浏览器如何创建新的渲染层"><a href="#_90-css-的渲染层合成是什么-浏览器如何创建新的渲染层" class="header-anchor">#</a> 90 css 的渲染层合成是什么 浏览器如何创建新的渲染层</h3>
<blockquote><p>在 DOM 树中每个节点都会对应一个渲染对象（<code>RenderObject），当它们的渲染对象处于相同的坐标空间（z 轴空间）时，就会形成一个 RenderLayers，也就是渲染层。渲染层将保证页面元素以正确的顺序堆叠，这时候就会出现层合成（</code>composite`），从而正确处理透明元素和重叠元素的显示。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常</p></blockquote>
<p>在 CSS 中，渲染层合成（Layer Composition）是浏览器中用于处理页面元素的显示和堆叠顺序的机制。它通过创建新的渲染层（Render Layer）来管理页面中的元素，并确保它们以正确的顺序进行渲染和呈现。</p>
<p><strong>浏览器创建新的渲染层的条件包括但不限于以下情况：</strong></p>
<ol><li><strong>定位属性</strong>：元素具有 <code>position: fixed</code>、<code>position: relative</code>、<code>position: sticky</code>、<code>position: absolute</code> 等定位属性时，会创建新的渲染层。</li> <li><strong>透明度和混合模式</strong>：元素的透明度设置小于 1（<code>opacity: 0.5</code>）或具有非 <code>normal</code> 的混合模式（<code>mix-blend-mode: multiply</code>）时，会创建新的渲染层。</li> <li><strong>3D 变换</strong>：元素具有 3D 变换（<code>transform: translateZ(0)</code>）时，会创建新的渲染层。</li> <li><strong>滤镜效果</strong>：元素应用了滤镜效果（<code>filter: blur(5px)</code>）时，会创建新的渲染层。</li> <li><strong>遮罩效果</strong>：元素应用了遮罩效果（<code>mask-image: url(mask.png)</code>）时，会创建新的渲染层。</li> <li><strong>CSS 动画</strong>：元素正在进行 CSS 动画（<code>animation</code>、<code>transition</code>）时，会创建新的渲染层。</li> <li><strong>其他因素</strong>：还有一些其他因素，如元素应用了 <code>backface-visibility: hidden</code>、<code>column-count</code> 不为 <code>auto</code> 等，也可能触发创建新的渲染层。</li></ol>
<p>创建新的渲染层有助于确保页面元素以正确的顺序进行堆叠和渲染，并处理透明元素和重叠元素的显示。这对于具有位置重叠的页面元素尤为重要，因为合成层的顺序错误可能导致元素显示异常。通过创建新的渲染层，浏览器可以更好地管理元素的渲染和呈现，提高页面的性能和用户体验。</p>
</div>