<!-- Section: # 一、HTML、HTTP、WEB综合问题 -->
<div class="section-content" data-section-id="一、html、http、web综合问题">
<h2 id="一、html、http、web综合问题"><a href="#一、html、http、web综合问题" class="header-anchor">#</a> 一、HTML、HTTP、WEB综合问题</h2>
<h3 id="_1-前端需要注意哪些seo"><a href="#_1-前端需要注意哪些seo" class="header-anchor">#</a> 1 前端需要注意哪些SEO</h3>
<ul><li>合理的<code>title</code>、<code>description</code>、<code>keywords</code>：搜索引擎对这些标签的权重逐渐减小。在<code>title</code>中，强调重点即可，重要关键词不要超过2次，并且要靠前。每个页面的<code>title</code>应该有所不同。<code>description</code>应该高度概括页面内容，长度适当，避免过度堆砌关键词。每个页面的<code>description</code>也应该有所不同。<code>keywords</code>标签应列举出重要关键词即可。
<ul><li>针对<code>title</code>标签，可以使用重要关键词、品牌词或描述页面内容的短语。确保标题简洁、准确地概括页面的主题，并吸引用户点击。</li> <li>在编写<code>description</code>标签时，应尽量使用简洁、具有吸引力的语句来概括页面的内容，吸引用户点击搜索结果。避免堆砌关键词，以自然流畅的方式描述页面</li> <li><code>keywords</code>标签已经不再是搜索引擎排名的重要因素，但仍然可以列举出与页面内容相关的几个重要关键词，以便搜索引擎了解页面的主题。</li></ul></li> <li>语义化的<code>HTML</code>代码，符合W3C规范：使用语义化的HTML代码可以让搜索引擎更容易理解网页的结构和内容。遵循W3C规范可以提高网页的可读性和可访问性，对SEO也有好处。</li> <li>重要内容<code>HTML</code>代码放在最前：搜索引擎抓取HTML的顺序是从上到下，有些搜索引擎对抓取长度有限制。因此，将重要的内容放在<code>HTML</code>的前面，确保重要内容一定会被抓取。</li> <li>重要内容不要用<code>js</code>输出：爬虫不会执行<code>JavaScript</code>，所以重要的内容不应该依赖于通过<code>JavaScript</code>动态生成。确保重要内容在<code>HTML</code>中静态存在。</li> <li>少用<code>iframe</code>：搜索引擎通常不会抓取<code>iframe</code>中的内容，因此应该尽量减少<code>iframe</code>的使用，特别是对于重要的内容。</li> <li>非装饰性图片必须加<code>alt</code>：为非装饰性图片添加<code>alt</code>属性，可以为搜索引擎提供关于图片内容的描述，同时也有助于可访问性。</li> <li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ul>
<h3 id="_2-img-的title和alt有什么区别"><a href="#_2-img-的title和alt有什么区别" class="header-anchor">#</a> 2 <code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>有什么区别</h3>
<ul><li><p><code>title</code>属性：<code>title</code>属性是HTML元素通用的属性，适用于各种元素，不仅仅是<code>&lt;img&gt;</code>标签。当鼠标滑动到元素上时，浏览器会显示<code>title</code>属性的内容，提供额外的信息或解释，帮助用户了解元素的用途或含义。对于<code>&lt;img&gt;</code>标签，鼠标悬停在图片上时会显示<code>title</code>属性的内容。</p></li> <li><p><code>alt</code>属性：<code>alt</code>属性是<code>&lt;img&gt;</code>标签的特有属性，用于提供图片的替代文本描述。当图片无法加载时，浏览器会显示<code>alt</code>属性的内容，或者在可访问性场景中，读屏器会读取<code>alt</code>属性的内容。<code>alt</code>属性的主要目的是提高图片的可访问性，使无法查看图片的用户也能了解图片的内容或含义。除了纯装饰性图片外，所有<code>&lt;img&gt;</code>标签都应该设置有意义的<code>alt</code>属性值。</p></li> <li><p><strong>补充答案：</strong></p> <ul><li><code>title</code>属性主要用于提供额外的信息或提示，是对图片的补充描述，可以用于提供更详细的说明，如图片的来源、作者、相关信息等。它不是必需的，但可以增强用户体验，特别是在需要显示更多信息时。</li> <li><code>alt</code>属性是图片内容的等价描述，应该简洁明了地描述图片所表达的信息。它对于可访问性至关重要，确保无障碍用户能够理解图片的含义，同时也是搜索引擎重点分析的内容。在设置<code>alt</code>属性时，应该避免过度堆砌关键词，而是提供准确、有意义的描述。</li></ul></li></ul>
<h3 id="_3-http的几种请求方法用途"><a href="#_3-http的几种请求方法用途" class="header-anchor">#</a> 3 HTTP的几种请求方法用途</h3>
<ul><li><code>GET</code>方法：
<ul><li>用途：发送一个请求来获取服务器上的某一资源。</li> <li>面试可能涉及的问题：
<ol><li>GET方法的特点是什么？
<ul><li>GET方法是HTTP的一种请求方法，用于从服务器获取资源。</li> <li>它是一种幂等的方法，多次发送相同的GET请求会返回相同的结果。</li></ul></li> <li>GET请求和POST请求的区别是什么？
<ul><li>GET请求将参数附加在URL的查询字符串中，而POST请求将参数放在请求体中。</li> <li>GET请求的数据会显示在URL中，而POST请求的数据不会显示在URL中。</li> <li>GET请求一般用于获取数据，而POST请求一般用于提交数据。</li></ul></li> <li>GET请求可以有请求体吗？
<ul><li>根据HTTP规范，GET请求不应该有请求体，参数应该通过URL的查询字符串传递。</li></ul></li> <li>GET请求的参数如何传递？
<ul><li>GET请求的参数可以通过URL的查询字符串传递，例如：<code>/api/users?id=123&amp;name=poetry</code>。</li></ul></li> <li>GET请求的安全性和幂等性如何保证？
<ul><li>GET请求不会对服务器端的资源产生副作用，因此被视为安全的。</li> <li>GET请求是幂等的，多次发送相同的GET请求不会对服务器端产生影响。</li></ul></li></ol></li></ul></li> <li><code>POST</code>方法：
<ul><li>用途：向<code>URL</code>指定的资源提交数据或附加新的数据。</li> <li>面试可能涉及的问题：
<ol><li>POST方法的特点是什么？
<ul><li>POST方法是HTTP的一种请求方法，用于向服务器提交数据。</li> <li>它不是幂等的，多次发送相同的POST请求可能会产生不同的结果。</li></ul></li> <li>POST请求和GET请求的区别是什么？
<ul><li>POST请求将参数放在请求体中，而GET请求将参数附加在URL的查询字符串中。</li> <li>POST请求的数据不会显示在URL中，而GET请求的数据会显示在URL中。</li> <li>POST请求一般用于提交数据，而GET请求一般用于获取数据。</li></ul></li> <li>POST请求的请求体如何传递数据？
<ul><li>POST请求的数据可以通过请求体以表单形式传递，或者以JSON等格式传递。</li></ul></li> <li>POST请求的安全性和幂等性如何保证？
<ul><li>POST请求可能对服务器端的资源产生副作用，因此被视为不安全的。</li> <li>POST请求不是幂等的，多次发送相同的POST请求可能会对服务器端产生影响。</li></ul></li></ol></li></ul></li> <li>PUT方法：
<ul><li>用途：将数据发送给服务器，并将其存储在指定的URL位置。与POST方法不同的是，PUT方法指定了资源在服务器上的位置。</li> <li>面试可能涉及的问题：
<ul><li>PUT方法的特点是什么？
<ul><li>PUT方法是HTTP的一种请求方法，用于将数据发送给服务器并存储在指定的URL位置。</li> <li>它是一种幂等的方法，多次发送相同的PUT请求会对服务器端产生相同的结果。</li></ul></li> <li>PUT请求和POST请求有什么区别？
<ul><li>PUT请求用于指定资源在服务器上的位置，而POST请求没有指定位置。</li> <li>PUT请求一般用于更新或替换资源，而POST请求一般用于新增资源或提交数据。</li></ul></li> <li>PUT请求的幂等性如何保证？
<ul><li>PUT请求的幂等性保证是由服务器端实现的。</li> <li>服务器端应该根据请求中的资源位置来处理请求，多次发送相同的PUT请求会对该位置上的资源进行相同的更新或替换操作。</li></ul></li></ul></li></ul></li> <li><code>HEAD</code>方法
<ul><li>只请求页面的首部</li></ul></li> <li><code>DELETE</code>方法
<ul><li>删除服务器上的某资源</li></ul></li> <li><code>OPTIONS</code>方法
<ul><li>它用于获取当前<code>URL</code>所支持的方法。如果请求成功，会有一个<code>Allow</code>的头包含类似<code>“GET,POST”</code>这样的信息</li></ul></li> <li><code>TRACE</code>方法
<ul><li><code>TRACE</code>方法被用于激发一个远程的，应用层的请求消息回路</li></ul></li> <li><code>CONNECT</code>方法
<ul><li>把请求连接转换到透明的<code>TCP/IP</code>通道</li></ul></li></ul>
<h3 id="_4-从浏览器地址栏输入url到显示页面的步骤"><a href="#_4-从浏览器地址栏输入url到显示页面的步骤" class="header-anchor">#</a> 4 从浏览器地址栏输入url到显示页面的步骤</h3>
<p><strong>基础版本</strong></p>
<ul><li>浏览器根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；</li> <li>服务器交给后台处理完成后返回数据，浏览器接收文件（<code>HTML、JS、CSS</code>、图象等）；</li> <li>浏览器对加载到的资源（<code>HTML、JS、CSS</code>等）进行语法解析，建立相应的内部数据结构（如<code>HTML</code>的<code>DOM</code>）；</li> <li>载入解析到的资源文件，渲染页面，完成。</li></ul>
<p><strong>详细版</strong></p>
<ol><li>在浏览器地址栏输入URL</li> <li>浏览器查看<strong>缓存</strong>，如果请求资源在缓存中并且新鲜，跳转到转码步骤
<ol><li>如果资源未缓存，发起新请求</li> <li>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</li> <li>检验新鲜通常有两个HTTP头进行控制<code>Expires</code>和<code>Cache-Control</code>：
<ul><li>HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期</li> <li>HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li></ul></li></ol></li> <li>浏览器<strong>解析URL</strong>获取协议，主机，端口，path</li> <li>浏览器<strong>组装一个HTTP（GET）请求报文</strong></li> <li>浏览器<strong>获取主机ip地址</strong>，过程如下：
<ol><li>浏览器缓存</li> <li>本机缓存</li> <li>hosts文件</li> <li>路由器缓存</li> <li>ISP DNS缓存</li> <li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li></ol></li> <li><strong>打开一个socket与目标IP地址，端口建立TCP链接</strong>，三次握手如下：
<ol><li>客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端口</li> <li>服务器发回<strong>SYN=1， ACK=X+1， Seq=Y</strong>的响应包</li> <li>客户端发送<strong>ACK=Y+1， Seq=Z</strong></li></ol></li> <li>TCP链接建立后<strong>发送HTTP请求</strong></li> <li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</li> <li>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</li> <li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</li> <li>服务器将<strong>响应报文通过TCP连接发送回浏览器</strong></li> <li>浏览器接收HTTP响应，然后根据情况选择<strong>关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下</strong>：
<ol><li>主动方发送<strong>Fin=1， Ack=Z， Seq= X</strong>报文</li> <li>被动方发送<strong>ACK=X+1， Seq=Z</strong>报文</li> <li>被动方发送<strong>Fin=1， ACK=X， Seq=Y</strong>报文</li> <li>主动方发送<strong>ACK=Y， Seq=X</strong>报文</li></ol></li> <li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</li> <li>如果资源可缓存，<strong>进行缓存</strong></li> <li>对响应进行<strong>解码</strong>（例如gzip压缩）</li> <li>根据资源类型决定如何处理（假设资源为HTML文档）</li> <li><strong>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</li> <li><strong>构建DOM树</strong>：
<ol><li><strong>Tokenizing</strong>：根据HTML规范将字符流解析为标记</li> <li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li> <li><strong>DOM construction</strong>：根据HTML标记关系将对象组成DOM树</li></ol></li> <li>解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></li> <li>构建<strong>CSSOM树</strong>：
<ol><li><strong>Tokenizing</strong>：字符流转换为标记流</li> <li><strong>Node</strong>：根据标记创建节点</li> <li><strong>CSSOM</strong>：节点创建CSSOM树</li></ol></li> <li><strong><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" target="_blank" rel="noopener noreferrer">根据DOM树和CSSOM树构建渲染树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong>:
<ol><li>从DOM树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：1）<code>script</code>,<code>meta</code>这样本身不可见的标签。2)被css隐藏的节点，如<code>display: none</code></li> <li>对每一个可见节点，找到恰当的CSSOM规则并应用</li> <li>发布可视节点的内容和计算样式</li></ol></li> <li><strong>js解析如下</strong>：
<ol><li>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate为loading</strong></li> <li>HTML解析器遇到<strong>没有async和defer的script时</strong>，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</strong></li> <li>当解析器遇到设置了<strong>async</strong>属性的script时，开始下载脚本并继续解析文档。脚本会在它<strong>下载完成后尽快执行</strong>，但是<strong>解析器不会停下来等它下载</strong>。异步脚本<strong>禁止使用document.write()</strong>，它们可以访问自己script和之前的文档元素</li> <li>当文档完成解析，document.readState变成interactive</li> <li>所有<strong>defer</strong>脚本会<strong>按照在文档出现的顺序执行</strong>，延迟脚本<strong>能访问完整文档树</strong>，禁止使用document.write()</li> <li>浏览器<strong>在Document对象上触发DOMContentLoaded事件</strong></li> <li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成载入和执行</strong>，document.readState变为complete，window触发load事件</li></ol></li> <li><strong>显示页面</strong>（HTML解析过程中会逐步显示页面）</li></ol>
<p><strong>详细简版</strong></p>
<ol><li>从浏览器接收<code>url</code>到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</li> <li>开启网络线程到发出一个完整的<code>HTTP</code>请求（这一部分涉及到dns查询，<code>TCP/IP</code>请求，五层因特网协议栈等知识）</li> <li>从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</li> <li>后台和前台的<code>HTTP</code>交互（这一部分包括<code>HTTP</code>头部、响应码、报文结构、<code>cookie</code>等知识，可以提下静态资源的<code>cookie</code>优化，以及编码解码，如<code>gzip</code>压缩等）</li> <li>单独拎出来的缓存问题，<code>HTTP</code>的缓存（这部分包括http缓存头部，<code>ETag</code>，<code>catch-control</code>等）</li> <li>浏览器接收到<code>HTTP</code>数据包后的解析流程（解析<code>html</code>-词法分析然后解析成<code>dom</code>树、解析<code>css</code>生成<code>css</code>规则树、合并成<code>render</code>树，然后<code>layout</code>、<code>painting</code>渲染、复合图层的合成、<code>GPU</code>绘制、外链资源的处理、<code>loaded</code>和<code>DOMContentLoaded</code>等）</li> <li><code>CSS</code>的可视化格式模型（元素的渲染规则，如包含块，控制框，<code>BFC</code>，<code>IFC</code>等概念）</li> <li><code>JS</code>引擎解析过程（<code>JS</code>的解释阶段，预处理阶段，执行阶段生成执行上下文，<code>VO</code>，作用域链、回收机制等等）</li> <li>其它（可以拓展不同的知识模块，如跨域，web安全，<code>hybrid</code>模式等等内容）</li></ol>
<h3 id="_5-如何进行网站性能优化"><a href="#_5-如何进行网站性能优化" class="header-anchor">#</a> 5 如何进行网站性能优化</h3>
<ul><li><code>content</code>方面
<ul><li>减少<code>HTTP</code>请求：合并文件、<code>CSS</code>精灵、<code>inline Image</code></li> <li>减少<code>DNS</code>查询：<code>DNS</code>缓存、将资源分布到恰当数量的主机名</li> <li>减少<code>DOM</code>元素数量</li></ul></li> <li><code>Server</code>方面
<ul><li>使用<code>CDN</code></li> <li>配置<code>ETag</code></li> <li>对组件使用<code>Gzip</code>压缩</li></ul></li> <li><code>Cookie</code>方面
<ul><li>减小<code>cookie</code>大小</li></ul></li> <li><code>css</code>方面
<ul><li>将样式表放到页面顶部</li> <li>不使用<code>CSS</code>表达式</li> <li>使用<code>&lt;link&gt;</code>不使用<code>@import</code></li></ul></li> <li><code>Javascript</code>方面
<ul><li>将脚本放到页面底部</li> <li>将<code>javascript</code>和<code>css</code>从外部引入</li> <li>压缩<code>javascript</code>和<code>css</code></li> <li>删除不需要的脚本</li> <li>减少<code>DOM</code>访问</li></ul></li> <li>图片方面
<ul><li>优化图片：根据实际颜色需要选择色深、压缩</li> <li>优化<code>css</code>精灵</li> <li>不要在<code>HTML</code>中拉伸图片</li></ul></li></ul>
<p><strong>你有用过哪些前端性能优化的方法？</strong></p>
<ul><li>减少<code>http</code>请求次数：<code>CSS Sprites</code>, <code>JS</code>、<code>CSS</code>源码压缩、图片大小控制合适；网页<code>Gzip</code>，<code>CDN</code>托管，<code>data</code>缓存 ，图片服务器。</li> <li>前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存<code>AJAX</code>请求结果，每次操作本地变量，不用请求，减少请求次数</li> <li>用<code>innerHTML</code>代替DOM操作，减少DOM操作次数，优化javascript性能。</li> <li>当需要设置的样式很多时设置<code>className</code>而不是直接操作<code>style</code></li> <li>少用全局变量、缓存DOM节点查找的结果。减少IO读取操作</li> <li>避免使用<code>CSS Expression</code>（css表达式)又称<code>Dynamic properties</code>(动态属性)</li> <li>图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳</li> <li>避免在页面的主体布局中使用<code>table</code>，<code>table</code>要等其中的内容完全下载之后才会显示出来，显示比<code>div+css</code>布局慢</li></ul>
<p><strong>谈谈性能优化问题</strong></p>
<ul><li>代码层面：避免使用<code>css</code>表达式，避免使用高级选择器，通配选择器</li> <li>缓存利用：缓存<code>Ajax</code>，使用<code>CDN</code>，使用外部<code>js</code>和<code>css</code>文件以便缓存，添加<code>Expires</code>头，服务端配置<code>Etag</code>，减少<code>DNS</code>查找等</li> <li>请求数量：合并样式和脚本，使用<code>css</code>图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载</li> <li>请求带宽：压缩文件，开启<code>GZIP</code></li></ul>
<p><strong>前端性能优化最佳实践？</strong></p>
<ul><li>性能评级工具（<code>PageSpeed</code> 或 <code>YSlow</code>）</li> <li>合理设置 <code>HTTP</code> 缓存：<code>Expires</code> 与 <code>Cache-control</code></li> <li>静态资源打包，开启 Gzip 压缩（节省响应流量）</li> <li><code>CSS3</code> 模拟图像，图标<code>base64</code>（降低请求数）</li> <li>模块延迟(defer)加载/异步(<code>async</code>)加载</li> <li><code>Cookie</code> 隔离（节省请求流量）</li> <li><code>localStorage</code>（本地存储）</li> <li>使用 <code>CDN</code> 加速（访问最近服务器）</li> <li>启用 <code>HTTP/2</code>（多路复用，并行加载）</li> <li>前端自动化（<code>gulp/webpack</code>）</li></ul>
<h3 id="_6-http状态码及其含义"><a href="#_6-http状态码及其含义" class="header-anchor">#</a> 6 HTTP状态码及其含义</h3>
<ul><li><code>1XX</code>：信息状态码
<ul><li><code>100 Continue</code>   继续，一般在发送<code>post</code>请求时，已发送了<code>http header</code>之后服务端将返回此信息，表示确认，之后发送具体参数信息</li></ul></li> <li><code>2XX</code>：成功状态码
<ul><li><code>200 OK</code>         正常返回信息</li> <li><code>201 Created</code>   请求成功并且服务器创建了新的资源</li> <li><code>202 Accepted</code>   服务器已接受请求，但尚未处理</li></ul></li> <li><code>3XX</code>：重定向
<ul><li><code>301 Moved Permanently</code>  请求的网页已永久移动到新位置。</li> <li><code>302 Found</code>     临时性重定向。</li> <li><code>303 See Other</code>  临时性重定向，且总是使用 <code>GET</code> 请求新的 <code>URI</code>。</li> <li><code>304 Not Modified</code> 自从上次请求后，请求的网页未修改过。</li></ul></li> <li><code>4XX</code>：客户端错误
<ul><li><code>400 Bad Request</code> 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li> <li><code>401 Unauthorized</code> 请求未授权。</li> <li><code>403 Forbidden</code>  禁止访问。</li> <li><code>404 Not Found</code>   找不到如何与 <code>URI</code> 相匹配的资源。</li></ul></li> <li><code>5XX:</code> 服务器错误
<ul><li><code>500 Internal Server Error</code>  最常见的服务器端错误。</li> <li><code>503 Service Unavailable</code> 服务器端暂时无法处理请求（可能是过载或维护）</li></ul></li></ul>
<h3 id="_7-语义化的理解"><a href="#_7-语义化的理解" class="header-anchor">#</a> 7 语义化的理解</h3>
<blockquote><p>语义化是指在编写HTML和CSS代码时，通过恰当的选择标签和属性，使得代码更具有语义性和可读性，使得页面结构和内容更加清晰明了。语义化的目的是让页面具备良好的可访问性、可维护性和可扩展性。</p></blockquote>
<p><strong>语义化的重要性体现在以下几个方面：</strong></p>
<ol><li><strong>可访问性（Accessibility）</strong>：通过使用恰当的标签和属性，可以提高页面的可访问性，使得辅助技术（如屏幕阅读器）能够更好地理解和解析页面内容，使得残障用户能够正常浏览和使用网页。</li> <li><strong>搜索引擎优化（SEO）</strong>：搜索引擎更喜欢能够理解和解析的页面内容，语义化的HTML结构可以提高页面在搜索引擎结果中的排名，增加网页的曝光和访问量。</li> <li><strong>代码可读性和可维护性</strong>：使用语义化的标签和属性，可以让代码更易于阅读和理解，提高代码的可维护性。开发人员可以更快速地定位和修改特定功能或内容。</li> <li><strong>设备兼容性</strong>：不同设备和平台对于网页的渲染和解析方式有所不同，语义化的代码可以增加网页在各种设备上的兼容性，确保页面在不同环境中的正确显示和使用。</li></ol>
<p><strong>语义化在前端开发中的具体表现和实践包括以下几个方面：</strong></p>
<ol><li><strong>选择合适的HTML标签</strong>：在构建页面结构时，选择恰当的HTML标签来描述内容的含义。例如，使用<code>&lt;header&gt;</code>表示页面的页眉，<code>&lt;nav&gt;</code>表示导航栏，<code>&lt;article&gt;</code>表示独立的文章内容等。</li> <li><strong>使用有意义的标签和属性</strong>：避免滥用<code>&lt;div&gt;</code>标签，而是选择更具语义的标签来表达内容的含义。同时，合理使用标签的属性，如<code>alt</code>属性用于图像的替代文本，<code>title</code>属性用于提供额外的信息等。</li> <li><strong>结构和层次化</strong>：通过正确嵌套和组织HTML元素，构建清晰的页面结构和层次关系。使用语义化的父子关系，让内容的层级关系更加明确，便于样式和脚本的编写和维护。</li> <li><strong>文本格式化</strong>：使用合适的标签和属性来标记文本的格式和语义。例如，使用<code>&lt;strong&gt;</code>标签表示重要文本，<code>&lt;em&gt;</code>标签表示强调文本，<code>&lt;blockquote&gt;</code>标签表示引用文本等。</li> <li><strong>无障碍支持</strong>：考虑到残障用户的需求，使用语义化的标签和属性可以提高页面的可访问性。例如，为表格添加适当的表头和描述信息，为表单元素关联标签等。</li> <li><strong>CSS选择器的语义化</strong>：在编写CSS样式时，尽量使用具有语义的类名和ID，避免过于依赖元素标签选择器，以增强样式的可读性和可维护性。</li></ol>
<p>通过遵循语义化的原则，我们能够构建出更具有可读性、可访问性和可维护性的前端代码，提高用户体验和开发效率。同时，也能够使网页在不同的环境和设备上保持一致的表现，增强网站的可持续性和可扩展性。</p>
<p><strong>总结</strong></p>
<ul><li>用正确的标签做正确的事情！</li> <li><code>HTML</code>语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；</li> <li>在没有样式<code>CSS</code>情况下也以一种文档格式显示，并且是容易阅读的。</li> <li>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 <code>SEO</code>。</li> <li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解</li></ul>
<h3 id="_8-介绍一下你对浏览器内核的理解"><a href="#_8-介绍一下你对浏览器内核的理解" class="header-anchor">#</a> 8 介绍一下你对浏览器内核的理解？</h3>
<p>浏览器内核是浏览器的核心组成部分，主要分为两个部分：渲染引擎（也称为布局引擎或渲染引擎）和 JavaScript 引擎。</p>
<ul><li>渲染引擎：渲染引擎负责解析网页的 HTML、XML、图像等内容，并将其转换为可视化的网页形式展示给用户。它负责处理网页的布局、样式计算、绘制等任务。不同浏览器的内核对网页的解释和渲染方式可能会有差异，因此不同浏览器的渲染效果也会有所不同。常见的渲染引擎包括：
<ul><li><code>WebKit</code>：主要用于 Safari 和 Chrome 浏览器。</li> <li><code>Gecko</code>：主要用于 Firefox 浏览器。</li> <li><code>Trident</code>：主要用于旧版本的 Internet Explorer 浏览器。</li> <li><code>Blink</code>：基于 WebKit，用于 Chrome、Opera 和部分 Chromium 浏览器。</li></ul></li> <li>JavaScript 引擎：JavaScript 引擎负责解析和执行网页中的 JavaScript 代码，实现网页的动态交互和功能。不同浏览器的 JavaScript 引擎性能和特性也可能存在差异。常见的 JavaScript 引擎包括：
<ul><li><code>V8</code>：用于 Chrome 和 <code>Opera</code> 浏览器，具有高性能和快速执行速度。</li> <li><code>SpiderMonkey</code>：用于 <code>Firefox</code> 浏览器。</li> <li><code>JavaScriptCore</code>：用于 <code>Safari</code> 浏览器。</li></ul></li></ul>
<blockquote><ul><li>在早期，渲染引擎和 JavaScript 引擎没有明确的分离，它们在同一个内核中工作。随着时间的推移，JavaScript 引擎逐渐独立出来，使内核更专注于页面渲染和布局方面的任务。</li> <li>理解浏览器内核对于前端开发人员非常重要，因为不同的内核可能会对网页的解释和渲染产生影响，从而影响页面的布局、样式和交互效果。在开发过程中，需要考虑不同浏览器内核的差异，并进行兼容性测试和优化，以确保网页在不同浏览器上都能正确显示和运行。</li></ul></blockquote>
<h3 id="_9-html5有哪些新特性、移除了那些元素"><a href="#_9-html5有哪些新特性、移除了那些元素" class="header-anchor">#</a> 9 html5有哪些新特性、移除了那些元素？</h3>
<ul><li><code>HTML5</code> 现在已经不是 <code>SGML</code> 的子集，主要是关于图像，位置，存储，多任务等功能的增加
<ul><li>新增选择器 <code>document.querySelector</code>、<code>document.querySelectorAll</code></li> <li>拖拽释放(<code>Drag and drop</code>) API</li> <li>媒体播放的 <code>video</code> 和 <code>audio</code></li> <li>本地存储 <code>localStorage</code> 和 <code>sessionStorage</code></li> <li>离线应用 <code>manifest</code></li> <li>桌面通知 <code>Notifications</code></li> <li>语意化标签 <code>article</code>、<code>footer</code>、<code>header</code>、<code>nav</code>、<code>section</code></li> <li>增强表单控件 <code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code></li> <li>地理位置 <code>Geolocation</code></li> <li>多任务 <code>webworker</code></li> <li>全双工通信协议 <code>websocket</code></li> <li>历史管理 <code>history</code></li> <li>跨域资源共享(CORS) <code>Access-Control-Allow-Origin</code></li> <li>页面可见性改变事件 <code>visibilitychange</code></li> <li>跨窗口通信 <code>PostMessage</code></li> <li><code>Form Data</code> 对象</li> <li>绘画 <code>canvas</code></li></ul></li> <li>移除的元素：
<ul><li>纯表现的元素：<code>basefont</code>、<code>big</code>、<code>center</code>、<code>font</code>、 <code>s</code>、<code>strike</code>、<code>tt</code>、<code>u</code></li> <li>对可用性产生负面影响的元素：<code>frame</code>、<code>frameset</code>、<code>noframes</code></li></ul></li> <li>支持<code>HTML5</code>新标签：
<ul><li><code>IE8/IE7/IE6</code>支持通过<code>document.createElement</code>方法产生的标签</li> <li>可以利用这一特性让这些浏览器支持<code>HTML5</code>新标签</li> <li>浏览器支持新标签后，还需要添加标签默认的样式</li></ul></li> <li>当然也可以直接使用成熟的框架、比如<code>html5shim</code></li></ul>
<p><strong>如何区分 HTML 和 HTML5</strong></p>
<ul><li><code>DOCTYPE</code>声明、新增的结构元素、功能元素</li></ul>
<h3 id="_10-html5的离线储存怎么使用-工作原理能不能解释一下"><a href="#_10-html5的离线储存怎么使用-工作原理能不能解释一下" class="header-anchor">#</a> 10 <code>HTML5</code>的离线储存怎么使用，工作原理能不能解释一下？</h3>
<ul><li>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件</li> <li>原理：<code>HTML5</code>的离线存储是基于一个新建的<code>.appcache</code>文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像<code>cookie</code>一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</li> <li>如何使用：
<ul><li>页面头部像下面一样加入一个<code>manifest</code>的属性；</li> <li>在<code>cache.manifest</code>文件的编写离线存储的资源</li> <li>在离线状态时，操作<code>window.applicationCache</code>进行需求实现</li></ul></li></ul>
<div class="language-json extra-class"><pre class="language-json"><code>CACHE MANIFEST
#v0.<span class="token number">11</span>
CACHE<span class="token operator">:</span>
js/app.js
css/style.css
NETWORK<span class="token operator">:</span>
resourse/logo.png
FALLBACK<span class="token operator">:</span>
/offline.html
</code></pre></div>
<h3 id="_11-浏览器是怎么对html5的离线储存资源进行管理和加载的呢"><a href="#_11-浏览器是怎么对html5的离线储存资源进行管理和加载的呢" class="header-anchor">#</a> 11 浏览器是怎么对<code>HTML5</code>的离线储存资源进行管理和加载的呢</h3>
<ul><li>在线的情况下，浏览器发现<code>html</code>头部有<code>manifest</code>属性，它会请求<code>manifest</code>文件，如果是第一次访问<code>app</code>，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过<code>app</code>并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的<code>manifest</code>文件与旧的<code>manifest</code>文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</li> <li>离线的情况下，浏览器就直接使用离线存储的资源。</li></ul>
<h3 id="_12-请描述一下-cookies-sessionstorage-和-localstorage-的区别"><a href="#_12-请描述一下-cookies-sessionstorage-和-localstorage-的区别" class="header-anchor">#</a> 12 请描述一下 <code>cookies</code>，<code>sessionStorage</code> 和 <code>localStorage</code> 的区别？</h3>
<blockquote><p><code>cookies</code>、<code>sessionStorage</code> 和 <code>localStorage</code> 都是在 Web 开发中用于在客户端存储数据的技术，但它们在以下方面存在区别：</p></blockquote>
<p><strong>存储容量</strong></p>
<ul><li><code>cookies</code>：通常存储容量较小，一般限制在4KB左右。</li> <li><code>sessionStorage</code>：存储容量比 <code>cookies</code> 大，不同浏览器的限制有所不同，但一般可以存储5MB或更多的数据。</li> <li><code>localStorage</code>：存储容量也较大，通常和 <code>sessionStorage</code> 相近，能满足大多数 Web 应用的存储需求。</li></ul>
<p><strong>数据有效期</strong></p>
<ul><li><code>cookies</code>：可以设置过期时间，若不设置，默认在浏览器关闭时失效。如果设置了过期时间，那么在过期时间之前，<code>cookies</code> 会一直存在于客户端，即使浏览器关闭后重新打开也依然有效。</li> <li><code>sessionStorage</code>：数据仅在当前会话期间有效，当浏览器窗口关闭时，<code>sessionStorage</code> 中的数据会被自动清除。</li> <li><code>localStorage</code>：数据没有自动过期时间，除非主动删除，否则数据会一直保存在客户端，即使浏览器关闭、电脑重启，数据依然存在。</li></ul>
<p><strong>作用域</strong></p>
<ul><li><code>cookies</code>：在同域名下的不同页面之间可以共享，但如果设置了 <code>Path</code> 属性，那么只有在指定路径下的页面才能访问该 <code>cookie</code>。此外，<code>cookies</code> 还可以通过设置 <code>Domain</code> 属性在不同子域名之间共享。</li> <li><code>sessionStorage</code>：具有严格的页面级作用域，即只有在同一个浏览器窗口（或标签页）中打开的页面才能共享 <code>sessionStorage</code> 中的数据。不同浏览器窗口或标签页之间无法访问彼此的 <code>sessionStorage</code> 数据，即使它们来自同一个域名。</li> <li><code>localStorage</code>：在同域名下的所有页面都可以共享 <code>localStorage</code> 中的数据，只要是在同一个浏览器中访问该域名，无论在哪个页面存储的数据，其他页面都可以读取和修改。</li></ul>
<p><strong>与服务器的交互</strong></p>
<ul><li><code>cookies</code>：每次向服务器发送请求时，浏览器会自动将同域名下的 <code>cookies</code> 发送到服务器，这可能会增加不必要的网络传输开销，尤其是当 <code>cookies</code> 数据量较大时。</li> <li><code>sessionStorage</code> 和 <code>localStorage</code>：数据仅存储在客户端，不会自动发送到服务器。如果需要与服务器进行数据交互，需要通过 Ajax 等方式手动将数据发送到服务器。</li></ul>
<p><strong>应用场景</strong></p>
<ul><li><code>cookies</code>：常用于存储用户登录状态、购物车信息、用户偏好设置等。由于其会在每次请求时发送到服务器，所以也可以用于在客户端和服务器之间传递一些少量的必要信息。</li> <li><code>sessionStorage</code>：适合存储一些临时数据，例如在一个多步骤的表单填写过程中，存储用户在当前页面填写的数据，当用户完成整个流程或关闭页面时，这些数据就不再需要了。</li> <li><code>localStorage</code>：用于长期存储用户相关的数据，如用户的配置信息、离线缓存数据等。例如，一个 Web 应用可以将一些常用的静态资源存储在 <code>localStorage</code> 中，以便在离线状态下仍然能够访问应用的部分功能。</li></ul>
<h3 id="_13-iframe有那些缺点"><a href="#_13-iframe有那些缺点" class="header-anchor">#</a> 13 iframe有那些缺点？</h3>
<p><code>iframe</code>是一种在网页中嵌入其他网页或文档的标签，虽然它在某些情况下可以提供一些便利，但也存在一些缺点需要考虑：</p>
<ul><li>阻塞主页面的 <code>onload</code> 事件：当页面中存在 <code>iframe</code> 时，<code>iframe</code> 的加载会阻塞主页面的 <code>onload</code> 事件触发。这可能会导致页面加载速度变慢，影响用户体验。</li> <li>不利于 <code>SEO</code>：搜索引擎的爬虫程序通常不能很好地解读 <code>iframe</code> 内部的内容。因此，如果重要的页面内容被放置在 <code>iframe</code> 中，搜索引擎可能无法正确地索引和收录这些内容，从而影响网页的搜索引擎优化（SEO）。</li> <li>连接限制和并行加载：<code>iframe</code> 和主页面共享连接池，而大多数浏览器对相同域的连接数有限制。这意味着当页面中包含多个 <code>iframe</code> 时，浏览器需要同时处理这些连接，可能会影响页面的并行加载能力，导致页面加载速度变慢。</li></ul>
<p><strong>为了避免以上问题，可以考虑以下解决方案：</strong></p>
<ul><li>尽量避免使用 <code>iframe</code>，特别是在主要内容部分。</li> <li>如果必须使用 <code>iframe</code>，可以通过 <code>JavaScript</code> 动态地给 <code>iframe</code> 添加 <code>src</code> 属性值，而不是在静态 <code>HTML</code> 中指定。这样可以绕开阻塞主页面的 <code>onload</code> 事件。
对于需要被搜索引擎索引的重要内容，避免将其放置在 <code>iframe</code> 中。</li> <li>考虑使用其他替代方案，如 <code>AJAX</code> 加载内容或使用现代的前端框架来实现类似的效果。</li> <li>总之，<code>iframe</code> 在某些场景下可以提供方便，但在使用时需要注意其缺点，并根据具体情况进行权衡和选择。</li></ul>
<h3 id="_14-web标准以及w3c标准是什么"><a href="#_14-web标准以及w3c标准是什么" class="header-anchor">#</a> 14 WEB标准以及W3C标准是什么?</h3>
<p>WEB标准是指由万维网联盟（World Wide Web Consortium，简称W3C）制定的一系列技术规范和指南，旨在确保网页在不同的浏览器和设备上具有一致的表现和行为。这些标准涵盖了HTML、CSS、JavaScript等前端技术，并规定了它们的语法、结构、样式以及交互行为等方面的规范。</p>
<p>W3C标准是由W3C组织制定和推广的一系列技术标准，旨在推动网络技术的发展和互操作性。W3C是一个国际性的标准化组织，由互联网行业的各大公司、研究机构和个人组成，致力于制定并推广互联网的开放标准。W3C标准包括HTML、CSS、XML、DOM、SVG等多个技术领域，并且不断更新和演进，以适应新的需求和技术发展。</p>
<p><strong>具体来说，WEB标准和W3C标准强调以下几个方面：</strong></p>
<ul><li><strong>标签闭合</strong>：HTML标签必须按照规定的格式正确闭合，以确保页面结构的准确性和一致性。</li> <li><strong>标签小写</strong>：HTML标签和属性应该使用小写字母，以避免浏览器解析错误。</li> <li><strong>不乱嵌套</strong>：HTML标签应该按照正确的嵌套规则进行使用，不应该出现乱七八糟的嵌套结构，以确保页面结构的清晰和可维护性。</li> <li><strong>使用外链CSS和JS</strong>：将CSS样式和JavaScript代码尽可能地放在外部文件中，并通过链接的方式引入，以实现结构、行为和表现的分离，提高代码的可重用性和可维护性。</li></ul>
<p>通过遵循这些标准和规范，开发人员可以编写出更加规范、可靠和跨平台的网页，确保网页在不同的浏览器和设备上得到一致的显示和行为，提供更好的用户体验。此外，遵循WEB标准和W3C标准还有助于网页的可访问性、可维护性和可扩展性，同时推动互联网技术的进步和发展。</p>
<h3 id="_15-xhtml和html有什么区别"><a href="#_15-xhtml和html有什么区别" class="header-anchor">#</a> 15 xhtml和html有什么区别?</h3>
<ul><li>一个是功能上的差别
<ul><li>主要是<code>XHTML</code>可兼容各大浏览器、手机以及<code>PDA</code>，并且浏览器也能快速正确地编译网页</li></ul></li> <li>另外是书写习惯的差别
<ul><li><code>XHTML</code> 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素</li></ul></li></ul>
<h3 id="_16-doctype作用-严格模式与混杂模式如何区分-它们有何意义"><a href="#_16-doctype作用-严格模式与混杂模式如何区分-它们有何意义" class="header-anchor">#</a> 16 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h3>
<ul><li><code>DOCTYPE</code>（文档类型声明）的作用是告知浏览器的解析器使用哪种<code>HTML</code>或<code>XHTML</code>规范来解析文档。</li> <li>严格模式（标准模式）是指浏览器按照<code>HTML</code>或<code>XHTML</code>的规范严格解析和渲染页面，以确保页面在不同浏览器中具有一致的展示效果和行为。在严格模式下，浏览器会按照规范要求的方式处理<code>HTML</code>和<code>CSS</code>代码。</li> <li>混杂模式（怪异模式或兼容模式）是指浏览器使用较宽松的解析方式来渲染页面，以模拟旧式浏览器的行为，以保证旧版网站的兼容性。在混杂模式下，浏览器可能会容忍一些不符合规范的<code>HTML</code>和CSS`代码，导致页面展示和行为在不同浏览器中有差异。</li> <li>通过<code>DOCTYPE</code>声明的类型来区分严格模式和混杂模式。当<code>DOCTYPE</code>声明为严格的<code>HTML</code>或<code>XHTML</code>规范时，浏览器会进入严格模式；当<code>DOCTYPE</code>声明缺失或格式不正确时，浏览器会进入混杂模式。</li> <li>严格模式和混杂模式的意义在于确保页面在不同浏览器中的一致性和兼容性。严格模式使开发者能够使用更规范的<code>HTML</code>和<code>CSS</code>代码，减少兼容性问题，提高网页的可靠性和可维护性。混杂模式则用于支持旧版网站，以确保这些网站在新版浏览器中能够正确显示和运行。</li></ul>
<h3 id="_17-行内元素有哪些-块级元素有哪些-空-void-元素有那些-行内元素和块级元素有什么区别"><a href="#_17-行内元素有哪些-块级元素有哪些-空-void-元素有那些-行内元素和块级元素有什么区别" class="header-anchor">#</a> 17 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？</h3>
<ul><li>行内元素有：<code>a</code> <code>b</code> <code>span</code> <code>img</code> <code>input</code> <code>select</code> <code>strong</code>等。</li> <li>块级元素有：<code>div</code> <code>ul</code> <code>ol</code> <code>li</code> <code>dl</code> <code>dt</code> <code>dd</code> <code>h1</code> <code>h2</code> <code>h3</code> <code>h4</code>等标题标签、<code>p</code> 段落标签等。</li> <li>空元素（void元素）是指没有内容的HTML元素。常见的空元素包括：<code>&lt;br&gt;</code> 换行元素、<code>&lt;hr&gt;</code> 水平线元素、<code>&lt;img&gt;</code> 图片元素、<code>&lt;input&gt;</code> 输入框元素、<code>&lt;link&gt;</code> 样式表引用元素、<code>&lt;meta&gt;</code> 元数据元素等。</li> <li>行内元素不可以设置宽高，不独占一行，它们会按照从左到右的顺序排列，并尽可能占据内容所需的空间。</li> <li>块级元素可以设置宽高，独占一行，会自动换行。块级元素会在页面上以独立的块形式展现，并占据其父元素的整个宽度。</li></ul>
<p>请注意，这是以Markdown源文件格式输出的回答，不会解析Markdown内容。</p>
<h3 id="_18-html全局属性-global-attribute-有哪些"><a href="#_18-html全局属性-global-attribute-有哪些" class="header-anchor">#</a> 18 HTML全局属性(global attribute)有哪些</h3>
<ul><li><code>class</code>:为元素设置类标识</li> <li><code>data-*</code>: 为元素增加自定义属性</li> <li><code>draggable</code>: 设置元素是否可拖拽</li> <li><code>id</code>: 元素<code>id</code>，文档内唯一</li> <li><code>lang</code>: 元素内容的的语言</li> <li><code>style</code>: 行内<code>css</code>样式</li> <li><code>title</code>: 元素相关的建议信息</li></ul>
<h3 id="_19-canvas和svg有什么区别"><a href="#_19-canvas和svg有什么区别" class="header-anchor">#</a> 19 Canvas和SVG有什么区别？</h3>
<blockquote><ul><li><code>svg</code>绘制出来的每一个图形的元素都是独立的<code>DOM</code>节点，能够方便的绑定事件或用来修改。<code>canvas</code>输出的是一整幅画布</li> <li><code>svg</code>输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而<code>canvas</code>输出标量画布，就像一张图片一样，放大会失真或者锯齿</li></ul></blockquote>
<p>你对Canvas和SVG的区别的描述是正确的。以下是对Canvas和SVG的更详细解释：</p>
<p><strong>Canvas：</strong></p>
<ul><li>Canvas 是一个HTML5元素，用于在网页上绘制图形、动画和图像。</li> <li>通过使用JavaScript绘制图形，Canvas提供了一个像素级的绘图环境。</li> <li>Canvas 绘制的是位图，它是由一系列的像素组成的，所以在放大时会出现像素失真或锯齿效应。</li> <li>Canvas 不会保留绘图的对象，绘制完成后，图形将被保存为一张图片。</li> <li>由于绘制是基于像素的，Canvas 更适合处理像素级的图像处理、游戏开发等场景。</li> <li>Canvas 不支持事件绑定，需要通过监听鼠标、键盘等事件来实现交互。</li></ul>
<p><strong>SVG：</strong></p>
<ul><li>SVG 是一种基于XML的矢量图形格式，用于在网页上绘制图形和图像。</li> <li>SVG 使用XML描述图形，它由一系列的矢量对象组成，可以方便地修改和操作。</li> <li>SVG 绘制的是矢量图形，它基于数学描述，可以自由缩放和变换而不会失真或产生锯齿效应。</li> <li>SVG 保留了绘图的对象，可以对其进行修改、删除和动态操作。</li> <li>由于是矢量图形，SVG 更适合处理图表、数据可视化和可缩放的图形场景。</li> <li>SVG 支持事件绑定，可以方便地为图形元素添加交互行为。</li></ul>
<blockquote><p>综上所述，Canvas适用于像素级绘图和动画，而SVG适用于矢量图形和可缩放的图像。选择使用Canvas还是SVG取决于具体的需求和场景。</p></blockquote>
<h3 id="_20-html5-为什么只需要写-doctype-html"><a href="#_20-html5-为什么只需要写-doctype-html" class="header-anchor">#</a> 20 HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code></h3>
<blockquote><ul><li><code>HTML5</code> 不基于 <code>SGML</code>，因此不需要对<code>DTD</code>进行引用，但是需要<code>doctype</code>来规范浏览器的行为</li> <li>而<code>HTML4.01</code>基于<code>SGML</code>,所以需要对<code>DTD</code>进行引用，才能告知浏览器文档所使用的文档类型</li></ul></blockquote>
<p>下面是对此进行更详细的解释：</p>
<ul><li>在 HTML5 中，不再基于 SGML（Standard Generalized Markup Language）标准，而是定义了自己的独立规范。由于不再使用 SGML，因此不需要引用外部的 DTD（文档类型定义）来验证文档的结构和规则。</li> <li>因此，HTML5 只需要简单地使用 <code>&lt;!DOCTYPE HTML&gt;</code> 声明，它是一个标准模式的声明，告诉浏览器当前文档遵循的是 HTML5 规范。这样，浏览器就可以根据 HTML5 规范来解析和渲染文档，而无需引用外部的 DTD。</li> <li>相比之下，HTML4.01 基于 SGML 标准，需要通过 <code>&lt;!DOCTYPE&gt;</code> 声明来指定所使用的 DTD，例如 <code>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</code>。这个 DTD 提供了规范的文档结构和规则，以确保浏览器正确解析和显示文档。</li> <li>HTML5 的简化 <code>&lt;!DOCTYPE HTML&gt;</code> 声明的设计，使得创建和编写 HTML 文档更加简单和直观。此外，这也有助于提高浏览器的兼容性，因为所有的浏览器都会将文档解析为 HTML5，无需根据 DTD 进行选择和适配。</li> <li>总结起来，HTML5 不再依赖 SGML，因此不需要引用外部 DTD，只需使用简单的 <code>&lt;!DOCTYPE HTML&gt;</code> 声明来指定文档类型，规范浏览器的行为。</li></ul>
<h3 id="_21-如何在页面上实现一个圆形的可点击区域"><a href="#_21-如何在页面上实现一个圆形的可点击区域" class="header-anchor">#</a> 21 如何在页面上实现一个圆形的可点击区域？</h3>
<p>有几种方法可以实现一个圆形的可点击区域：</p>
<ol><li>使用 SVG（可缩放矢量图形）：可以使用 SVG 元素 <code>&lt;circle&gt;</code> 创建一个圆形，并通过添加事件监听器实现点击功能。</li></ol>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>circle</span> <span class="token attr-name">cx</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span> <span class="token attr-name">cy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span> <span class="token attr-name">r</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>circle</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<ol start="2"><li>使用 CSS <code>border-radius</code>：通过设置一个具有相等宽度和高度的元素，并将 border-radius 属性设置为 50% 可以创建一个圆形区域</li></ol>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>circle<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.circle</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<ol start="3"><li>使用纯 JavaScript 实现：通过计算鼠标点击的坐标与圆心的距离，判断点击位置是否在圆形区域内。</li></ol>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>circle<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">#circle</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> circle <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"circle"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> circleRect <span class="token operator">=</span> circle<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> circleCenterX <span class="token operator">=</span> circleRect<span class="token punctuation">.</span>left <span class="token operator">+</span> circleRect<span class="token punctuation">.</span>width <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> circleCenterY <span class="token operator">=</span> circleRect<span class="token punctuation">.</span>top <span class="token operator">+</span> circleRect<span class="token punctuation">.</span>height <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> clickX <span class="token operator">=</span> event<span class="token punctuation">.</span>clientX<span class="token punctuation">;</span>
  <span class="token keyword">var</span> clickY <span class="token operator">=</span> event<span class="token punctuation">.</span>clientY<span class="token punctuation">;</span>
  <span class="token keyword">var</span> distance <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>
    Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>clickX <span class="token operator">-</span> circleCenterX<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>clickY <span class="token operator">-</span> circleCenterY<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>distance <span class="token operator">&lt;=</span> circleRect<span class="token punctuation">.</span>width <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 点击在圆形区域内</span>
    <span class="token comment">// 执行相应操作</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h3 id="_22-网页验证码是干嘛的-是为了解决什么安全问题"><a href="#_22-网页验证码是干嘛的-是为了解决什么安全问题" class="header-anchor">#</a> 22 网页验证码是干嘛的，是为了解决什么安全问题</h3>
<p>网页验证码（CAPTCHA）的作用是用于区分用户是计算机还是人的公共全自动程序。它主要解决以下安全问题：</p>
<ol><li><strong>防止恶意破解</strong>：通过要求用户输入验证码，可以防止恶意用户使用自动化程序（如暴力破解工具）对密码、账号进行不断的尝试，提高系统的安全性。</li> <li><strong>防止刷票和论坛灌水</strong>：验证码可以阻止自动化程序大规模注册账号、刷票或在论坛上进行大量无意义的发帖，保护网站资源免受滥用。</li></ol>
<p>通过要求用户正确地输入验证码，可以验证用户的身份，确保其为真实的人类用户，而不是自动化程序或恶意攻击者。验证码通常会显示一张包含随机字符、数字或图形的图片，用户需要根据图片中的内容进行识别并输入正确的答案。</p>
<p>这样，网页验证码有效地提高了网站和应用程序的安全性，防止了各种恶意行为的发生。</p>
<h3 id="_23-viewport"><a href="#_23-viewport" class="header-anchor">#</a> 23 viewport</h3>
<div class="language-javascript extra-class"><pre class="language-javascript"><code> <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token comment">// width    设置viewport宽度，为一个正整数，或字符串‘device-width’</span>
  <span class="token comment">// device-width  设备宽度</span>
  <span class="token comment">// height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置</span>
  <span class="token comment">// initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数</span>
  <span class="token comment">// minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数</span>
  <span class="token comment">// maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数</span>
  <span class="token comment">// user-scalable    是否允许手动缩放</span>
</code></pre></div>
<ul><li>延伸提问
<ul><li>怎样处理 移动端 <code>1px</code> 被 渲染成 <code>2px</code>问题？</li></ul></li></ul>
<p><strong>局部处理</strong></p>
<ul><li><code>meta</code>标签中的 <code>viewport</code>属性 ，<code>initial-scale</code> 设置为 <code>1</code></li> <li><code>rem</code>按照设计稿标准走，外加利用<code>transform</code> 的<code>scale(0.5)</code> 缩小一倍即可；</li></ul>
<p><strong>全局处理</strong></p>
<ul><li><code>mata</code>标签中的 <code>viewport</code>属性 ，<code>initial-scale</code> 设置为 <code>0.5</code></li> <li><code>rem</code> 按照设计稿标准走即可</li></ul>
<h3 id="_24-渲染优化"><a href="#_24-渲染优化" class="header-anchor">#</a> 24 渲染优化</h3>
<ul><li>禁止使用<code>iframe</code>（阻塞父文档<code>onload</code>事件）
<ul><li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li> <li>搜索引擎的检索程序无法解读这种页面，不利于SEO</li> <li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li> <li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code></li> <li>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li></ul></li> <li>禁止使用<code>gif</code>图片实现<code>loading</code>效果（降低<code>CPU</code>消耗，提升渲染性能）</li> <li>使用<code>CSS3</code>代码代替<code>JS</code>动画（尽可能避免重绘重排以及回流）</li> <li>对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费<code>CPU</code> <ul><li>小图标优势在于
<ul><li>减少<code>HTTP</code>请求</li> <li>避免文件跨域</li> <li>修改及时生效</li></ul></li></ul></li> <li>页面头部的<code>&lt;style&gt;&lt;/style&gt;</code> <code>&lt;script&gt;&lt;/script&gt;</code> 会阻塞页面；（因为 <code>Renderer</code>进程中 <code>JS</code>线程和渲染线程是互斥的）</li> <li>页面中空的 <code>href</code> 和 <code>src</code> 会阻塞页面其他资源的加载 (阻塞下载进程)</li> <li>网页<code>gzip</code>，<code>CDN</code>托管，<code>data</code>缓存 ，图片服务器</li> <li>前端模板 JS+数据，减少由于<code>HTML</code>标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</li> <li>用<code>innerHTML</code>代替<code>DOM</code>操作，减少<code>DOM</code>操作次数，优化<code>javascript</code>性能</li> <li>当需要设置的样式很多时设置<code>className</code>而不是直接操作<code>style</code></li> <li>少用全局变量、缓存<code>DOM</code>节点查找的结果。减少<code>IO</code>读取操作</li> <li>图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳</li> <li>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘<code>IO</code></li></ul>
<h3 id="_25-meta-viewport相关"><a href="#_25-meta-viewport相关" class="header-anchor">#</a> 25 meta viewport相关</h3>
<div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!--H5标准声明，使用 HTML5 doctype，不区分大小写--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”en”</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--标准的 lang 属性写法--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>’utf-8′</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--声明文档使用的字符编码--&gt;</span>
&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt;   <span class="token comment">&lt;!--优先使用 IE 最新版本和 Chrome--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”description”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”不超过150个字符”/</span><span class="token punctuation">&gt;</span></span>       <span class="token comment">&lt;!--页面描述--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”keywords”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>””/</span><span class="token punctuation">&gt;</span></span>     <span class="token comment">&lt;!-- 页面关键词--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”author”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”name,</span> <span class="token attr-name">email@gmail.com”</span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--网页作者--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”robots”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”index,follow”/</span><span class="token punctuation">&gt;</span></span>      <span class="token comment">&lt;!--搜索引擎抓取--&gt;</span>
&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”&gt; <span class="token comment">&lt;!--为移动设备添加 viewport--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”apple-mobile-web-app-title”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”标题”</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!--iOS 设备 begin--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”apple-mobile-web-app-capable”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”yes”/</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!--添加到主屏后的标题（iOS 6 新增）
是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--&gt;</span>
&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”&gt;
<span class="token comment">&lt;!--添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”apple-mobile-web-app-status-bar-style”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”black”/</span><span class="token punctuation">&gt;</span></span>
&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt;  <span class="token comment">&lt;!--设置苹果工具栏颜色--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”renderer”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”webkit”</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 启用360浏览器的极速模式(webkit)--&gt;</span>
&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt;     <span class="token comment">&lt;!--避免IE使用兼容模式--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”Cache-Control”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”no-siteapp”</span> <span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--不让百度转码--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”HandheldFriendly”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”true”</span><span class="token punctuation">&gt;</span></span>     <span class="token comment">&lt;!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”MobileOptimized”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”320″</span><span class="token punctuation">&gt;</span></span>   <span class="token comment">&lt;!--微软的老式浏览器--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”screen-orientation”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”portrait”</span><span class="token punctuation">&gt;</span></span>   <span class="token comment">&lt;!--uc强制竖屏--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”x5-orientation”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”portrait”</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--QQ强制竖屏--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”full-screen”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”yes”</span><span class="token punctuation">&gt;</span></span>              <span class="token comment">&lt;!--UC强制全屏--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”x5-fullscreen”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”true”</span><span class="token punctuation">&gt;</span></span>       <span class="token comment">&lt;!--QQ强制全屏--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”browsermode”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”application”</span><span class="token punctuation">&gt;</span></span>   <span class="token comment">&lt;!--UC应用模式--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”x5-page-mode”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”app”</span><span class="token punctuation">&gt;</span></span>   <span class="token comment">&lt;!-- QQ应用模式--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”msapplication-tap-highlight”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”no”</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--windows phone 点击无高亮
设置页面不缓存--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”pragma”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”no-cache”</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”cache-control”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”no-cache”</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”expires”</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”0″</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>
<h3 id="_26-你做的页面在哪些流览器测试过-这些浏览器的内核分别是什么"><a href="#_26-你做的页面在哪些流览器测试过-这些浏览器的内核分别是什么" class="header-anchor">#</a> 26 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?</h3>
<ul><li><code>IE</code> 使用的是 <code>Trident</code> 内核。</li> <li><code>Firefox</code> 使用的是 <code>Gecko</code> 内核。</li> <li><code>Safari</code> 使用的是 <code>WebKit</code> 内核。</li> <li><code>Opera</code> 在过去使用的是 <code>Presto</code> 内核，但现在已经改用了与 <code>Google Chrome</code> 相同的 <code>Blink</code> 内核。</li> <li><code>Chrome</code> 使用的是基于 <code>WebKit</code> 开发的 <code>Blink</code> 内核。</li></ul>
<p>这些浏览器内核的不同决定了它们在渲染网页时的行为和特性支持。在开发和测试网页时，通常需要在不同的浏览器上进行测试，以确保网页在不同内核的浏览器上都能正确显示和运行。</p>
<h3 id="_27-div-css的布局较table布局有什么优点"><a href="#_27-div-css的布局较table布局有什么优点" class="header-anchor">#</a> 27 div+css的布局较table布局有什么优点？</h3>
<ul><li>改版的时候更方便 只要改<code>css</code>文件。</li> <li>页面加载速度更快、结构化清晰、页面显示简洁。</li> <li>表现与结构相分离。</li> <li>易于优化（<code>seo</code>）搜索引擎更友好，排名更容易靠前。</li></ul>
<h3 id="_28-a-img的alt与title有何异同-b-strong与em的异同"><a href="#_28-a-img的alt与title有何异同-b-strong与em的异同" class="header-anchor">#</a> 28 a：img的alt与title有何异同？b：strong与em的异同？</h3>
<ul><li><code>alt(alt text)</code>: 用于为不能显示图像、窗体或<code>applets</code>的用户代理（<code>UA</code>）提供替代文字。它由<code>lang</code>属性指定替代文字的语言。在某些浏览器中，当没有<code>title</code>属性时，会将<code>alt</code>属性作为工具提示（<code>tooltip</code>）显示。</li> <li><code>title(tool tip)</code>: 用于为元素提供额外的提示信息，当鼠标悬停在元素上时显示。它提供了一种向用户解释元素用途或提供有关元素的补充信息的方式。</li></ul>
<p><strong>b：strong与em的异同？</strong></p>
<ul><li><code>strong</code>: 是表示文本的重要性或紧急性的标签，通常呈现为加粗的文本样式。它用于强调内容的重要性，可以为内容赋予更大的权重。</li> <li><code>em</code>: 是表示文本的强调或重要性的标签，通常呈现为斜体的文本样式。它用于更强烈地强调内容，使其在阅读时更具有突出性，但并不改变内容的含义。</li></ul>
<p>注意：<code>strong</code>和<code>em</code>都是语义化标签，用于表示文本的语义和重要性，而不仅仅是样式上的改变。</p>
<h3 id="_29-你能描述一下渐进增强和优雅降级之间的不同吗"><a href="#_29-你能描述一下渐进增强和优雅降级之间的不同吗" class="header-anchor">#</a> 29 你能描述一下渐进增强和优雅降级之间的不同吗</h3>
<ul><li>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li> <li>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li></ul>
<blockquote><p>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p></blockquote>
<h3 id="_30-为什么利用多个域名来存储网站资源会更有效"><a href="#_30-为什么利用多个域名来存储网站资源会更有效" class="header-anchor">#</a> 30 为什么利用多个域名来存储网站资源会更有效？</h3>
<p>利用多个域名来存储网站资源可以带来以下好处：</p>
<ul><li><strong>CDN缓存更方便</strong>：内容分发网络（CDN）可以更轻松地缓存和分发位于不同域名下的资源，提高资源的访问速度和可用性。</li> <li><strong>突破浏览器并发限制</strong>：大多数浏览器对同一域名下的并发请求数量有限制，通过将资源分布在多个域名下，可以突破这一限制，同时发送更多的并发请求，加快页面加载速度。</li> <li><strong>节约cookie带宽</strong>：浏览器在每个请求中都会携带相应域名下的cookie信息，通过将资源分布在不同的域名下，可以减少对cookie的传输，节约带宽和提高性能。</li> <li><strong>节约主域名的连接数</strong>：浏览器对同一域名下的连接数也有限制，通过将资源请求分散到多个域名下，可以减少对主域名的连接数占用，提高页面的响应速度和并发处理能力。</li> <li><strong>防止不必要的安全问题</strong>：将静态资源与主要网站内容分离到不同的域名下，可以降低恶意攻击者利用资源加载过程中的安全漏洞对主站点进行攻击的风险。</li></ul>
<p>综上所述，通过利用多个域名来存储网站资源，可以提升网站的性能、安全性和用户体验。</p>
<h3 id="_31-简述一下src与href的区别"><a href="#_31-简述一下src与href的区别" class="header-anchor">#</a> 31 简述一下src与href的区别</h3>
<p><code>src</code>和<code>href</code>是HTML中两个常见的属性，它们有以下区别：</p>
<ul><li><code>src</code>属性（source）用于指定要嵌入到当前文档中的外部资源的位置。例如，<code>&lt;script src="script.js"&gt;&lt;/script&gt;</code>用于引入一个外部的JavaScript文件，或者<code>&lt;img src="image.jpg" alt="Image"&gt;</code>用于显示一个外部的图像文件。浏览器在解析到带有<code>src</code>属性的元素时，会暂停当前文档的加载和解析，去下载并执行或显示指定的资源。</li> <li><code>href</code>属性（hypertext reference）用于建立当前文档和引用资源之间的关联。它通常用于链接到其他文档或外部资源，例如<code>&lt;a href="https://www.example.com"&gt;Link&lt;/a&gt;</code>用于创建一个指向外部网页的链接，或者<code>&lt;link href="styles.css" rel="stylesheet"&gt;</code>用于引入外部的CSS样式表。浏览器在解析到带有<code>href</code>属性的元素时，会同时进行当前文档和引用资源的加载和处理，而不会阻塞当前文档的解析。</li></ul>
<p><strong>总结来说：</strong></p>
<ul><li><code>src</code>用于替换当前元素，指向的资源会嵌入到文档中，例如脚本、图像、框架等。</li> <li><code>href</code>用于建立文档与引用资源之间的链接，例如链接到其他文档或引入外部样式表。</li></ul>
<p>注意：尽管它们的用途不同，但在实际使用时，需要根据元素的类型和需求正确地选择使用<code>src</code>或<code>href</code>属性。</p>
<h3 id="_32-知道的网页制作会用到的图片格式有哪些"><a href="#_32-知道的网页制作会用到的图片格式有哪些" class="header-anchor">#</a> 32 知道的网页制作会用到的图片格式有哪些？</h3>
<p>在网页制作中，常用的图片格式包括：</p>
<ul><li><strong>JPEG</strong>（Joint Photographic Experts Group）：适用于存储照片和复杂的图像，具有较高的压缩比，但会有一定的图像质量损失。</li> <li><strong>PNG</strong>（Portable Network Graphics）：适用于图标、透明背景的图像以及需要保留较高图像质量的场景。可以选择使用<code>PNG-8</code>或<code>PNG-24</code>，前者支持最多<code>256</code>种颜色，后者支持更多颜色但文件体积更大。</li> <li><strong>GIF</strong>（Graphics Interchange Format）：适用于简单动画和图标，支持透明背景和基本的透明度。</li> <li><strong>SVG</strong>（Scalable Vector Graphics）：矢量图形格式，使用XML描述图形，具有无损缩放和可编辑性。</li></ul>
<p>除了上述常见的图片格式，还有一些新兴的图片格式：</p>
<ul><li><strong>WebP</strong>：由Google开发的一种旨在提高图片加载速度的格式，具有较高的压缩率和图像质量，逐渐被主流浏览器支持。</li> <li><strong>APNG</strong>（Animated Portable Network Graphics）：是PNG的位图动画扩展，支持帧动画效果，但浏览器兼容性较差。</li></ul>
<p>请注意，选择合适的图片格式应根据具体需求，如图像内容、透明度要求、动画效果等。新的图片格式如WebP和APNG可以根据项目需求和兼容性考虑是否使用。</p>
<h3 id="_33-在css-js代码上线之后-开发人员经常会优化性能。从用户刷新网页开始-一次js请求一般情况下有哪些地方会有缓存处理"><a href="#_33-在css-js代码上线之后-开发人员经常会优化性能。从用户刷新网页开始-一次js请求一般情况下有哪些地方会有缓存处理" class="header-anchor">#</a> 33 在CSS/JS代码上线之后，开发人员经常会优化性能。从用户刷新网页开始，一次JS请求一般情况下有哪些地方会有缓存处理？</h3>
<p>在进行JS请求时，可以在以下几个地方进行缓存处理，以提高性能和减少资源加载时间：</p>
<ol><li><strong>DNS缓存</strong>：浏览器会缓存已解析的域名和对应的IP地址，这样在下次请求同一域名时可以直接使用缓存的IP地址，避免重新进行DNS解析。</li> <li><strong>CDN缓存</strong>：如果使用了内容分发网络（CDN），CDN会缓存静态资源文件，如CSS和JS文件，以便快速地分发给用户。当用户再次请求同一资源时，可以从CDN缓存中获取，减少向源服务器的请求次数。</li> <li><strong>浏览器缓存</strong>：浏览器会缓存已请求的静态资源文件，如CSS和JS文件。可以通过设置HTTP响应头中的<code>Cache-Control</code>和<code>Expires</code>字段来控制浏览器缓存的行为。如果设置了适当的缓存策略，浏览器在下次请求同一资源时可以直接从本地缓存中获取，而不需要再次向服务器请求。</li> <li><strong>服务器缓存</strong>：服务器可以对动态生成的JS文件进行缓存，以避免重复生成相同的响应。服务器可以通过设置响应头中的<code>Cache-Control</code>和<code>Expires</code>字段，或者使用缓存代理服务器来进行缓存处理。</li></ol>
<p>需要注意的是，缓存的有效期限和缓存策略的设置需要根据具体的需求和业务场景来确定。合理地利用缓存可以显著提高网页加载速度和用户体验。</p>
<h3 id="_33-一个页面上有大量的图片-大型电商网站-加载很慢-你有哪些方法优化这些图片的加载-给用户更好的体验。"><a href="#_33-一个页面上有大量的图片-大型电商网站-加载很慢-你有哪些方法优化这些图片的加载-给用户更好的体验。" class="header-anchor">#</a> 33 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。</h3>
<ul><li><strong>使用图像压缩技术</strong>：通过使用图像压缩工具，如PhotoShop、TinyPNG等，将图片文件的大小减小，以减少加载时间。</li> <li><strong>使用适当的图像格式</strong>：根据图像的特性选择合适的图像格式，如JPEG、PNG、WebP等。JPEG适用于照片和复杂图像，而PNG适用于简单的图标和透明图像。WebP是一种现代的图像格式，可以在保持良好质量的同时减小文件大小。</li> <li><strong>图片CDN加速</strong>：使用内容分发网络（CDN）来加速图片的传输，将图片文件缓存到离用户更近的服务器，减少传输时间。</li> <li><strong>图片延迟加载</strong>：采用图片懒加载技术，将页面上不可见区域的图片暂时不加载，当用户滚动页面至可见区域时再进行加载，以减少初始加载时间。</li> <li><strong>使用CSS精灵图</strong>：将多个小图标或背景图片合并为一张大图，并利用CSS的<code>background-position</code>来定位显示需要的部分，减少HTTP请求的数量。</li> <li><strong>使用矢量图形</strong>：使用矢量图形（如SVG）代替位图，以减小文件大小并保持清晰度，适用于简单的图形和图标。</li> <li><strong>响应式图片</strong>：针对不同的设备和屏幕尺寸提供适当大小的图片，以避免在小屏幕设备上加载过大的图片。</li> <li><strong>图片懒加载、预加载</strong>：根据用户的浏览行为，提前加载下一页或下一组图片，以提高用户体验和流畅度。</li> <li><strong>图片缓存</strong>：设置适当的缓存策略，让浏览器在首次加载后对图片进行缓存，减少重复加载的次数。</li></ul>
<p>综合应用这些优化技术可以减小图片的加载大小和加载时间，提升网页的加载速度，给用户更好的体验。</p>
<h3 id="_34-常见排序算法的时间复杂度-空间复杂度"><a href="#_34-常见排序算法的时间复杂度-空间复杂度" class="header-anchor">#</a> 34 常见排序算法的时间复杂度,空间复杂度</h3>
<p>下面是一些常见的排序算法及其时间复杂度和空间复杂度的概述：</p>
<ol><li>冒泡排序（Bubble Sort）：</li></ol>
<ul><li>时间复杂度：最好情况下<code>O(n)</code>，平均和最坏情况下<code>O(n^2)</code></li> <li>空间复杂度：<code>O(1)</code></li></ul>
<ol start="2"><li>插入排序（Insertion Sort）：</li></ol>
<ul><li>时间复杂度：最好情况下<code>O(n)</code>，平均和最坏情况下<code>O(n^2)</code></li> <li>空间复杂度：<code>O(1)</code></li></ul>
<ol start="3"><li>选择排序（Selection Sort）：</li></ol>
<ul><li>时间复杂度：最好情况下<code>O(n^2)</code>，平均和最坏情况下<code>O(n^2)</code></li> <li>空间复杂度：<code>O(1)</code></li></ul>
<ol start="4"><li>快速排序（Quick Sort）：</li></ol>
<ul><li>时间复杂度：最好情况下<code>O(nlogn)</code>，平均情况下<code>O(nlogn)</code>，最坏情况下<code>O(n^2)</code></li> <li>空间复杂度：最好情况下<code>O(logn)</code>，平均和最坏情况下<code>O(n)</code></li></ul>
<ol start="5"><li>归并排序（Merge Sort）：</li></ol>
<ul><li>时间复杂度：最好情况下<code>O(nlogn)</code>，平均情况下<code>O(nlogn)</code>，最坏情况下<code>O(nlogn)</code></li> <li>空间复杂度：<code>O(n)</code></li></ul>
<ol start="6"><li>堆排序（Heap Sort）：</li></ol>
<ul><li>时间复杂度：最好情况下<code>O(nlogn)</code>，平均情况下<code>O(nlogn)</code>，最坏情况下<code>O(nlogn)</code></li> <li>空间复杂度：<code>O(1)</code></li></ul>
<ol start="7"><li>希尔排序（Shell Sort）：</li></ol>
<ul><li>时间复杂度：取决于所选的间隔序列，最好情况下<code>O(nlogn)</code>，平均和最坏情况下根据间隔序列的选择而不同</li> <li>空间复杂度：<code>O(1)</code></li></ul>
<ol start="8"><li>计数排序（Counting Sort）：</li></ol>
<ul><li>时间复杂度：最好情况下<code>O(n+k)</code>，平均和最坏情况下<code>O(n+k)</code></li> <li>空间复杂度：<code>O(k)</code>，其中 <code>k</code> 是计数范围</li></ul>
<ol start="9"><li>桶排序（Bucket Sort）：</li></ol>
<ul><li>时间复杂度：最好情况下<code>O(n+k)</code>，平均和最坏情况下根据桶的数量和排序算法的选择而不同</li> <li>空间复杂度：<code>O(n+k)</code></li></ul>
<ol start="10"><li>基数排序（Radix Sort）：</li></ol>
<ul><li>时间复杂度：最好情况下<code>O(nk)</code>，平均和最坏情况下<code>O(nk)</code></li> <li>空间复杂度：<code>O(n+k)</code></li></ul>
<p><img alt="" src="https://s.poetries.top/cos/202204032131039.png"> <img alt="" src="https://s.poetries.top/uploads/2023/01/553d2314d0d81dfe.png"></p>
<h3 id="_35-web开发中会话跟踪的方法有哪些"><a href="#_35-web开发中会话跟踪的方法有哪些" class="header-anchor">#</a> 35 web开发中会话跟踪的方法有哪些</h3>
<ul><li><strong>Cookie</strong>: 使用Cookie是最常见的会话跟踪方法之一。服务器在响应中设置一个包含会话ID的Cookie，然后在后续的请求中，浏览器会自动将该Cookie发送回服务器，以标识用户的会话。</li> <li><strong>Session</strong>: 服务器使用会话来跟踪用户的状态。每个会话都会分配一个唯一的会话ID，该ID通常存储在Cookie中或通过URL重写传递给服务器。服务器使用会话ID来关联用户的请求，并在服务器端存储会话数据。</li> <li><strong>URL重写</strong>: 将会话ID作为查询参数添加到URL中，以便在每个请求中传递会话信息。这种方法不需要依赖Cookie，适用于禁用Cookie的情况，但会增加URL的长度并暴露会话信息。</li> <li><strong>隐藏input</strong>: 在表单中添加一个隐藏的input字段，将会话ID作为其值传递给服务器。服务器接收到请求时可以通过解析请求参数获取会话ID，以进行会话跟踪。</li> <li><strong>IP地址</strong>: 使用客户端的IP地址作为会话跟踪的依据。服务器根据不同的IP地址来区分不同的用户，并跟踪他们的会话状态。然而，由于多个用户可能共享相同的IP地址（如在同一局域网内），这种方法可能不准确。</li></ul>
<p>这些方法可以单独或结合使用，根据实际需求和安全考虑选择适当的会话跟踪方法。</p>
<h3 id="_36-http-request报文结构是怎样的"><a href="#_36-http-request报文结构是怎样的" class="header-anchor">#</a> 36 HTTP request报文结构是怎样的</h3>
<ol><li>首行是<strong>Request-Line</strong>包括：<strong>请求方法</strong>，<strong>请求URI</strong>，<strong>协议版本</strong>，<strong>CRLF</strong></li> <li>首行之后是若干行<strong>请求头</strong>，包括<strong>general-header</strong>，<strong>request-header</strong>或者<strong>entity-header</strong>，每个一行以CRLF结束</li> <li>请求头和消息实体之间有一个<strong>CRLF分隔</strong></li> <li>根据实际请求需要可能包含一个<strong>消息实体</strong>
一个请求报文例子如下：</li></ol>
<div class="language- extra-class"><pre class="language-text"><code>GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: "2cc8-3e3073913b100"
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT

name=qiu&amp;age=25
</code></pre></div>
<h3 id="_37-http-response报文结构是怎样的"><a href="#_37-http-response报文结构是怎样的" class="header-anchor">#</a> 37 HTTP response报文结构是怎样的</h3>
<ul><li>首行是状态行包括：<strong>HTTP版本，状态码，状态描述</strong>，后面跟一个CRLF</li> <li>首行之后是<strong>若干行响应头</strong>，包括：<strong>通用头部，响应头部，实体头部</strong></li> <li>响应头部和响应实体之间用<strong>一个CRLF空行</strong>分隔</li> <li>最后是一个可能的<strong>消息实体</strong></li></ul>
<p>响应报文例子如下：</p>
<div class="language- extra-class"><pre class="language-text"><code>HTTP/1.1 200 OK
Date: Tue, 08 Jul 2014 05:28:43 GMT
Server: Apache/2
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
ETag: "40d7-3e3073913b100"
Accept-Ranges: bytes
Content-Length: 16599
Cache-Control: max-age=21600
Expires: Tue, 08 Jul 2014 11:28:43 GMT
P3P: policyref="http://www.w3.org/2001/05/P3P/p3p.xml"
Content-Type: text/html; charset=iso-8859-1

{"name": "qiu", "age": 25}
</code></pre></div>
<h3 id="_38-title与h1的区别、b与strong的区别、i与em的区别"><a href="#_38-title与h1的区别、b与strong的区别、i与em的区别" class="header-anchor">#</a> 38 title与h1的区别、b与strong的区别、i与em的区别</h3>
<ul><li><code>title</code>属性用于提供元素的额外信息，通常以工具提示的形式显示。它没有语义化的意义，仅表示一个标题或描述性文本。它在SEO中没有直接影响，但可以提供更好的用户体验和辅助工具提示。</li> <li><code>&lt;h1&gt;</code>是HTML中的标题元素，用于表示页面的主标题。它具有层次结构，表示文档的结构和内容。搜索引擎通常会将<code>&lt;h1&gt;</code>标签中的文本作为页面的主要标题，并根据其重要性进行权重分配。</li> <li><code>&lt;b&gt;</code>是用于粗体显示文本的HTML元素，仅仅表示展示的效果，没有语义上的强调意义。在使用屏幕阅读器等辅助工具阅读网页时，<code>&lt;b&gt;</code>不会改变读取方式，仅仅呈现粗体效果。</li> <li><code>&lt;strong&gt;</code>是表示文本的强调元素，具有语义化的含义，用于强调重要内容。在屏幕阅读器等辅助工具中，会以更加强调的方式读取<code>&lt;strong&gt;</code>标签中的文本，传达给用户更强的语气。</li> <li><code>&lt;i&gt;</code>用于将文本显示为斜体，仅表示展示的效果，没有语义上的强调意义。</li> <li><code>&lt;em&gt;</code>表示强调的文本，具有语义化的含义，用于强调某些内容。在屏幕阅读器等辅助工具中，会以更加强调的方式读取<code>&lt;em&gt;</code>标签中的文本，传达给用户更强的强调效果。</li></ul>
<p><strong>总结：</strong></p>
<ul><li><code>&lt;title&gt;</code>和<code>&lt;h1&gt;</code>在语义化和SEO方面有区别，一个用于页面标题，一个用于内容标题。</li> <li><code>&lt;b&gt;</code>和<code>&lt;strong&gt;</code>都可以用于加粗文本，但<code>&lt;strong&gt;</code>具有语义化的强调效果。</li> <li><code>&lt;i&gt;</code>和<code>&lt;em&gt;</code>都可以用于斜体文本，但<code>&lt;em&gt;</code>具有语义化的强调效果。</li></ul>
<h3 id="_39-请你谈谈cookie的弊端"><a href="#_39-请你谈谈cookie的弊端" class="header-anchor">#</a> 39 请你谈谈Cookie的弊端</h3>
<p><code>cookie</code>虽然在存储客户端数据方面提供了方便，并减轻了服务器的负担，但它也存在一些弊端和限制，包括：</p>
<ul><li><strong>数量限制</strong>：每个特定域名下的<code>cookie</code>数量有限。例如，旧版的<code>IE6</code>最多允许20个<code>cookie</code>，而<code>IE7</code>及更高版本允许50个<code>cookie</code>，其他浏览器也有类似的限制。</li> <li><strong>大小限制</strong>：每个<code>cookie</code>的大小也有限制，通常为约<code>4096</code>字节（不同浏览器可能有差异），为了兼容性，一般建议将<code>cookie</code>大小控制在<code>4095</code>字节以内。</li> <li><strong>清理策略</strong>：一些浏览器会根据策略清理过期或不常使用的<code>cookie</code>，这可能会导致某些数据丢失或需要重新设置。</li> <li><strong>安全性问题</strong>：<code>cookie</code>存储在客户端，如果被恶意拦截，攻击者可以获取其中的数据，包括<code>session</code>信息，可能导致安全隐患。</li> <li><strong>跨域限制</strong>：<code>cookie</code>在同源策略下工作，无法跨域访问。每个域名下的<code>cookie</code>只能被同域名的页面访问和修改。</li> <li><strong>对网络性能的影响</strong>：<code>cookie</code>会增加每个请求的数据量，从而增加了网络传输的开销，尤其在请求大量静态资源的网页时，会对加载速度产生一定的影响。</li></ul>
<p>要解决这些问题，可以使用其他存储方式，如<code>localStorage</code>或<code>sessionStorage</code>，使用服务器端存储来替代部分或全部<code>cookie</code>，或者通过其他技术手段来优化和管理<code>cookie</code>的使用。</p>
<h3 id="_40-git-fetch和git-pull的区别"><a href="#_40-git-fetch和git-pull的区别" class="header-anchor">#</a> 40 git fetch和git pull的区别</h3>
<ul><li><code>git pull</code>：执行<code>git pull</code>命令时，Git会自动从远程仓库下载最新的提交并将其合并到当前分支。它是<code>git fetch</code>和<code>git merge</code>两个操作的组合。它会自动将远程仓库的更新合并到当前分支，并自动解决可能的冲突。一般情况下，使用<code>git pull</code>可以快速获取远程最新代码并合并到本地分支。</li> <li><code>git fetch</code>：执行<code>git fetch</code>命令时，Git会从远程仓库下载最新的提交，但不会自动将其合并到当前分支。它只是将远程仓库的最新代码下载到本地，并更新本地仓库中远程分支的指针位置。这样，你可以在本地查看远程仓库的更新情况，进行代码比较或其他操作。但它不会修改你当前所在的分支。</li></ul>
<blockquote><p>总结：<code>git pull</code>是直接从远程仓库获取最新代码并合并到当前分支，而<code>git fetch</code>只是获取最新代码到本地，并不会自动合并。使用<code>git pull</code>可以更方便地获取最新代码并更新本地分支，而<code>git fetch</code>适合查看远程仓库的更新情况，进行代码比较或其他操作。</p></blockquote>
<h3 id="_41-http2-0-做了哪些改进-http3-0-呢"><a href="#_41-http2-0-做了哪些改进-http3-0-呢" class="header-anchor">#</a> 41 http2.0 做了哪些改进 http3.0 呢</h3>
<p><strong>HTTP/2 的特性包括：</strong></p>
<p><strong>1. 二进制分帧</strong></p>
<ul><li><strong>HTTP/1.x</strong>：基于文本格式，报文以明文形式传输，解析过程复杂且容易出错，效率较低。</li> <li><strong>HTTP/2</strong>：采用二进制分帧层，将所有传输的信息分割为更小的帧，并对这些帧进行二进制编码。帧是 HTTP/2 数据传输的最小单位，包括头帧和数据帧等。这种二进制分帧的方式使得协议的解析更加高效、准确，提高了数据传输的性能。</li></ul>
<p><strong>2. 多路复用</strong></p>
<ul><li><strong>HTTP/1.x</strong>：同一时间一个连接只能处理一个请求，当有多个请求时，需要依次排队等待处理，容易出现“队头阻塞”问题，即一个请求阻塞会影响后续请求的处理。</li> <li><strong>HTTP/2</strong>：通过多路复用机制，允许在一个连接上同时并行处理多个请求和响应。每个请求和响应被拆分成多个独立的帧，这些帧可以在连接上乱序发送和接收，然后在另一端根据帧的标识进行重新组装。这样可以充分利用网络带宽，提高连接的利用率，避免了“队头阻塞”问题。</li></ul>
<p><strong>3. 头部压缩</strong></p>
<ul><li><strong>HTTP/1.x</strong>：请求和响应的头部信息通常以明文形式重复传输，包含了很多重复的字段，如 <code>User - Agent</code>、<code>Cookie</code> 等，会占用大量的带宽。</li> <li><strong>HTTP/2</strong>：采用 HPACK 算法对头部信息进行压缩。HPACK 会维护一个静态表和一个动态表，对于重复出现的头部字段，只需要在表中存储一次，后续传输时只需传输对应的索引，从而大大减少了头部信息的传输量，降低了带宽消耗。</li></ul>
<p><strong>4. 服务器推送</strong></p>
<ul><li><strong>HTTP/1.x</strong>：客户端需要明确请求服务器上的资源，服务器只能被动响应客户端的请求，无法主动向客户端推送资源。</li> <li><strong>HTTP/2</strong>：支持服务器推送功能，服务器可以在客户端请求某个资源时，主动将客户端可能需要的其他资源一起推送给客户端。例如，当客户端请求一个 HTML 页面时，服务器可以同时推送该页面所需的 CSS、JavaScript 等资源，减少了客户端的请求次数，提高了页面的加载速度。</li></ul>
<p><strong>而 HTTP/3 则是基于 QUIC 协议的新一代 HTTP 协议。QUIC 是一个基于 UDP 的传输协议，具有以下特性：</strong></p>
<p><strong>1. 基于 QUIC 协议</strong></p>
<ul><li><strong>HTTP/2</strong>：仍然基于 TCP 协议，TCP 协议在处理丢包重传、拥塞控制等方面存在一些固有的问题，可能会导致“队头阻塞”问题，影响数据传输的性能。</li> <li><strong>HTTP/3</strong>：采用 QUIC（快速 UDP 互联网连接）协议作为传输层协议。QUIC 基于 UDP 实现，但在 UDP 的基础上增加了可靠传输、拥塞控制、加密等功能。QUIC 协议的连接建立速度更快，并且在丢包情况下不会影响其他流的传输，避免了 TCP 协议中的“队头阻塞”问题，进一步提高了数据传输的性能和可靠性。</li></ul>
<p><strong>2. 连接迁移</strong></p>
<ul><li><strong>HTTP/2</strong>：基于 TCP 协议，TCP 连接依赖于源 IP 地址、目的 IP 地址、源端口和目的端口，当设备的网络环境发生变化（如从 Wi - Fi 切换到移动数据网络）时，TCP 连接会中断，需要重新建立连接，这可能会导致数据传输中断和延迟。</li> <li><strong>HTTP/3</strong>：QUIC 协议通过连接 ID 来标识连接，而不是依赖于 IP 地址和端口。当设备的网络环境发生变化时，只要连接 ID 不变，QUIC 连接可以保持不变，实现无缝的连接迁移，提高了用户体验。</li></ul>
<p><strong>3. 更灵活的拥塞控制</strong></p>
<ul><li><strong>HTTP/2</strong>：TCP 协议的拥塞控制算法是固定的，不同的网络环境可能需要不同的拥塞控制策略，TCP 难以快速适应网络变化。</li> <li><strong>HTTP/3</strong>：QUIC 协议的拥塞控制更加灵活，可以根据不同的网络情况动态调整拥塞控制策略，更好地适应各种复杂的网络环境，提高数据传输的效率。</li></ul>
<p><strong>总结</strong>：<code>HTTP/2</code> 和 <code>HTTP/3</code> 都是在传输层进行的协议改进，<code>HTTP/2</code> 在 <code>TCP</code> 上引入了二进制分帧传输、多路复用、头部压缩和服务器推送等特性，而 <code>HTTP/3</code> 则是基于 <code>UDP</code> 的 <code>QUIC</code> 协议，引入了连接迁移、无队头阻塞、自定义拥塞控制和前向安全和前向纠错等新特性。</p>
</div>