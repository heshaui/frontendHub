<!-- Section: # 27 实现LRU淘汰算法 -->
<div class="section-content" data-section-id="_27-实现lru淘汰算法">
<h2 id="_27-实现lru淘汰算法"><a href="#_27-实现lru淘汰算法" class="header-anchor">#</a> 27 实现LRU淘汰算法</h2>
<p><code>LRU</code> 缓存算法是一个非常经典的算法，在很多面试中经常问道，不仅仅包括前端面试</p>
<blockquote><p><code>LRU</code> 英文全称是 <code>Least Recently Used</code>，英译过来就是”<strong>最近最少使用</strong>“的意思。<code>LRU</code> 是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 <code>t</code>，当须淘汰一个页面时，选择现有页面中其 <code>t</code> 值最大的，即最近最少使用的页面予以淘汰</p></blockquote>
<p>通俗的解释：</p>
<blockquote><p>假如我们有一块内存，专门用来缓存我们最近发访问的网页，访问一个新网页，我们就会往内存中添加一个网页地址，随着网页的不断增加，内存存满了，这个时候我们就需要考虑删除一些网页了。这个时候我们找到内存中最早访问的那个网页地址，然后把它删掉。这一整个过程就可以称之为 <code>LRU</code> 算法</p></blockquote>
<p><img alt="" src="https://s.poetries.top/uploads/2022/08/d7207b1a48380fe1.png"></p>
<p>上图就很好的解释了 <code>LRU</code> 算法在干嘛了，其实非常简单，无非就是我们往内存里面添加或者删除元素的时候，遵循<strong>最近最少使用原则</strong></p>
<p><strong>使用场景</strong></p>
<p><code>LRU</code> 算法使用的场景非常多，这里简单举几个例子即可：</p>
<ul><li>我们操作系统底层的内存管理，其中就包括有 <code>LRU</code> 算法</li> <li>我们常见的缓存服务，比如 <code>redis</code> 等等</li> <li>比如浏览器的最近浏览记录存储</li> <li><code>vue</code>中的<code>keep-alive</code>组件使用了<code>LRU</code>算法</li></ul>
<p><strong>梳理实现 LRU 思路</strong></p>
<ul><li>特点分析：
<ul><li>我们需要一块有限的存储空间，因为无限的化就没必要使用<code>LRU</code>算发删除数据了。</li> <li>我们这块存储空间里面存储的数据需要是有序的，因为我们必须要顺序来删除数据，所以可以考虑使用 <code>Array</code>、<code>Map</code> 数据结构来存储，不能使用 <code>Object</code>，因为它是无序的。</li> <li>我们能够删除或者添加以及获取到这块存储空间中的指定数据。</li> <li>存储空间存满之后，在添加数据时，会自动删除时间最久远的那条数据。</li></ul></li> <li>实现需求：
<ul><li>实现一个 <code>LRUCache</code> 类型，用来充当存储空间</li> <li>采用 <code>Map</code> 数据结构存储数据，因为它的存取时间复杂度为 <code>O(1)</code>，数组为 <code>O(n)</code></li> <li>实现 <code>get</code> 和 <code>set</code> 方法，用来获取和添加数据</li> <li>我们的存储空间有长度限制，所以无需提供删除方法，存储满之后，自动删除最久远的那条数据</li> <li>当使用 <code>get</code> 获取数据后，该条数据需要更新到最前面</li></ul></li></ul>
<p><strong>具体实现</strong></p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">=</span> length<span class="token punctuation">;</span> <span class="token comment">// 存储长度</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 存储数据</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 存储数据，通过键值对的方式</span>
  <span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span>

    <span class="token comment">// 有的话 删除 重建放到map最前面</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      data<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    data<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果超出了容量，则需要删除最久的数据</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span>size <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 删除map最老的数据</span>
      <span class="token keyword">const</span> delKey <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
      data<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>delKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 获取数据</span>
  <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span>
    <span class="token comment">// 未找到</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>data<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> value <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取元素</span>
    data<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除元素</span>
    data<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重新插入元素到map最前面</span>

    <span class="token keyword">return</span> value <span class="token comment">// 返回获取的值</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> lruCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<ul><li><code>set 方法</code>：往 <code>map</code> 里面添加新数据，如果添加的数据存在了，则先删除该条数据，然后再添加。如果添加数据后超长了，则需要删除最久远的一条数据。<code>data.keys().next().value</code> 便是获取最后一条数据的意思。</li> <li><code>get 方法</code>：首先从 <code>map</code> 对象中拿出该条数据，然后删除该条数据，最后再重新插入该条数据，确保将该条数据移动到最前面</li></ul>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 测试</span>

<span class="token comment">// 存储数据 set：</span>

lruCache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lruCache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lruCache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'sex'</span><span class="token punctuation">,</span> <span class="token string">'男'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lruCache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'height'</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lruCache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'weight'</span><span class="token punctuation">,</span> <span class="token string">'120'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>lruCache<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<p><img alt="" src="https://s.poetries.top/uploads/2022/08/9e0bd322b89a3ad1.png"></p>
<p>继续插入数据，此时会超长，代码如下：</p>
<div class="language-js extra-class"><pre class="language-js"><code>lruCache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'grade'</span><span class="token punctuation">,</span> <span class="token string">'100'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>lruCache<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<p><img alt="" src="https://s.poetries.top/uploads/2022/08/86fb38a46220b2a0.png"></p>
<p>此时我们发现存储时间最久的 name 已经被移除了，新插入的数据变为了最前面的一个。</p>
<p>我们使用 <code>get</code> 获取数据，代码如下：</p>
<p><img alt="" src="https://s.poetries.top/uploads/2022/08/414393277d71fee4.png"></p>
<p>我们发现此时 <code>sex</code> 字段已经跑到最前面去了</p>
<p><strong>总结</strong></p>
<blockquote><p><code>LRU</code> 算法其实逻辑非常的简单，明白了原理之后实现起来非常的简单。最主要的是我们需要使用什么数据结构来存储数据，因为 <code>map</code> 的存取非常快，所以我们采用了它，当然数组其实也可以实现的。还有一些小伙伴使用链表来实现 <code>LRU</code>，这当然也是可以的。</p></blockquote>
</div>