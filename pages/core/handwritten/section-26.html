<!-- Section: # 26 实现Node的require方法 -->
<div class="section-content" data-section-id="_26-实现node的require方法">
<h2 id="_26-实现node的require方法"><a href="#_26-实现node的require方法" class="header-anchor">#</a> 26 实现Node的require方法</h2>
<p><strong>require 基本原理</strong></p>
<p><img alt="" src="https://s.poetries.top/uploads/2022/08/9aa839dd23f565a0.png"></p>
<p><strong>require 查找路径</strong></p>
<p><img alt="" src="https://s.poetries.top/uploads/2022/08/fbd4839b18db27cd.png"></p>
<blockquote><p><code>require</code> 和 <code>module.exports</code> 干的事情并不复杂，我们先假设有一个全局对象<code>{}</code>，初始情况下是空的，当你 <code>require</code> 某个文件时，就将这个文件拿出来执行，如果这个文件里面存在<code>module.exports</code>，当运行到这行代码时将 <code>module.exports</code> 的值加入这个对象，键为对应的文件名，最终这个对象就长这样：</p></blockquote>
<div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">"a.js"</span><span class="token operator">:</span> <span class="token string">"hello world"</span><span class="token punctuation">,</span>
  <span class="token property">"b.js"</span><span class="token operator">:</span> function add()<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"c.js"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token property">"d.js"</span><span class="token operator">:</span> <span class="token punctuation">{</span> num<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<blockquote><p>当你再次 <code>require</code> 某个文件时，如果这个对象里面有对应的值，就直接返回给你，如果没有就重复前面的步骤，执行目标文件，然后将它的 <code>module.exports</code> 加入这个全局对象，并返回给调用者。这个全局对象其实就是我们经常听说的缓存。所以 <code>require</code> 和 <code>module.exports</code> 并没有什么黑魔法，就只是运行并获取目标文件的值，然后加入缓存，用的时候拿出来用就行</p></blockquote>
<p><strong>手写实现一个require</strong></p>
<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 路径操作</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 文件读取</span>
<span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vm'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 文件执行</span>

<span class="token comment">// node模块化的实现</span>
<span class="token comment">// node中是自带模块化机制的，每个文件就是一个单独的模块，并且它遵循的是CommonJS规范，也就是使用require的方式导入模块，通过module.export的方式导出模块。</span>
<span class="token comment">// node模块的运行机制也很简单，其实就是在每一个模块外层包裹了一层函数，有了函数的包裹就可以实现代码间的作用域隔离</span>

<span class="token comment">// require加载模块</span>
<span class="token comment">// require依赖node中的fs模块来加载模块文件，fs.readFile读取到的是一个字符串。</span>
<span class="token comment">// 在javascrpt中我们可以通过eval或者new Function的方式来将一个字符串转换成js代码来运行。</span>

<span class="token comment">// eval</span>
<span class="token comment">// const name = 'poetry';</span>
<span class="token comment">// const str = 'const a = 123; console.log(name)';</span>
<span class="token comment">// eval(str); // poetry;</span>

<span class="token comment">// new Function</span>
<span class="token comment">// new Function接收的是一个要执行的字符串，返回的是一个新的函数，调用这个新的函数字符串就会执行了。如果这个函数需要传递参数，可以在new Function的时候依次传入参数，最后传入的是要执行的字符串。比如这里传入参数b，要执行的字符串str</span>
<span class="token comment">// const b = 3;</span>
<span class="token comment">// const str = 'let a = 1; return a + b';</span>
<span class="token comment">// const fun = new Function('b', str);</span>
<span class="token comment">// console.log(fun(b, str)); // 4</span>
<span class="token comment">// 可以看到eval和Function实例化都可以用来执行javascript字符串，似乎他们都可以来实现require模块加载。不过在node中并没有选用他们来实现模块化，原因也很简单因为他们都有一个致命的问题，就是都容易被不属于他们的变量所影响。</span>
<span class="token comment">// 如下str字符串中并没有定义a，但是确可以使用上面定义的a变量，这显然是不对的，在模块化机制中，str字符串应该具有自身独立的运行空间，自身不存在的变量是不可以直接使用的</span>
<span class="token comment">// const a = 1;</span>
<span class="token comment">// const str = 'console.log(a)';</span>
<span class="token comment">// eval(str);</span>
<span class="token comment">// const func = new Function(str);</span>
<span class="token comment">// func();</span>

<span class="token comment">// node存在一个vm虚拟环境的概念，用来运行额外的js文件，他可以保证javascript执行的独立性，不会被外部所影响</span>
<span class="token comment">// vm 内置模块</span>
<span class="token comment">// 虽然我们在外部定义了hello，但是str是一个独立的模块，并不在村hello变量，所以会直接报错。</span>
<span class="token comment">// 引入vm模块， 不需要安装，node 自建模块</span>
<span class="token comment">// const vm = require('vm');</span>
<span class="token comment">// const hello = 'poetry';</span>
<span class="token comment">// const str = 'console.log(hello)';</span>
<span class="token comment">// wm.runInThisContext(str); // 报错</span>
<span class="token comment">// 所以node执行javascript模块时可以采用vm来实现。就可以保证模块的独立性了</span>

<span class="token comment">// 分析实现步骤</span>
<span class="token comment">// 1.导入相关模块，创建一个Require方法。</span>
<span class="token comment">// 2.抽离通过Module._load方法，用于加载模块。</span>
<span class="token comment">// 3.Module.resolveFilename 根据相对路径，转换成绝对路径。</span>
<span class="token comment">// 4.缓存模块 Module._cache，同一个模块不要重复加载，提升性能。</span>
<span class="token comment">// 5.创建模块 id: 保存的内容是 exports = {}相当于this。</span>
<span class="token comment">// 6.利用tryModuleLoad(module, filename) 尝试加载模块。</span>
<span class="token comment">// 7.Module._extensions使用读取文件。</span>
<span class="token comment">// 8.Module.wrap: 把读取到的js包裹一个函数。</span>
<span class="token comment">// 9.将拿到的字符串使用runInThisContext运行字符串。</span>
<span class="token comment">// 10.让字符串执行并将this改编成exports</span>

<span class="token comment">// 定义导入类，参数为模块路径</span>
<span class="token keyword">function</span> <span class="token function">Require</span><span class="token punctuation">(</span><span class="token parameter">modulePath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取当前要加载的绝对路径</span>
    <span class="token keyword">let</span> absPathname <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> modulePath<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 自动给模块添加后缀名，实现省略后缀名加载模块，其实也就是如果文件没有后缀名的时候遍历一下所有的后缀名看一下文件是否存在</span>
    <span class="token comment">// 获取所有后缀名</span>
    <span class="token keyword">const</span> extNames <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>Module<span class="token punctuation">.</span>_extensions<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 存储原始文件路径</span>
    <span class="token keyword">const</span> oldPath <span class="token operator">=</span> absPathname<span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">findExt</span><span class="token punctuation">(</span><span class="token parameter">absPathname</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> extNames<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'文件不存在'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            fs<span class="token punctuation">.</span><span class="token function">accessSync</span><span class="token punctuation">(</span>absPathname<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> absPathname<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> ext <span class="token operator">=</span> extNames<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token function">findExt</span><span class="token punctuation">(</span>oldPath <span class="token operator">+</span> ext<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 递归追加后缀名，判断文件是否存在</span>
    absPathname <span class="token operator">=</span> <span class="token function">findExt</span><span class="token punctuation">(</span>absPathname<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 从缓存中读取，如果存在，直接返回结果</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Module<span class="token punctuation">.</span>_cache<span class="token punctuation">[</span>absPathname<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Module<span class="token punctuation">.</span>_cache<span class="token punctuation">[</span>absPathname<span class="token punctuation">]</span><span class="token punctuation">.</span>exports<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 创建模块，新建Module实例</span>
    <span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Module</span><span class="token punctuation">(</span>absPathname<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 添加缓存</span>
    Module<span class="token punctuation">.</span>_cache<span class="token punctuation">[</span>absPathname<span class="token punctuation">]</span> <span class="token operator">=</span> module<span class="token punctuation">;</span>

    <span class="token comment">// 加载当前模块</span>
    <span class="token function">tryModuleLoad</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 返回exports对象</span>
    <span class="token keyword">return</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Module的实现很简单，就是给模块创建一个exports对象，tryModuleLoad执行的时候将内容加入到exports中，id就是模块的绝对路径</span>
<span class="token comment">// 定义模块, 添加文件id标识和exports属性</span>
<span class="token keyword">function</span> <span class="token function">Module</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token comment">// 读取到的文件内容会放在exports中</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Module<span class="token punctuation">.</span>_cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 我们给Module挂载静态属性wrapper，里面定义一下这个函数的字符串，wrapper是一个数组，数组的第一个元素就是函数的参数部分，其中有exports，module. Require，__dirname, __filename, 都是我们模块中常用的全局变量。注意这里传入的Require参数是我们自己定义的Require</span>
<span class="token comment">// 第二个参数就是函数的结束部分。两部分都是字符串，使用的时候我们将他们包裹在模块的字符串外部就可以了</span>
Module<span class="token punctuation">.</span>wrapper <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">"(function(exports, module, Require, __dirname, __filename) {"</span><span class="token punctuation">,</span>
    <span class="token string">"})"</span>
<span class="token punctuation">]</span>

<span class="token comment">// _extensions用于针对不同的模块扩展名使用不同的加载方式，比如JSON和javascript加载方式肯定是不同的。JSON使用JSON.parse来运行。</span>
<span class="token comment">// javascript使用vm.runInThisContext来运行，可以看到fs.readFileSync传入的是module.id也就是我们Module定义时候id存储的是模块的绝对路径，读取到的content是一个字符串，我们使用Module.wrapper来包裹一下就相当于在这个模块外部又包裹了一个函数，也就实现了私有作用域。</span>
<span class="token comment">// 使用call来执行fn函数，第一个参数改变运行的this我们传入module.exports，后面的参数就是函数外面包裹参数exports, module, Require, __dirname, __filename</span>
Module<span class="token punctuation">.</span>_extensions <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token string">'.js'</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> content <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span>id<span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> fnStr <span class="token operator">=</span> Module<span class="token punctuation">.</span>wrapper<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> content <span class="token operator">+</span> Module<span class="token punctuation">.</span>wrapper<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> fn <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">runInThisContext</span><span class="token punctuation">(</span>fnStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span>exports<span class="token punctuation">,</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">,</span> module<span class="token punctuation">,</span> Require<span class="token punctuation">,</span>__filename<span class="token punctuation">,</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">'.json'</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> json <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span>id<span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 把文件的结果放在exports属性上</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// tryModuleLoad函数接收的是模块对象，通过path.extname来获取模块的后缀名，然后使用Module._extensions来加载模块</span>
<span class="token comment">// 定义模块加载方法</span>
<span class="token keyword">function</span> <span class="token function">tryModuleLoad</span><span class="token punctuation">(</span><span class="token parameter">module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取扩展名</span>
    <span class="token keyword">const</span> extension <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">extname</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 通过后缀加载当前模块</span>
    Module<span class="token punctuation">.</span>_extensions<span class="token punctuation">[</span>extension<span class="token punctuation">]</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 至此Require加载机制我们基本就写完了，我们来重新看一下。Require加载模块的时候传入模块名称，在Require方法中使用path.resolve(__dirname, modulePath)获取到文件的绝对路径。然后通过new Module实例化的方式创建module对象，将模块的绝对路径存储在module的id属性中，在module中创建exports属性为一个json对象</span>
<span class="token comment">// 使用tryModuleLoad方法去加载模块，tryModuleLoad中使用path.extname获取到文件的扩展名，然后根据扩展名来执行对应的模块加载机制</span>
<span class="token comment">// 最终将加载到的模块挂载module.exports中。tryModuleLoad执行完毕之后module.exports已经存在了，直接返回就可以了</span>


<span class="token comment">// 给模块添加缓存</span>
<span class="token comment">// 添加缓存也比较简单，就是文件加载的时候将文件放入缓存中，再去加载模块时先看缓存中是否存在，如果存在直接使用，如果不存在再去重新，加载之后再放入缓存</span>

<span class="token comment">// 测试</span>
<span class="token keyword">let</span> json <span class="token operator">=</span> <span class="token function">Require</span><span class="token punctuation">(</span><span class="token string">'./test.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> test2 <span class="token operator">=</span> <span class="token function">Require</span><span class="token punctuation">(</span><span class="token string">'./test2.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
</div>